

----STARTUP---- (27 April 2024 12:17:38) as /home/ivan/Documents/Facu/Inge 1/linux64/linux64/CuisUniversity-6169.image!


----End fileIn of /home/ivan/Downloads/ISW1-2023-2C-Parcial-1.st----!
!Delantero methodsFor: 'no messages' stamp: 'I 4/27/2024 12:24:08'!
decideTirarAColocarSuFuerzaBaseEs: cantidadDeFuerzaALanzar! !
!Pelota methodsFor: 'nil' stamp: 'I 4/27/2024 12:29:23'!
jabulaniSudafricanaRapida! !

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'I 4/27/2024 12:29:56'!
ERROR!

Object subclass: #Delantero
	instanceVariableNames: 'fuerzaPateada'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Delantero category: #'ISW1-2023-2C-Parcial-1' stamp: 'I 4/27/2024 12:30:27'!
Object subclass: #Delantero
	instanceVariableNames: 'fuerzaPateada'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Delantero methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 12:30:50' prior: 50528023!
decideTirarAColocarSuFuerzaBaseEs: cantidadDeFuerzaALanzar
	^fuerzaPateada := cantidadDeFuerzaALanzar! !
!Penales methodsFor: 'nil' stamp: 'I 4/27/2024 12:34:35'!
conDelantero: delantero yArquero: arquero! !
!Penales methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 12:35:20' prior: 50528053!
conDelantero: delantero yArquero: arquero
	! !

Object subclass: #Penales
	instanceVariableNames: 'delantero arquero'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Penales methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 12:35:53' prior: 50528058!
conDelantero: delanteroAPatear yArquero: arqueroAAtajar
	! !

Object subclass: #Penales
	instanceVariableNames: 'delantero arquero'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Penales category: #'ISW1-2023-2C-Parcial-1' stamp: 'I 4/27/2024 12:36:01'!
Object subclass: #Penales
	instanceVariableNames: 'delantero arquero'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Penales methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 12:42:03' prior: 50528068!
conDelantero: delanteroAPatear yArquero: arqueroAAtajar
	delantero := delanteroAPatear.
	arquero := arqueroAAtajar.
	^self
	! !
!Arquero methodsFor: 'nil' stamp: 'I 4/27/2024 12:42:44'!
esperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaParaAtajar
! !

Object subclass: #Arquero
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Arquero category: #'ISW1-2023-2C-Parcial-1' stamp: 'I 4/27/2024 12:42:53'!
Object subclass: #Arquero
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Arquero methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 12:43:06' prior: 50528092!
esperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaParaAtajar
	fuerza:= fuerzaParaAtajar.! !

Object subclass: #Pelota
	instanceVariableNames: 'pelotaAUsar'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Pelota category: #'ISW1-2023-2C-Parcial-1' stamp: 'I 4/27/2024 12:43:20'!
Object subclass: #Pelota
	instanceVariableNames: 'pelotaAUsar'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Pelota methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 12:43:39' prior: 50528027!
jabulaniSudafricanaRapida
	| pelotaAUSar |
	pelotaAUSar := #Jabulani.! !
!Pelota methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 12:43:53' prior: 50528127!
jabulaniSudafricanaRapida

	pelotaAUsar := #Jabulani.! !
!Pelota methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 12:43:56' prior: 50528133!
jabulaniSudafricanaRapida

	^pelotaAUsar := #Jabulani.! !
!Pelota methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 12:44:30' prior: 50528138!
jabulaniSudafricanaRapida

	pelotaAUsar := #Jabulani.
	^self.! !
!Pelota methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 12:44:56' prior: 50528143!
jabulaniSudafricanaRapida

	^pelotaAUsar := #Jabulani.
	! !

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'I 4/27/2024 12:45:29'!
ERROR!
!Delantero class methodsFor: 'nil' stamp: 'I 4/27/2024 12:48:10'!
decideTirarAColocarSuFuerzaBaseEs: cantidadDeFuerzaALanzar
	^self new initializeEstrategiaTiro: #aColocar              			withFuerzaBase:cantidadDeFuerzaALanzar! !
!Delantero class methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 12:48:24'!
decideTirarAMatarSuFuerzaBaseEs: cantidadDeFuerzaALanzar
	^self new initializeEstrategiaTiro: #aMatar            			withFuerzaBase:cantidadDeFuerzaALanzar! !
!Delantero methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 12:48:41'!
decideTirarAMatarSuFuerzaBaseEs: cantidadDeFuerzaALanzar
	^self new initializeEstrategiaTiro: #aMatar            			withFuerzaBase:cantidadDeFuerzaALanzar! !

!methodRemoval: Delantero #decideTirarAColocarSuFuerzaBaseEs: stamp: 'I 4/27/2024 12:48:49'!
decideTirarAColocarSuFuerzaBaseEs: cantidadDeFuerzaALanzar
	^fuerzaPateada := cantidadDeFuerzaALanzar!

!methodRemoval: Delantero #decideTirarAMatarSuFuerzaBaseEs: stamp: 'I 4/27/2024 12:48:50'!
decideTirarAMatarSuFuerzaBaseEs: cantidadDeFuerzaALanzar
	^self new initializeEstrategiaTiro: #aMatar            			withFuerzaBase:cantidadDeFuerzaALanzar!

Object subclass: #Delantero
	instanceVariableNames: 'fuerzaBase estrategia'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Delantero category: #'ISW1-2023-2C-Parcial-1' stamp: 'I 4/27/2024 12:49:01'!
Object subclass: #Delantero
	instanceVariableNames: 'fuerzaBase estrategia'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Delantero methodsFor: 'no messages' stamp: 'I 4/27/2024 12:50:04'!
initializeEstrategiaTiro: estrategiaATirar         			withFuerzaBase:cantidadDeFuerzaALanzar
	fuerzaBase := cantidadDeFuerzaALanzar.
	estrategia := estrategiaATirar.! !
!Pelota class methodsFor: 'nil' stamp: 'I 4/27/2024 12:51:32'!
jabulaniSudafricanaRapida
	^self new initializeWithPelota: #Jabulani! !
!Pelota methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 12:51:58'!
initializeWithPelota: pelotaAUsa
	! !

Object subclass: #Pelota
	instanceVariableNames: 'pelota'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Pelota category: #'ISW1-2023-2C-Parcial-1' stamp: 'I 4/27/2024 12:52:06'!
Object subclass: #Pelota
	instanceVariableNames: 'pelota'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Pelota methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 12:52:09' prior: 50528219!
initializeWithPelota: pelotaAUsar
	! !
!Pelota methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 12:52:17' prior: 50528235!
initializeWithPelota: pelotaAUsar
	pelota := pelotaAUsar.
	! !

!methodRemoval: Arquero #esperaPorTiroYSeAdelantaSuFuerzaBaseEs: stamp: 'I 4/27/2024 12:52:39'!
esperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaParaAtajar
	fuerza:= fuerzaParaAtajar.!

Object subclass: #Arquero
	instanceVariableNames: 'fuerzaBase'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Arquero category: #'ISW1-2023-2C-Parcial-1' stamp: 'I 4/27/2024 12:52:45'!
Object subclass: #Arquero
	instanceVariableNames: 'fuerzaBase'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Arquero class methodsFor: 'nil' stamp: 'I 4/27/2024 13:02:18'!
esperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaParaAtajar
	^self new initializeWithEstrategia: #Espera withFuerzaBase: fuerzaParaAtajar.! !

Object subclass: #Arquero
	instanceVariableNames: 'fuerzaBase estrategia'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Arquero category: #'ISW1-2023-2C-Parcial-1' stamp: 'I 4/27/2024 13:02:33'!
Object subclass: #Arquero
	instanceVariableNames: 'fuerzaBase estrategia'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Arquero methodsFor: 'nil' stamp: 'I 4/27/2024 13:03:10'!
initializeWithEstrategia: estrategiaARealizar withFuerzaBase: fuerzaParaAtajar.
	fuerzaBase := fuerzaParaAtajar.
	estrategia := estrategiaARealizar.! !

!methodRemoval: Penales #conDelantero:yArquero: stamp: 'I 4/27/2024 13:03:31'!
conDelantero: delanteroAPatear yArquero: arqueroAAtajar
	delantero := delanteroAPatear.
	arquero := arqueroAAtajar.
	^self
	!
!Penales class methodsFor: 'nil' stamp: 'I 4/27/2024 13:04:17'!
conDelantero: delanteroAPatear yArquero: arqueroAAtajar
	^self new initializeWithDelantero: delanteroAPatear withArquero: arqueroAAtajar.! !
!Penales methodsFor: 'nil' stamp: 'I 4/27/2024 13:04:27'!
initializeWithDelantero: delanteroAPatear withArquero: arqueroAAtajar.
! !
!Penales methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 13:04:48' prior: 50528301!
initializeWithDelantero: delanteroAPatear withArquero: arqueroAAtajar.
	delantero := delanteroAPatear.
	arquero := arqueroAAtajar.! !
!Arquero class methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 13:05:59' prior: 50528261!
esperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaParaAtajar
	^self new initializeWithEstrategia: #EligeDireccionAntesTiro withFuerzaBase: fuerzaParaAtajar.! !
!Arquero class methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 13:06:26' prior: 50528315!
esperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaParaAtajar
	^self new initializeWithEstrategia: #EsperaTiroYSeAdelanta withFuerzaBase: fuerzaParaAtajar.! !
!Delantero class methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 13:07:13' prior: 50528156!
decideTirarAColocarSuFuerzaBaseEs: cantidadDeFuerzaALanzar
	^self new initializeEstrategiaTiro: #AColocar              			withFuerzaBase:cantidadDeFuerzaALanzar! !
!Delantero class methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 13:07:20' prior: 50528331!
decideTirarAColocarSuFuerzaBaseEs: cantidadDeFuerzaALanzar
	^self new initializeEstrategiaTiro: #aColocar              			withFuerzaBase:cantidadDeFuerzaALanzar! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 13:08:12' prior: 50527934!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."

	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Delantero methodsFor: 'nil' stamp: 'I 4/27/2024 13:08:54'!
estrategiaARealizar
	^estrategia! !
!Delantero methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 13:09:12'!
fuerzaATirar
	^fuerzaBase! !
!Pelota methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 13:09:37'!
pelotaUsada
	^pelota! !
!Pelota methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 13:09:45' prior: 50528148!
jabulaniSudafricanaRapida

	^pelota:= #Jabulani.
	! !
!Arquero methodsFor: 'nil' stamp: 'I 4/27/2024 13:16:00'!
fuerza
	^fuerzaBase! !
!Arquero methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 13:16:17'!
estrategiaAUsar
	^estrategia! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 13:16:41' prior: 50528349!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Delantero methodsFor: 'values' stamp: 'I 4/27/2024 13:16:51'!
estrategia
	^estrategia! !
!Arquero methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 13:17:00'!
estrategia
	^estrategia! !

Object subclass: #Penales
	instanceVariableNames: 'delantero arquero puntajeDelantero puntajeArquero'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Penales category: #'ISW1-2023-2C-Parcial-1' stamp: 'I 4/27/2024 14:42:01'!
Object subclass: #Penales
	instanceVariableNames: 'delantero arquero puntajeDelantero puntajeArquero'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Penales methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 14:42:19' prior: 50528307!
initializeWithDelantero: delanteroAPatear withArquero: arqueroAAtajar.
	delantero := delanteroAPatear.
	arquero := arqueroAAtajar.
	puntajeDelantero := 0.
	puntajeArquero := 0.! !
!Penales methodsFor: 'nil' stamp: 'I 4/27/2024 14:43:10'!
puntajeDeDelantero
	^puntajeDelantero! !
!Penales methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 14:43:22'!
puntajeDeArquero
	^puntajeArquero! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 14:47:23' prior: 50528442!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: 'Penales direccionTiroFueraDeRango'.
].

(delantero estrategia = #aColocar) ifTrue: [
    pelota = #Jabulani ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro = direccionArquero ifTrue: [
                (delantero fuerza / 2) > arquero fuerza ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse: [
                    puntajeArquero := 1
                ]
            ]
        ]
    ].
    pelota = #Playera ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: []
    ]
].
	
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 14:48:23'!
FAILURE!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 14:48:31'!
FAILURE!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 14:48:31'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 14:48:51' prior: 50528550!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango.
].

(delantero estrategia = #aColocar) ifTrue: [
    pelota = #Jabulani ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro = direccionArquero ifTrue: [
                (delantero fuerza / 2) > arquero fuerza ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse: [
                    puntajeArquero := 1
                ]
            ]
        ]
    ].
    pelota = #Playera ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: []
    ]
].
	
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 14:48:55'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 14:48:58'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'I 4/27/2024 14:49:10'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'I 4/27/2024 14:49:15'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'I 4/27/2024 14:49:19'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 14:49:21'!
FAILURE!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 14:49:21'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 14:49:44' prior: 50528655!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango.
].
((direccionArquero x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango.
].

(delantero estrategia = #aColocar) ifTrue: [
    pelota = #Jabulani ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro = direccionArquero ifTrue: [
                (delantero fuerza / 2) > arquero fuerza ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse: [
                    puntajeArquero := 1
                ]
            ]
        ]
    ].
    pelota = #Playera ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: []
    ]
].
	
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 14:49:46'!
FAILURE!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 14:49:46'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 14:49:59' prior: 50528774!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].
((direccionArquero x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango.
].

(delantero estrategia = #aColocar) ifTrue: [
    pelota = #Jabulani ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro = direccionArquero ifTrue: [
                (delantero fuerza / 2) > arquero fuerza ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse: [
                    puntajeArquero := 1
                ]
            ]
        ]
    ].
    pelota = #Playera ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: []
    ]
].
	
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 14:50:02'!
FAILURE!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 14:50:02'!
FAILURE!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 14:50:11'!
FAILURE!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 14:50:11'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 14:50:30' prior: 50528879!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango.
].

(delantero estrategia = #aColocar) ifTrue: [
    pelota = #Jabulani ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro = direccionArquero ifTrue: [
                (delantero fuerza / 2) > arquero fuerza ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse: [
                    puntajeArquero := 1
                ]
            ]
        ]
    ].
    pelota = #Playera ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: []
    ]
].
	
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 14:50:40' prior: 50528991!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].

(delantero estrategia = #aColocar) ifTrue: [
    pelota = #Jabulani ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro = direccionArquero ifTrue: [
                (delantero fuerza / 2) > arquero fuerza ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse: [
                    puntajeArquero := 1
                ]
            ]
        ]
    ].
    pelota = #Playera ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: []
    ]
].
	
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 14:50:42'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'I 4/27/2024 14:50:45'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 14:50:49'!
FAILURE!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 14:50:49'!
FAILURE!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'I 4/27/2024 14:50:53'!
FAILURE!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'I 4/27/2024 14:50:53'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 14:52:21' prior: 50529089!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].

(delantero estrategia = #aColocar) ifTrue: [
    pelota = #Jabulani ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro = direccionArquero ifTrue: [
                (delantero fuerza / 2) > arquero fuerza ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse: [
                    puntajeArquero := 1
                ]
            ]
        ]
    ].
    pelota = #Playera ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: []
    ]
].
	
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'I 4/27/2024 14:52:25'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 14:52:26'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 14:52:27'!
FAILURE!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 14:52:27'!
FAILURE!
!Penales methodsFor: 'value' stamp: 'I 4/27/2024 14:56:06'!
varDireccionRemateResultante! !

Object subclass: #Penales
	instanceVariableNames: 'delantero arquero puntajeDelantero puntajeArquero direccionRemate'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Penales category: #'ISW1-2023-2C-Parcial-1' stamp: 'I 4/27/2024 14:56:19'!
Object subclass: #Penales
	instanceVariableNames: 'delantero arquero puntajeDelantero puntajeArquero direccionRemate'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Penales methodsFor: 'value' stamp: 'I 4/27/2024 14:58:00' prior: 50529319!
varDireccionRemateResultante
	^direccionRemate! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 15:02:28' prior: 50529208!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].

(delantero estrategia = #aColocar) ifTrue: [
    pelota = #Jabulani ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro = direccionArquero ifTrue: [
                (delantero fuerza / 2) > arquero fuerza ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse: [
                    puntajeArquero := 1
                ]
            ]
        ].
	direccionRemate := direccionTiro.
    ].
    pelota = #Playera ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: []
    ]
].
	
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 15:02:33'!
FAILURE!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 15:02:33'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 15:04:15' prior: 50529343!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].

(delantero estrategia = #aColocar) ifTrue: [
    pelota= #Jabulani ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro = direccionArquero ifTrue: [
                (delantero fuerza / 2) > arquero fuerza ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse: [
                    puntajeArquero := 1
                ]
            ]
        ].
	direccionRemate := direccionTiro.
    ].
    pelota = #Playera ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: []
    ]
].
	
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 15:04:30' prior: 50529449!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].

(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro = direccionArquero ifTrue: [
                (delantero fuerza / 2) > arquero fuerza ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse: [
                    puntajeArquero := 1
                ]
            ]
        ].
	direccionRemate := direccionTiro.
    ].
    pelota pelotaUsada = #Playera ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: []
    ]
].
	
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 15:04:39'!
FAILURE!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 15:04:39'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 15:05:39' prior: 50529549!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].

(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro = direccionArquero ifTrue: [
                (delantero fuerza / 2) > arquero fuerza ifTrue: [
                    puntajeDelantero := 1
                ] 
            ]ifFalse: [
                    puntajeArquero := 1
                ]
        ].
	direccionRemate := direccionTiro.
    ].
    pelota pelotaUsada = #Playera ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: []
    ]
].
	
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 15:05:42'!
FAILURE!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 15:05:42'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 15:06:32' prior: 50529656!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].

(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro = direccionArquero ifTrue: [
                (delantero fuerza / 2) > arquero fuerza ifTrue: [
                    puntajeDelantero := 1
                ] 
            ]ifFalse: [
                    puntajeDelantero := 1
                ]
        ].
	direccionRemate := direccionTiro.
    ].
    pelota pelotaUsada = #Playera ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: []
    ]
].
	
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 15:06:50' prior: 50529763!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].

(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro = direccionArquero ifTrue: [
                (delantero fuerza / 2) > arquero fuerza ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ]
        ].
	direccionRemate := direccionTiro.
    ].
    pelota pelotaUsada = #Playera ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: []
    ]
].
	
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 15:06:52'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 15:06:52'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'I 4/27/2024 15:06:52'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'I 4/27/2024 15:06:52'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'I 4/27/2024 15:06:52'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 15:06:52'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'I 4/27/2024 15:06:52'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'I 4/27/2024 15:06:52'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 15:06:52'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 15:06:52'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 15:06:52'!
ERROR!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 15:06:52'!
ERROR!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 15:06:52'!
ERROR!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'I 4/27/2024 15:06:52'!
ERROR!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 15:06:52'!
ERROR!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 15:06:52'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 15:06:52'!
ERROR!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 15:06:52'!
ERROR!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'I 4/27/2024 15:06:52'!
ERROR!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 15:06:52'!
ERROR!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 15:06:52'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 15:06:52'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 15:06:52'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 15:06:52'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 15:06:52'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 15:06:52'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 15:06:52'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 15:06:52'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 15:06:52'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 15:06:52'!
FAILURE!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 15:06:52'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 15:06:52'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 15:06:52'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 15:06:52'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 15:06:52'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 15:06:56'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 15:07:01'!
ERROR!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 15:07:01'!
ERROR!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 15:07:09'!
ERROR!

delantero fuerza!

delantero fuerza!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 15:08:16' prior: 50529864!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].

(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro = direccionArquero ifTrue: [
                (delantero fuerzaATirar / 2) > arquero fuerza ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ]
        ].
	direccionRemate := direccionTiro.
    ].
    pelota pelotaUsada = #Playera ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: []
    ]
].
	
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 15:08:25'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 15:08:32'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 15:08:34'!
ERROR!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 15:08:34'!
ERROR!
!Penales methodsFor: 'value' stamp: 'I 4/27/2024 15:09:17'!
varFuerzaResultanteDeTiro! !

Object subclass: #Penales
	instanceVariableNames: 'delantero arquero puntajeDelantero puntajeArquero direccionRemate potenciaTiro'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Penales category: #'ISW1-2023-2C-Parcial-1' stamp: 'I 4/27/2024 15:09:24'!
Object subclass: #Penales
	instanceVariableNames: 'delantero arquero puntajeDelantero puntajeArquero direccionRemate potenciaTiro'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 15:09:55' prior: 50530119!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].

(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro = direccionArquero ifTrue: [
                (delantero fuerzaATirar / 2) > arquero fuerza ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ]
        ].
	direccionRemate := direccionTiro.
	potenciaTiro := delantero fuerzaATirar / 2.
    ].
    pelota pelotaUsada = #Playera ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: []
    ]
].
	
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 15:09:58'!
FAILURE!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 15:09:58'!
FAILURE!
!Penales methodsFor: 'value' stamp: 'I 4/27/2024 15:10:50' prior: 50530234!
varFuerzaResultanteDeTiro
	^potenciaTiro! !

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 15:10:58'!
PASSED!
!Arquero class methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 15:13:04'!
eeligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaParaAtajar
	^self new initializeWithEstrategia: #EligeDireccionAntesTiro withFuerzaBase: fuerzaParaAtajar.! !
!Arquero class methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 15:13:08'!
eligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaParaAtajar
	^self new initializeWithEstrategia: #EligeDireccionAntesTiro withFuerzaBase: fuerzaParaAtajar.! !

!methodRemoval: Arquero class #eeligeDireccionAntesDeTiroSuFuerzaBaseEs: stamp: 'I 4/27/2024 15:13:10'!
eeligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaParaAtajar
	^self new initializeWithEstrategia: #EligeDireccionAntesTiro withFuerzaBase: fuerzaParaAtajar.!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 15:24:13'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 15:24:13'!
FAILURE!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 15:26:49'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 15:26:49'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'I 4/27/2024 15:26:49'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'I 4/27/2024 15:26:49'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'I 4/27/2024 15:26:49'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 15:26:49'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'I 4/27/2024 15:26:49'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'I 4/27/2024 15:26:49'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 15:26:49'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 15:26:49'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 15:26:49'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 15:26:49'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 15:26:49'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'I 4/27/2024 15:26:49'!
FAILURE!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 15:26:49'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 15:26:49'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 15:26:49'!
ERROR!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 15:26:49'!
ERROR!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'I 4/27/2024 15:26:49'!
ERROR!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 15:26:49'!
ERROR!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 15:26:49'!
FAILURE!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 15:26:49'!
FAILURE!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 15:26:49'!
FAILURE!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 15:26:49'!
FAILURE!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 15:26:49'!
FAILURE!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 15:26:49'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 15:26:49'!
FAILURE!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 15:26:49'!
FAILURE!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 15:26:49'!
FAILURE!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 15:26:49'!
FAILURE!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 15:26:49'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 15:26:49'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 15:26:49'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 15:26:49'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 15:26:49'!
ERROR!
!Pelota class methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 15:33:01'!
playeraLentaCostaAzul.
	^self new initializeWithPelota: #Playera! !

!methodRemoval: Pelota #jabulaniSudafricanaRapida stamp: 'I 4/27/2024 15:33:06'!
jabulaniSudafricanaRapida

	^pelota:= #Jabulani.
	!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 15:35:02' prior: 50530255!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].

(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro = direccionArquero ifTrue: [
                (delantero fuerzaATirar / 2) > arquero fuerza ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
		potenciaTiro := delantero fuerzaATirar / 2.
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: []
    ]
].
	
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'value' stamp: 'I 4/27/2024 15:35:21'!
varFuerzaResultanteDeAtajada
! !

Object subclass: #Penales
	instanceVariableNames: 'delantero arquero puntajeDelantero puntajeArquero direccionRemate potenciaTiro fuerzaAtajada'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Penales category: #'ISW1-2023-2C-Parcial-1' stamp: 'I 4/27/2024 15:35:32'!
Object subclass: #Penales
	instanceVariableNames: 'delantero arquero puntajeDelantero puntajeArquero direccionRemate potenciaTiro fuerzaAtajada'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Penales methodsFor: 'value' stamp: 'I 4/27/2024 15:35:44' prior: 50530657!
varFuerzaResultanteDeAtajada
	^fuerzaAtajada! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 15:37:01' prior: 50530555!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].

(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro = direccionArquero ifTrue: [
                (delantero fuerzaATirar / 2) > arquero fuerza ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
		
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro = direccionArquero ifTrue: [
                (delantero fuerzaATirar / 2) > arquero fuerza ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	potenciaTiro := delantero fuerzaATirar / 2.
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: []
    ]
].
	
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 15:38:52' prior: 50530683!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].

(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro x = direccionArquero x ifTrue: [
                (delantero fuerzaATirar / 2) > (arquero fuerza +(arquero fuerza/2) ) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
		
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro = direccionArquero ifTrue: [
                (delantero fuerzaATirar / 2) > arquero fuerza ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	potenciaTiro := delantero fuerzaATirar / 2.
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: []
    ]
].
	
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 15:43:21' prior: 50530795!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro x = direccionArquero x ifTrue: [
                (delantero fuerzaATirar / 2) > (arquero fuerza +(arquero fuerza/2) ) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
		
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro = direccionArquero ifTrue: [
                (delantero fuerzaATirar / 2) > arquero fuerza ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	potenciaTiro := delantero fuerzaATirar / 2.
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: []
    ]
].
	
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 15:45:11' prior: 50530908!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro x = direccionArquero x ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (delantero fuerzaATirar / 2) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro = direccionArquero ifTrue: [
                (delantero fuerzaATirar / 2) > arquero fuerza ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: []
    ]
].
	
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 15:45:33' prior: 50531021!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro x = direccionArquero x ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro = direccionArquero ifTrue: [
                (potenciaTiro) > arquero fuerza ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: []
    ]
].
	
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 15:45:54' prior: 50531135!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro x = direccionArquero x ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro = direccionArquero ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > arquero fuerza ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: []
    ]
].
	
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 15:46:01' prior: 50531249!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro x = direccionArquero x ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro = direccionArquero ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: []
    ]
].
	
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'I 4/27/2024 15:46:06'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 15:46:09'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 15:46:12'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 15:46:12'!
FAILURE!
!PenalesTest methodsFor: 'tests' stamp: 'I 4/27/2024 15:49:58' prior: 50527200!
test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"El Arquero que espera y se adelanta ante un tiro de jabulani a colocar ignora la 2da coordenada (altura) al atajar..."	
	"(al adelanterse encara la pelota antes de que su elevación se transforme en un problema)"
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero  eligeDireccionAntesDeTiroSuFuerzaBaseEs: 50.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@2 equals: juegoPenales varDireccionRemateResultante! !

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 15:50:01'!
PASSED!
!PenalesTest methodsFor: 'tests' stamp: 'I 4/27/2024 16:03:42' prior: 50531495!
test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"El Arquero que espera y se adelanta ante un tiro de jabulani a colocar ignora la 2da coordenada (altura) al atajar..."	
	"(al adelanterse encara la pelota antes de que su elevación se transforme en un problema)"
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero  esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 50.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@2 equals: juegoPenales varDireccionRemateResultante! !

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 16:03:44'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 16:04:05' prior: 50531364!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: []
    ]
].
	
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 16:04:08'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'I 4/27/2024 16:04:10'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 16:04:11'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 16:04:13'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 16:04:15'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 16:04:17'!
PASSED!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 16:04:19'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 16:04:19'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 16:19:17' prior: 50531572!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
    ]
].
	
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 16:19:23'!
PASSED!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 16:19:26'!
FAILURE!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 16:19:26'!
FAILURE!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 16:19:54'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 16:21:09' prior: 50531718!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
    ]
].
	
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 16:21:13'!
PASSED!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'I 4/27/2024 16:21:16'!
PASSED!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 16:21:18'!
FAILURE!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 16:21:18'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 16:23:25' prior: 50531875!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
	
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 16:23:29'!
PASSED!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 16:24:09' prior: 50532033!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 16:24:53' prior: 50532168!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro x @ direccionTiro y + 1.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 16:24:55'!
FAILURE!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 16:24:55'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 16:25:40' prior: 50532350!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro x @ (direccionTiro y + 1).
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 16:25:45'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 16:25:45'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'I 4/27/2024 16:25:45'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'I 4/27/2024 16:25:45'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'I 4/27/2024 16:25:45'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 16:25:45'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'I 4/27/2024 16:25:45'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'I 4/27/2024 16:25:45'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 16:25:45'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 16:25:45'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 16:25:45'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 16:25:45'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 16:25:45'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'I 4/27/2024 16:25:45'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 16:25:45'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 16:25:45'!
PASSED!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 16:25:45'!
PASSED!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 16:25:45'!
PASSED!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'I 4/27/2024 16:25:45'!
PASSED!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 16:25:45'!
PASSED!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 16:25:45'!
PASSED!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 16:25:45'!
FAILURE!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 16:25:45'!
PASSED!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 16:25:45'!
FAILURE!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 16:25:45'!
FAILURE!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 16:25:45'!
FAILURE!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 16:25:45'!
FAILURE!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 16:25:45'!
FAILURE!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 16:25:45'!
FAILURE!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 16:25:45'!
FAILURE!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 16:25:45'!
FAILURE!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 16:25:45'!
FAILURE!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 16:25:45'!
FAILURE!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 16:25:45'!
FAILURE!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 16:25:45'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 16:27:12' prior: 50532542!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	(direccionTiro y < 2) ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y + 1)] ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y - 1)]
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 16:27:14'!
PASSED!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 16:27:28'!
PASSED!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 16:27:34'!
PASSED!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 16:30:09' prior: 50532865!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
	(direccionTiro y < 2) ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y + 1)] ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y - 1)].
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 16:30:14'!
FAILURE!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 16:30:14'!
FAILURE!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 16:30:31'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 16:31:32' prior: 50533064!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar .
	(direccionTiro y < 2) ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y + 1)] ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y - 1)].
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 16:31:37'!
FAILURE!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 16:31:37'!
FAILURE!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 16:43:56'!
FAILURE!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 16:43:56'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 16:46:46' prior: 50533262!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar +  ((delantero fuerzaATirar*20)/100).
	(direccionTiro y < 2) ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y + 1)] ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y - 1)].
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 16:48:02'!
FAILURE!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 16:48:02'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 16:49:29' prior: 50533463!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar +  ((delantero fuerzaATirar*20)/100).
	(direccionTiro y < 2) ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y + 1)] ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y - 1)].
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate x = direccionArquero x ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro  = direccionArquero   ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 16:49:32'!
PASSED!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 16:51:04' prior: 50533658!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar +  ((delantero fuerzaATirar*20)/100).
	(direccionTiro y < 2) ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y + 1)] ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y - 1)].
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate  x = direccionArquero x  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
                    puntajeDelantero := 1
        ].
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 16:51:06'!
FAILURE!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 16:51:06'!
FAILURE!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 16:51:22'!
PASSED!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 16:51:32'!
FAILURE!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 16:51:32'!
FAILURE!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 16:52:06'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 16:53:45' prior: 50533849!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar +  ((delantero fuerzaATirar*20)/100).
	(direccionTiro y < 2) ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y + 1)] ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y - 1)].
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate  x = direccionArquero x  ifTrue: [
		fuerzaAtajada := arquero fuerza .
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
                    puntajeDelantero := 1
        ].
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 16:53:49'!
PASSED!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 16:53:51'!
PASSED!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 16:53:53'!
FAILURE!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 16:53:53'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 17:12:28' prior: 50534052!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar +  ((delantero fuerzaATirar*20)/100).
	
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate  x = direccionArquero x  ifTrue: [
		fuerzaAtajada := arquero fuerza .
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
                    puntajeDelantero := 1
        ].
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
	self esAngulo: direccionTiro ifTrue: [direccionRemate := direccionTiro x @ (direccionTiro y +2)].
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 17:12:36' prior: 50534245!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar +  ((delantero fuerzaATirar*20)/100).
	
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate  x = direccionArquero x  ifTrue: [
		fuerzaAtajada := arquero fuerza .
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
                    puntajeDelantero := 1
        ].
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
	(self esAngulo: direccionTiro )ifTrue: [direccionRemate := direccionTiro x @ (direccionTiro y +2)].
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'nil' stamp: 'I 4/27/2024 17:14:43'!
esAngulo: direccionTiro
 	^(direccionTiro x = 0 and: [direccionTiro y = 0] ) or: 
	(direccionTiro x = 0 and: [direccionTiro y = 2] ) or: 
	(direccionTiro x = 2 and: [direccionTiro y = 0] ) or: 
	(direccionTiro x = 2 and: [direccionTiro y = 2] )! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 17:19:48' prior: 50534421!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar +  ((delantero fuerzaATirar*20)/100).
	
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate  x = direccionArquero x  ifTrue: [
		fuerzaAtajada := arquero fuerza .
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
                    puntajeDelantero := 1
        ].
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
	(self esAngulo: direccionTiro )ifFalse: [direccionRemate := direccionTiro x @ (direccionTiro y +2)] ifTrue: [(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)]] .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro y = direccionArquero y ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 17:19:51'!
FAILURE!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 17:19:51'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 17:20:37' prior: 50534607!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar +  ((delantero fuerzaATirar*20)/100).
	
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate  x = direccionArquero x  ifTrue: [
		fuerzaAtajada := arquero fuerza .
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
                    puntajeDelantero := 1
        ].
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar  - (((delantero fuerzaATirar / 2)*20)/100) .
	(self esAngulo: direccionTiro )ifFalse: [direccionRemate := direccionTiro x @ (direccionTiro y +2)] ifTrue: [(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)]] .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro y = direccionArquero y ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 17:21:45' prior: 50534797!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar +  ((delantero fuerzaATirar*20)/100).
	
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate  x = direccionArquero x  ifTrue: [
		fuerzaAtajada := arquero fuerza .
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
                    puntajeDelantero := 1
        ].
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar  - (((delantero fuerzaATirar / 2)*20)/100) .
	(self esAngulo: direccionTiro )ifFalse: [direccionRemate := direccionTiro x @ (direccionTiro y +2)] ifTrue: [(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)]] .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate y = direccionArquero y ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 17:21:51'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 17:23:10' prior: 50534978!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar +  ((delantero fuerzaATirar*20)/100).
	
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate  x = direccionArquero x  ifTrue: [
		fuerzaAtajada := arquero fuerza .
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
                    puntajeDelantero := 1
        ].
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar  - (((delantero fuerzaATirar / 2)*20)/100) .
	(self esAngulo: direccionTiro )ifFalse: [direccionRemate := direccionTiro x @ (direccionTiro y +2)] ifTrue: [(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)]] .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate y = direccionArquero y ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 17:23:12'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 17:23:12'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'I 4/27/2024 17:23:12'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'I 4/27/2024 17:23:12'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'I 4/27/2024 17:23:12'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 17:23:12'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'I 4/27/2024 17:23:12'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'I 4/27/2024 17:23:12'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 17:23:12'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 17:23:12'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 17:23:12'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 17:23:12'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 17:23:12'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'I 4/27/2024 17:23:12'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 17:23:12'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 17:23:12'!
PASSED!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 17:23:12'!
PASSED!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 17:23:12'!
PASSED!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'I 4/27/2024 17:23:12'!
PASSED!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 17:23:12'!
PASSED!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 17:23:12'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 17:23:12'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 17:23:12'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 17:23:12'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 17:23:12'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 17:23:12'!
FAILURE!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 17:23:12'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 17:23:12'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 17:23:12'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 17:23:12'!
FAILURE!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 17:23:12'!
PASSED!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 17:23:12'!
FAILURE!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 17:23:12'!
PASSED!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 17:23:12'!
PASSED!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 17:23:12'!
FAILURE!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 17:23:16'!
PASSED!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 17:23:18'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 17:23:19'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'I 4/27/2024 17:23:19'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'I 4/27/2024 17:23:19'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'I 4/27/2024 17:23:19'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 17:23:19'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'I 4/27/2024 17:23:19'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'I 4/27/2024 17:23:19'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 17:23:19'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 17:23:19'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 17:23:19'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 17:23:19'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 17:23:19'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'I 4/27/2024 17:23:19'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 17:23:19'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 17:23:19'!
PASSED!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 17:23:19'!
PASSED!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 17:23:19'!
PASSED!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'I 4/27/2024 17:23:19'!
PASSED!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 17:23:19'!
PASSED!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 17:23:19'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 17:23:19'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 17:23:19'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 17:23:19'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 17:23:19'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 17:23:19'!
FAILURE!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 17:23:19'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 17:23:19'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 17:23:19'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 17:23:19'!
FAILURE!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 17:23:19'!
PASSED!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 17:23:19'!
FAILURE!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 17:23:19'!
PASSED!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 17:23:19'!
PASSED!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 17:23:19'!
FAILURE!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 17:23:33'!
FAILURE!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 17:23:33'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 17:24:32' prior: 50535164!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeArquero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar +  ((delantero fuerzaATirar*20)/100).
	
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate  x = direccionArquero x  ifTrue: [
		fuerzaAtajada := arquero fuerza .
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
                    puntajeDelantero := 1
        ].
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar  - (((delantero fuerzaATirar / 2)*20)/100) .
	(self esAngulo: direccionTiro )ifFalse: [direccionRemate := direccionTiro x @ (direccionTiro y +2)] ifTrue: [(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)]] .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate y = direccionArquero y ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 17:24:34'!
FAILURE!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 17:24:34'!
FAILURE!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 17:24:37'!
FAILURE!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 17:24:46'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 17:25:59' prior: 50535636!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeArquero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar +  ((delantero fuerzaATirar*20)/100).
	
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate  x = direccionArquero x  ifTrue: [
		fuerzaAtajada := arquero fuerza .
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
                    puntajeDelantero := 1
        ].
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar  - (((delantero fuerzaATirar / 2)*20)/100) .
	(self esAngulo: direccionTiro )ifFalse: [direccionRemate := direccionTiro x @ (direccionTiro y +2)] ifTrue: [(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)]] .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate y = direccionArquero y ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeArquero := 1.
        ].
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 17:26:02'!
PASSED!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 17:26:09'!
PASSED!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 17:26:11'!
PASSED!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 17:26:13'!
FAILURE!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 17:26:13'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 17:29:17' prior: 50535833!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeArquero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar +  ((delantero fuerzaATirar*20)/100).
	
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate  x = direccionArquero x  ifTrue: [
		fuerzaAtajada := arquero fuerza .
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
                    puntajeDelantero := 1
        ].
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar  - (((delantero fuerzaATirar / 2)*20)/100) .
	(self esAngulo: direccionTiro )ifFalse: [direccionRemate := direccionTiro x @ (direccionTiro y +2)] ifTrue: [(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)]] .
	(direccionRemate y > 2 ) ifTrue: [puntajeArquero:=1] ifFalse:[
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate y = direccionArquero y ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeArquero := 1.
        ].
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 17:29:20'!
PASSED!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 17:29:22'!
PASSED!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 17:29:23'!
PASSED!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 17:29:24'!
PASSED!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 17:29:26'!
PASSED!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 17:29:27'!
PASSED!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 17:29:28'!
FAILURE!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 17:29:28'!
FAILURE!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 17:29:43'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'I 4/27/2024 17:29:43'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'I 4/27/2024 17:29:43'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'I 4/27/2024 17:29:43'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 17:29:43'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'I 4/27/2024 17:29:43'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'I 4/27/2024 17:29:43'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 17:29:43'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 17:29:43'!
FAILURE!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 17:29:43'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 17:29:43'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 17:29:43'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'I 4/27/2024 17:29:43'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 17:29:43'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 17:29:43'!
PASSED!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 17:29:43'!
PASSED!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 17:29:43'!
PASSED!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'I 4/27/2024 17:29:43'!
PASSED!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 17:29:43'!
PASSED!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 17:29:43'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 17:29:43'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 17:29:43'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 17:29:43'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 17:29:43'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 17:29:43'!
FAILURE!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 17:29:43'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 17:29:43'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 17:29:43'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 17:29:43'!
FAILURE!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 17:29:43'!
PASSED!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 17:29:43'!
PASSED!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 17:29:43'!
PASSED!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 17:29:43'!
PASSED!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 17:29:43'!
PASSED!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 17:32:44' prior: 50536035!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeArquero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar +  ((delantero fuerzaATirar*20)/100).
	
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate  x = direccionArquero x  ifTrue: [
		fuerzaAtajada := arquero fuerza .
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1.
		   direccionRemate:= direccionTiro.
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
                    puntajeDelantero := 1
        ].
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar  - (((delantero fuerzaATirar / 2)*20)/100) .
	(self esAngulo: direccionTiro )ifFalse: [direccionRemate := direccionTiro x @ (direccionTiro y +2)] ifTrue: [(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)]] .
	(direccionRemate y > 2 ) ifTrue: [puntajeArquero:=1] ifFalse:[
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate y = direccionArquero y ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeArquero := 1.
        ].
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 17:32:47'!
FAILURE!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 17:32:47'!
FAILURE!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 17:32:56'!
FAILURE!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 17:32:56'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 17:33:28' prior: 50536387!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeArquero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar +  ((delantero fuerzaATirar*20)/100).
	
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate  x = direccionArquero x  ifTrue: [
		fuerzaAtajada := arquero fuerza .
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1.
		   
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
                    puntajeDelantero := 1.
		   direccionRemate:= direccionTiro.
        ].
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar  - (((delantero fuerzaATirar / 2)*20)/100) .
	(self esAngulo: direccionTiro )ifFalse: [direccionRemate := direccionTiro x @ (direccionTiro y +2)] ifTrue: [(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)]] .
	(direccionRemate y > 2 ) ifTrue: [puntajeArquero:=1] ifFalse:[
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate y = direccionArquero y ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeArquero := 1.
        ].
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 17:33:30'!
PASSED!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 17:33:32'!
PASSED!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 17:33:33'!
PASSED!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 17:34:27' prior: 50536587!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeArquero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar +  ((delantero fuerzaATirar*20)/100).
	
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [
	(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)].
	direccionRemate  x = direccionArquero x  ifTrue: [
		fuerzaAtajada := arquero fuerza .
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1.
		   
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
                    puntajeDelantero := 1.
		   direccionRemate:= direccionTiro.
        ].
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar  - (((delantero fuerzaATirar / 2)*20)/100) .
	(self esAngulo: direccionTiro )ifFalse: [direccionRemate := direccionTiro x @ (direccionTiro y +2)] ifTrue: [(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)]] .
	(direccionRemate y > 2 ) ifTrue: [puntajeArquero:=1] ifFalse:[
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate y = direccionArquero y ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeArquero := 1.
        ].
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 17:34:30'!
PASSED!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 17:34:32'!
PASSED!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 17:34:33'!
PASSED!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 17:34:35'!
FAILURE!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 17:34:35'!
FAILURE!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 17:34:37'!
FAILURE!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 17:34:37'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 17:37:30' prior: 50536784!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeArquero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar +  ((delantero fuerzaATirar*20)/100).
	
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [
	(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)].
	direccionRemate  x = direccionArquero x  ifTrue: [
		fuerzaAtajada := arquero fuerza .
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1.
		   
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
                    puntajeDelantero := 1.
		   direccionRemate:= direccionTiro.
        ].
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar .
	(self esAngulo: direccionTiro )ifFalse: [direccionRemate := direccionTiro x @ (direccionTiro y +2)] ifTrue: [(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)]] .
	(direccionRemate y > 2 ) ifTrue: [puntajeArquero:=1] ifFalse:[
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate y = direccionArquero y ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeArquero := 1.
        ].
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 17:37:32'!
PASSED!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 17:37:33'!
PASSED!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 17:37:35'!
PASSED!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 17:37:36'!
FAILURE!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 17:37:36'!
FAILURE!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 17:38:15'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 17:38:17'!
FAILURE!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 17:38:17'!
FAILURE!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 17:38:17'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 17:39:29'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 17:41:14' prior: 50536999!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar +  ((delantero fuerzaATirar*20)/100).
	
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [
	(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)].
	direccionRemate  x = direccionArquero x  ifTrue: [
		fuerzaAtajada := arquero fuerza .
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1.
		   
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
                    puntajeDelantero := 1.
		   direccionRemate:= direccionTiro.
        ].
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar .
	(self esAngulo: direccionTiro )ifFalse: [direccionRemate := direccionTiro x @ (direccionTiro y +2)] ifTrue: [(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)]] .
	(direccionRemate y > 2 ) ifTrue: [puntajeArquero:=1] ifFalse:[
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate y = direccionArquero y ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeArquero := 1.
        ].
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 17:41:18'!
FAILURE!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 17:41:18'!
PASSED!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 17:41:18'!
FAILURE!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 17:41:24'!
FAILURE!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 17:41:24'!
PASSED!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 17:41:24'!
FAILURE!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'I 4/27/2024 17:41:29'!
PASSED!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 17:44:12' prior: 50537348!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].


(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar +  ((delantero fuerzaATirar*20)/100).
	
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [
	(self esAngulo: direccionTiro)ifTrue:[(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)]]ifFalse:[direccionRemate := direccionTiro ].
	direccionRemate  x = direccionArquero x  ifTrue: [
		fuerzaAtajada := arquero fuerza .
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1.
		   
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
                    puntajeDelantero := 1.
		   direccionRemate:= direccionTiro.
        ].
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar .
	(self esAngulo: direccionTiro )ifFalse: [direccionRemate := direccionTiro x @ (direccionTiro y +2)] ifTrue: [(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)]] .
	(direccionRemate y > 2 ) ifTrue: [puntajeArquero:=1] ifFalse:[
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate y = direccionArquero y ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeArquero := 1.
        ].
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 17:44:15'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 17:44:16'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'I 4/27/2024 17:44:16'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'I 4/27/2024 17:44:16'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'I 4/27/2024 17:44:16'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 17:44:16'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'I 4/27/2024 17:44:16'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'I 4/27/2024 17:44:16'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 17:44:16'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 17:44:16'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 17:44:16'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 17:44:16'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 17:44:16'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'I 4/27/2024 17:44:16'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 17:44:16'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 17:44:16'!
PASSED!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 17:44:16'!
PASSED!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 17:44:16'!
PASSED!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'I 4/27/2024 17:44:16'!
PASSED!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 17:44:16'!
PASSED!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 17:44:16'!
PASSED!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 17:44:16'!
PASSED!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 17:44:16'!
PASSED!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 17:44:16'!
PASSED!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 17:44:16'!
PASSED!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 17:44:16'!
PASSED!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 17:44:16'!
PASSED!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 17:44:16'!
PASSED!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 17:44:16'!
PASSED!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 17:44:16'!
PASSED!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 17:44:16'!
PASSED!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 17:44:17'!
PASSED!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 17:44:17'!
PASSED!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 17:44:17'!
PASSED!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 17:44:17'!
PASSED!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 17:46:51' prior: 50537817!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].
self direccionValidaParaTiro: direccionTiro direccionValidaArquero: direccionArquero. 

(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar +  ((delantero fuerzaATirar*20)/100).
	
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [
	(self esAngulo: direccionTiro)ifTrue:[(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)]]ifFalse:[direccionRemate := direccionTiro ].
	direccionRemate  x = direccionArquero x  ifTrue: [
		fuerzaAtajada := arquero fuerza .
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1.
		   
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
                    puntajeDelantero := 1.
		   direccionRemate:= direccionTiro.
        ].
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar .
	(self esAngulo: direccionTiro )ifFalse: [direccionRemate := direccionTiro x @ (direccionTiro y +2)] ifTrue: [(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)]] .
	(direccionRemate y > 2 ) ifTrue: [puntajeArquero:=1] ifFalse:[
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate y = direccionArquero y ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeArquero := 1.
        ].
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'nil' stamp: 'I 4/27/2024 18:00:37'!
direccionValidaParaTiro: direccionTiro direccionValidaArquero: direccionArquero
 	((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionTiroFueraDeRango
].
((direccionArquero x between: 0 and: 2) and: [direccionArquero y between: 0 and: 2]) ifFalse: [
    self error: Penales direccionArqueroFueraDeRango.
].! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 18:00:50' prior: 50538146!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	
self direccionValidaParaTiro: direccionTiro direccionValidaArquero: direccionArquero. 

(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar +  ((delantero fuerzaATirar*20)/100).
	
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [
	(self esAngulo: direccionTiro)ifTrue:[(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)]]ifFalse:[direccionRemate := direccionTiro ].
	direccionRemate  x = direccionArquero x  ifTrue: [
		fuerzaAtajada := arquero fuerza .
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1.
		   
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
                    puntajeDelantero := 1.
		   direccionRemate:= direccionTiro.
        ].
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar .
	(self esAngulo: direccionTiro )ifFalse: [direccionRemate := direccionTiro x @ (direccionTiro y +2)] ifTrue: [(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)]] .
	(direccionRemate y > 2 ) ifTrue: [puntajeArquero:=1] ifFalse:[
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate y = direccionArquero y ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeArquero := 1.
        ].
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 18:00:55'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 18:05:05'!
PASSED!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 18:05:05'!
PASSED!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 18:06:54' prior: 50538352!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	
self direccionValidaParaTiro: direccionTiro direccionValidaArquero: direccionArquero. 
delantero tiralAlArcoConDireccion: direccionTiro conArquero: arquero arqueroDefendiendoDireccion: direccionArquero.
(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar +  ((delantero fuerzaATirar*20)/100).
	
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [
	(self esAngulo: direccionTiro)ifTrue:[(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)]]ifFalse:[direccionRemate := direccionTiro ].
	direccionRemate  x = direccionArquero x  ifTrue: [
		fuerzaAtajada := arquero fuerza .
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1.
		   
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
                    puntajeDelantero := 1.
		   direccionRemate:= direccionTiro.
        ].
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar .
	(self esAngulo: direccionTiro )ifFalse: [direccionRemate := direccionTiro x @ (direccionTiro y +2)] ifTrue: [(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)]] .
	(direccionRemate y > 2 ) ifTrue: [puntajeArquero:=1] ifFalse:[
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate y = direccionArquero y ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeArquero := 1.
        ].
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 18:09:03' prior: 50538806!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	
self direccionValidaParaTiro: direccionTiro direccionValidaArquero: direccionArquero. 
delantero tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero.
(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar +  ((delantero fuerzaATirar*20)/100).
	
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [
	(self esAngulo: direccionTiro)ifTrue:[(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)]]ifFalse:[direccionRemate := direccionTiro ].
	direccionRemate  x = direccionArquero x  ifTrue: [
		fuerzaAtajada := arquero fuerza .
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1.
		   
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
                    puntajeDelantero := 1.
		   direccionRemate:= direccionTiro.
        ].
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar .
	(self esAngulo: direccionTiro )ifFalse: [direccionRemate := direccionTiro x @ (direccionTiro y +2)] ifTrue: [(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)]] .
	(direccionRemate y > 2 ) ifTrue: [puntajeArquero:=1] ifFalse:[
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate y = direccionArquero y ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeArquero := 1.
        ].
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

Delantero subclass: #DelanteroTiraAMatar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #DelanteroTiraAMatar category: #'ISW1-2023-2C-Parcial-1' stamp: 'I 4/27/2024 18:12:32'!
Delantero subclass: #DelanteroTiraAMatar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

Delantero subclass: #DelanteroTiraAColocar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #DelanteroTiraAColocar category: #'ISW1-2023-2C-Parcial-1' stamp: 'I 4/27/2024 18:12:40'!
Delantero subclass: #DelanteroTiraAColocar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Delantero class methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:14:21' prior: 50528340!
decideTirarAColocarSuFuerzaBaseEs: cantidadDeFuerzaALanzar
	^DelanteroTiraAColocar new           			withFuerzaBase:cantidadDeFuerzaALanzar! !
!DelanteroTiraAColocar methodsFor: 'nil' stamp: 'I 4/27/2024 18:15:10'!
withFuerzaBase:cantidadDeFuerzaALanzar
	fuerzaBase := cantidadDeFuerzaALanzar/2! !
!DelanteroTiraAMatar methodsFor: 'nil' stamp: 'I 4/27/2024 18:15:44'!
withFuerzaBase:cantidadDeFuerzaALanzar
	fuerzaBase := cantidadDeFuerzaALanzar! !
!Delantero class methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:20:02' prior: 50528164!
decideTirarAMatarSuFuerzaBaseEs: cantidadDeFuerzaALanzar
	^DelanteroTiraAMatar new        			withFuerzaBase:cantidadDeFuerzaALanzar! !

Pelota subclass: #Jabulani
	instanceVariableNames: 'pelota'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

Pelota subclass: #Jabulani
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Jabulani category: #'ISW1-2023-2C-Parcial-1' stamp: 'I 4/27/2024 18:21:06'!
Pelota subclass: #Jabulani
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

Pelota subclass: #Playera
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Playera category: #'ISW1-2023-2C-Parcial-1' stamp: 'I 4/27/2024 18:21:09'!
Pelota subclass: #Playera
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!DelanteroTiraAColocar methodsFor: 'nil' stamp: 'I 4/27/2024 18:23:38'!
tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero
	fuerzaBase := pelota esPateadaConFuerza: fuerzaBase.! !
!DelanteroTiraAColocar methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:26:16' prior: 50539259!
tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero
      |direccionPelota|
	direccionPelota := pelota esLanzadaConDireccion: direccionTiro.
	fuerzaBase := pelota esPateadaConFuerza: fuerzaBase.
	
	arquero atajaPelota: pelota conDireccion: direccionTiro defendiendoLaDireccion.! !
!Pelota class methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:26:47' prior: 50528214!
jabulaniSudafricanaRapida
	^Jabulani new ! !
!Pelota class methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:26:57' prior: 50530545!
playeraLentaCostaAzul.
	^Playera new ! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 18:27:32'!
PASSED!
!DelanteroTiraAColocar methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:28:09' prior: 50539268!
tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero
      |direccionPelota|
	direccionPelota := pelota esLanzadaAColocarConDireccion: direccionTiro.
	fuerzaBase := pelota esPateadaConFuerza: fuerzaBase.
	
	arquero atajaPelota: pelota conDireccion: direccionTiro defendiendoLaDireccion.! !
!Jabulani methodsFor: 'nil' stamp: 'I 4/27/2024 18:28:27'!
esLanzadaAColocarConDireccion: direccionTiro
	^direccionTiro! !
!DelanteroTiraAColocar methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:28:43' prior: 50539296!
tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero
      |direccionPelota|
	direccionPelota := pelota esLanzadaAColocarConDireccion: direccionTiro.
	fuerzaBase := pelota esPateadaConFuerzaAColocar: fuerzaBase.
	
	arquero atajaPelota: pelota conDireccion: direccionTiro defendiendoLaDireccion.! !
!DelanteroTiraAColocar methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:28:54' prior: 50539316!
tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero
      |direccionPelota|
	direccionPelota := pelota esLanzadaAColocarConDireccion: direccionTiro.
	fuerzaBase := pelota esPateadaConFuerzaAColocar: fuerzaBase.
	
	arquero atajaPelota: pelota conDireccion: direccionPelota defendiendoLaDireccion.! !
!Jabulani methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:29:29'!
esPateadaConFuerzaAColocar: fuerzaLlegada
	^fuerzaLlegada! !
!DelanteroTiraAColocar methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:30:16' prior: 50539331!
tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero
      |direccionPelota|
	direccionPelota := pelota esLanzadaAColocarConDireccion: direccionTiro.
	fuerzaBase := pelota esPateadaConFuerzaAColocar: fuerzaBase.
	
	arquero atajaPelota: pelota conDireccion: direccionPelota defendiendoLaDireccion: direccionArquero ! !
!DelanteroTiraAColocar methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:30:33' prior: 50539351!
tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero
      |direccionPelota|
	direccionPelota := pelota esLanzadaAColocarConDireccion: direccionTiro.
	fuerzaBase := pelota esPateadaConFuerzaAColocar: fuerzaBase.
	
	arquero atajaPelota: pelota conDireccion: direccionPelota defendiendoLaDireccion: direccionArquero conPotenciaDePelota: fuerzaBase. ! !

----SNAPSHOT----(27 April 2024 18:31:05) CuisUniversity-6169.image priorSource: 6245038!

Arquero subclass: #ArqueroEspera
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #ArqueroEspera category: #'ISW1-2023-2C-Parcial-1' stamp: 'I 4/27/2024 18:32:41'!
Arquero subclass: #ArqueroEspera
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

Arquero subclass: #ArqueroElige
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #ArqueroElige category: #'ISW1-2023-2C-Parcial-1' stamp: 'I 4/27/2024 18:32:49'!
Arquero subclass: #ArqueroElige
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Arquero class methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:33:13' prior: 50530381!
eligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaParaAtajar
	^ArqueroElige new withFuerzaBase: fuerzaParaAtajar.! !
!Arquero class methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:33:25' prior: 50528323!
esperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaParaAtajar
	^ArqueroEspera new withFuerzaBase: fuerzaParaAtajar.! !
!ArqueroElige methodsFor: 'nil' stamp: 'I 4/27/2024 18:33:45'!
withFuerzaBase: fuerzaParaAtajar.
	! !
!ArqueroElige methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:34:00' prior: 50539424!
withFuerzaBase: fuerzaParaAtajar.
	fuerzaBase:= fuerzaParaAtajar.! !
!ArqueroEspera methodsFor: 'nil' stamp: 'I 4/27/2024 18:34:04'!
withFuerzaBase: fuerzaParaAtajar.
	fuerzaBase:= fuerzaParaAtajar.! !
!DelanteroTiraAColocar methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:37:08' prior: 50539367!
tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero
      |direccionPelota|
	direccionPelota := pelota esLanzadaAColocarConDireccion: direccionTiro.
	fuerzaBase := pelota esPateadaConFuerzaAColocar: fuerzaBase.
	
	arquero atajaPelota: pelota conDireccion: direccionPelota defendiendoLaDireccion: direccionArquero conPotenciaDePelotaAColocar: fuerzaBase.
	! !

Object subclass: #Delantero
	instanceVariableNames: 'fuerzaBase direccionRematada'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Delantero category: #'ISW1-2023-2C-Parcial-1' stamp: 'I 4/27/2024 18:39:20'!
Object subclass: #Delantero
	instanceVariableNames: 'fuerzaBase direccionRematada'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!DelanteroTiraAColocar methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:39:30' prior: 50539440!
tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero
      |direccionPelota|
	direccionRematada := pelota esLanzadaAColocarConDireccion: direccionTiro.
	fuerzaBase := pelota esPateadaConFuerzaAColocar: fuerzaBase.
	
	arquero atajaPelota: pelota conDireccion: direccionPelota defendiendoLaDireccion: direccionArquero conPotenciaDePelotaAColocar: fuerzaBase.
	! !
!DelanteroTiraAColocar methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:39:45' prior: 50539471!
tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero

	direccionRematada := pelota esLanzadaAColocarConDireccion: direccionTiro.
	fuerzaBase := pelota esPateadaConFuerzaAColocar: fuerzaBase.
	
	arquero atajaPelota: pelota conDireccion: direccionRematada defendiendoLaDireccion: direccionArquero conPotenciaDePelotaAColocar: fuerzaBase.
	! !

Object subclass: #Delantero
	instanceVariableNames: 'fuerzaBase direccionRematada puntaje'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Delantero category: #'ISW1-2023-2C-Parcial-1' stamp: 'I 4/27/2024 18:40:18'!
Object subclass: #Delantero
	instanceVariableNames: 'fuerzaBase direccionRematada puntaje'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

Object subclass: #Arquero
	instanceVariableNames: 'fuerzaBase estrategia puntaje'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Arquero category: #'ISW1-2023-2C-Parcial-1' stamp: 'I 4/27/2024 18:40:23'!
Object subclass: #Arquero
	instanceVariableNames: 'fuerzaBase estrategia puntaje'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Arquero methodsFor: 'initialization' stamp: 'I 4/27/2024 18:40:34' prior: 50528280!
initializeWithEstrategia: estrategiaARealizar withFuerzaBase: fuerzaParaAtajar.
	fuerzaBase := fuerzaParaAtajar.
	estrategia := estrategiaARealizar.
	puntaje := 0! !
!ArqueroElige methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:41:13' prior: 50539429!
withFuerzaBase: fuerzaParaAtajar.
	fuerzaBase:= fuerzaParaAtajar.
	puntaje := 0.! !
!ArqueroEspera methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:41:17' prior: 50539434!
withFuerzaBase: fuerzaParaAtajar.
	fuerzaBase:= fuerzaParaAtajar.
	puntaje := 0.! !
!Delantero methodsFor: 'nil' stamp: 'I 4/27/2024 18:42:09'!
puntaje
	^ puntaje! !
!DelanteroTiraAColocar methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:42:48' prior: 50539488!
tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero

	direccionRematada := pelota esLanzadaAColocarConDireccion: direccionTiro.
	fuerzaBase := pelota esPateadaConFuerzaAColocar: fuerzaBase.
	
	pelota esTiradaAArquero: arquero conDireccion: direccionRematada defendiendoLaDireccion: direccionArquero conPotenciaDePelotaAColocar: fuerzaBase.
	! !
!DelanteroTiraAColocar methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:43:30' prior: 50539555!
tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero

	direccionRematada := pelota esLanzadaAColocarConDireccion: direccionTiro.
	fuerzaBase := pelota esPateadaConFuerzaAColocar: fuerzaBase.
	
	pelota esTiradaAArquero: arquero conDireccion: direccionRematada defendiendoLaDireccion: direccionArquero conPotenciaDePelotaAColocar: fuerzaBase delDelantero: self.
	! !
!Jabulani methodsFor: 'nil' stamp: 'I 4/27/2024 18:47:45'!
esTiradaAArquero: arquero conDireccion: direccionRematada defendiendoLaDireccion: direccionArquero conPotenciaDePelotaAColocar: fuerzaBase delDelantero: delantero
	arquero defiendeJabulaniAColocarConDireccion: direccionRematada
	defendiendoLaDireccion: direccionArquero    conPotenciaDePelotaAColocar: fuerzaBase delDelantero: delantero ! !
!ArqueroElige methodsFor: 'nil' stamp: 'I 4/27/2024 18:52:30'!
defiendeJabulaniAColocarConDireccion: direccionRemate
defendiendoLaDireccion: direccionArquero    conPotenciaDePelotaAColocar: fuerzaPateada delDelantero: delantero 


(direccionRemate = direccionArquero) ifTrue:[self mismaDireccionConFuerza: fuerzaPateada delDelantero: delantero] ifFalse:[delantero puntaje ]! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 18:54:10' prior: 50538993!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	
self direccionValidaParaTiro: direccionTiro direccionValidaArquero: direccionArquero. 
delantero tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero delPenal: self.
(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar +  ((delantero fuerzaATirar*20)/100).
	
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [
	(self esAngulo: direccionTiro)ifTrue:[(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)]]ifFalse:[direccionRemate := direccionTiro ].
	direccionRemate  x = direccionArquero x  ifTrue: [
		fuerzaAtajada := arquero fuerza .
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1.
		   
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
                    puntajeDelantero := 1.
		   direccionRemate:= direccionTiro.
        ].
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar .
	(self esAngulo: direccionTiro )ifFalse: [direccionRemate := direccionTiro x @ (direccionTiro y +2)] ifTrue: [(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)]] .
	(direccionRemate y > 2 ) ifTrue: [puntajeArquero:=1] ifFalse:[
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate y = direccionArquero y ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeArquero := 1.
        ].
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!DelanteroTiraAColocar methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:54:25'!
tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero delPenal: penalADecidir

	direccionRematada := pelota esLanzadaAColocarConDireccion: direccionTiro.
	fuerzaBase := pelota esPateadaConFuerzaAColocar: fuerzaBase.
	
	pelota esTiradaAArquero: arquero conDireccion: direccionRematada defendiendoLaDireccion: direccionArquero conPotenciaDePelotaAColocar: fuerzaBase delDelantero: self.
	! !
!DelanteroTiraAColocar methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:54:45' prior: 50539802!
tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero delPenal: penalADecidir

	direccionRematada := pelota esLanzadaAColocarConDireccion: direccionTiro.
	fuerzaBase := pelota esPateadaConFuerzaAColocar: fuerzaBase.
	
	pelota esTiradaAArquero: arquero conDireccion: direccionRematada defendiendoLaDireccion: direccionArquero conPotenciaDePelotaAColocar: fuerzaBase delDelantero: self delPenal: penalADecidir.
	! !
!Jabulani methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:55:02'!
esTiradaAArquero: arquero conDireccion: direccionRematada defendiendoLaDireccion: direccionArquero conPotenciaDePelotaAColocar: fuerzaBase delDelantero: delantero
delPenal: penalADecidir
	arquero defiendeJabulaniAColocarConDireccion: direccionRematada
	defendiendoLaDireccion: direccionArquero    conPotenciaDePelotaAColocar: fuerzaBase delDelantero: delantero delPenal: penalADecidir! !
!ArqueroElige methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:55:18'!
defiendeJabulaniAColocarConDireccion: direccionRemate
defendiendoLaDireccion: direccionArquero    conPotenciaDePelotaAColocar: fuerzaPateada delDelantero: delantero
delPenal: penalADecidir 


(direccionRemate = direccionArquero) ifTrue:[self mismaDireccionConFuerza: fuerzaPateada delDelantero: delantero] ifFalse:[delantero puntaje ]! !
!ArqueroElige methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:55:33' prior: 50539853!
defiendeJabulaniAColocarConDireccion: direccionRemate
defendiendoLaDireccion: direccionArquero    conPotenciaDePelotaAColocar: fuerzaPateada delDelantero: delantero
delPenal: penalADecidir 


(direccionRemate = direccionArquero) ifTrue:[self mismaDireccionConFuerza: fuerzaPateada delDelantero: delantero] ifFalse:[penalADecidir ganaDelantero ]! !

!methodRemoval: ArqueroElige #defiendeJabulaniAColocarConDireccion:defendiendoLaDireccion:conPotenciaDePelotaAColocar:delDelantero: stamp: 'I 4/27/2024 18:55:52'!
defiendeJabulaniAColocarConDireccion: direccionRemate
defendiendoLaDireccion: direccionArquero    conPotenciaDePelotaAColocar: fuerzaPateada delDelantero: delantero 


(direccionRemate = direccionArquero) ifTrue:[self mismaDireccionConFuerza: fuerzaPateada delDelantero: delantero] ifFalse:[delantero puntaje ]!
!Penales methodsFor: 'nil' stamp: 'I 4/27/2024 18:56:24'!
ganaArquero
	puntajeArquero:= 1.! !
!ArqueroElige methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:57:09'!
mismaDireccionConFuerza: fuerzaPateada delDelantero: delantero
(fuerzaPateada>fuerzaBase)ifTrue:[]! !
!ArqueroElige methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:57:32' prior: 50539867!
defiendeJabulaniAColocarConDireccion: direccionRemate
defendiendoLaDireccion: direccionArquero    conPotenciaDePelotaAColocar: fuerzaPateada delDelantero: delantero
delPenal: penalADecidir 


(direccionRemate = direccionArquero) ifTrue:[self mismaDireccionConFuerza: fuerzaPateada delDelantero: delantero paraPenal: penalADecidir] ifFalse:[penalADecidir ganaDelantero ]! !
!Penales methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:58:20'!
ganaDelantero
	puntajeDelantero:= 1.! !
!ArqueroElige methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:58:30'!
mismaDireccionConFuerza: fuerzaPateada delDelantero: delantero
paraPenal: penalADecidir
(fuerzaPateada>fuerzaBase)ifTrue:[penalADecidir ganaDelantero]! !
!ArqueroElige methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 18:58:58' prior: 50539924!
mismaDireccionConFuerza: fuerzaPateada delDelantero: delantero
paraPenal: penalADecidir
(fuerzaPateada>fuerzaBase)ifTrue:[penalADecidir ganaDelantero]ifFalse:[penalADecidir ganaArquero]! !
!Arquero methodsFor: 'nil' stamp: 'I 4/27/2024 19:00:06'!
mismaDireccionConFuerza: fuerzaPateada delDelantero: delantero
paraPenal: penalADecidir
(fuerzaPateada>fuerzaBase)ifTrue:[penalADecidir ganaDelantero]ifFalse:[penalADecidir ganaArquero]! !

!methodRemoval: ArqueroElige #mismaDireccionConFuerza:delDelantero: stamp: 'I 4/27/2024 19:00:10'!
mismaDireccionConFuerza: fuerzaPateada delDelantero: delantero
(fuerzaPateada>fuerzaBase)ifTrue:[]!

!methodRemoval: ArqueroElige #mismaDireccionConFuerza:delDelantero:paraPenal: stamp: 'I 4/27/2024 19:00:13'!
mismaDireccionConFuerza: fuerzaPateada delDelantero: delantero
paraPenal: penalADecidir
(fuerzaPateada>fuerzaBase)ifTrue:[penalADecidir ganaDelantero]ifFalse:[penalADecidir ganaArquero]!

!methodRemoval: DelanteroTiraAColocar #tiralAlArcoConDireccion:conPelota:conArquero:arqueroDefendiendoDireccion: stamp: 'I 4/27/2024 19:00:41'!
tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero

	direccionRematada := pelota esLanzadaAColocarConDireccion: direccionTiro.
	fuerzaBase := pelota esPateadaConFuerzaAColocar: fuerzaBase.
	
	pelota esTiradaAArquero: arquero conDireccion: direccionRematada defendiendoLaDireccion: direccionArquero conPotenciaDePelotaAColocar: fuerzaBase delDelantero: self.
	!
!DelanteroTiraAColocar methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 19:03:42' prior: 50539820!
tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero delPenal: penalADecidir

	direccionRematada := pelota esLanzadaAColocarConDireccion: direccionTiro.
	fuerzaBase := pelota esPateadaConFuerzaAColocar: fuerzaBase.
	penalADecidir esLanzadoADireccion: direccionRematada.
	pelota esTiradaAArquero: arquero conDireccion: direccionRematada defendiendoLaDireccion: direccionArquero conPotenciaDePelotaAColocar: fuerzaBase delDelantero: self delPenal: penalADecidir.
	! !
!Penales methodsFor: 'nil' stamp: 'I 4/27/2024 19:04:15'!
esLanzadoADireccion: direccionTiro
	direccionRemate := direccionTiro.! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 19:05:15'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 19:05:15'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'I 4/27/2024 19:05:15'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'I 4/27/2024 19:05:15'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'I 4/27/2024 19:05:15'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 19:05:15'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'I 4/27/2024 19:05:15'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'I 4/27/2024 19:05:15'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 19:05:15'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 19:05:15'!
ERROR!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 19:05:15'!
ERROR!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 19:05:15'!
ERROR!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 19:05:15'!
ERROR!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'I 4/27/2024 19:05:15'!
FAILURE!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 19:05:15'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 19:05:15'!
ERROR!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 19:05:15'!
ERROR!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 19:05:15'!
ERROR!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'I 4/27/2024 19:05:15'!
ERROR!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 19:05:15'!
ERROR!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 19:05:15'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 19:05:15'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 19:05:15'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 19:05:15'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 19:05:15'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 19:05:15'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 19:05:15'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 19:05:15'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 19:05:15'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 19:05:15'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 19:05:15'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 19:05:15'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 19:05:15'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 19:05:15'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 19:05:15'!
ERROR!
!ArqueroEspera methodsFor: 'nil' stamp: 'I 4/27/2024 19:06:00'!
defiendeJabulaniAColocarConDireccion: direccionRemate
defendiendoLaDireccion: direccionArquero    conPotenciaDePelotaAColocar: fuerzaPateada delDelantero: delantero
delPenal: penalADecidir 


(direccionRemate x = direccionArquero x ) ifTrue:[self mismaDireccionConFuerza: fuerzaPateada delDelantero: delantero paraPenal: penalADecidir] ifFalse:[penalADecidir ganaDelantero ]! !

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 19:07:32'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 19:07:32'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'I 4/27/2024 19:07:32'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'I 4/27/2024 19:07:32'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'I 4/27/2024 19:07:32'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 19:07:32'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'I 4/27/2024 19:07:32'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'I 4/27/2024 19:07:32'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 19:07:32'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 19:07:32'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 19:07:32'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 19:07:32'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 19:07:32'!
FAILURE!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'I 4/27/2024 19:07:32'!
FAILURE!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 19:07:32'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 19:07:32'!
PASSED!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 19:07:32'!
ERROR!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 19:07:32'!
ERROR!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'I 4/27/2024 19:07:32'!
ERROR!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 19:07:32'!
ERROR!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 19:07:32'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 19:07:32'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 19:07:32'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 19:07:32'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 19:07:32'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 19:07:32'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 19:07:32'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 19:07:32'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 19:07:32'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 19:07:32'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 19:07:32'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 19:07:32'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 19:07:32'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 19:07:32'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 19:07:32'!
ERROR!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 19:07:37'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 19:07:39'!
PASSED!
!DelanteroTiraAColocar methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 19:10:34' prior: 50539983!
tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero delPenal: penalADecidir

	direccionRematada := pelota esLanzadaAColocarConDireccion: direccionTiro.
	fuerzaBase := pelota esPateadaConFuerzaAColocar: fuerzaBase.
	penalADecidir esLanzadoADireccion: direccionRematada.
	pelota esTiradaAArquero: arquero conDireccion: direccionRematada defendiendoLaDireccion: direccionArquero delDelantero: self delPenal: penalADecidir.
	! !

!methodRemoval: Jabulani #esTiradaAArquero:conDireccion:defendiendoLaDireccion:conPotenciaDePelotaAColocar:delDelantero: stamp: 'I 4/27/2024 19:10:52'!
esTiradaAArquero: arquero conDireccion: direccionRematada defendiendoLaDireccion: direccionArquero conPotenciaDePelotaAColocar: fuerzaBase delDelantero: delantero
	arquero defiendeJabulaniAColocarConDireccion: direccionRematada
	defendiendoLaDireccion: direccionArquero    conPotenciaDePelotaAColocar: fuerzaBase delDelantero: delantero !
!Jabulani methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 19:11:06'!
esTiradaAArquero: arquero conDireccion: direccionRematada defendiendoLaDireccion: direccionArquero delDelantero: delantero
delPenal: penalADecidir
	arquero defiendeJabulaniAColocarConDireccion: direccionRematada
	defendiendoLaDireccion: direccionArquero delDelantero: delantero delPenal: penalADecidir! !
!DelanteroTiraAColocar methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 19:11:39' prior: 50540306!
tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero delPenal: penalADecidir

	direccionRematada := pelota esLanzadaAColocarConDireccion: direccionTiro.
	fuerzaBase := pelota esPateadaConFuerzaAColocar: fuerzaBase.
	penalADecidir esLanzadoADireccion: direccionRematada.
	pelota esTiradaAArquero: arquero defendiendoLaDireccion: direccionArquero delDelantero: self delPenal: penalADecidir.
	! !
!DelanteroTiraAColocar methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 19:13:19' prior: 50540353!
tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero delPenal: penalADecidir

	direccionRematada := pelota esLanzadaAColocarConDireccion: direccionTiro.
	fuerzaBase := pelota esPateadaConFuerzaAColocar: fuerzaBase.
	penalADecidir esLanzadoADireccion: direccionRematada.
	pelota esTiradaAlArquero: arquero defendiendoLaDireccion: direccionArquero delDelantero: self delPenal: penalADecidir.
	! !
!Jabulani methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 19:21:54'!
esTiradaAlArquero: arquero conDireccion: direccionRematada defendiendoLaDireccion: direccionArquero delDelantero: delantero
delPenal: penalADecidir
	arquero defiendeJabulaniAColocarConDireccion: direccionRematada
	defendiendoLaDireccion: direccionArquero delDelantero: delantero delPenal: penalADecidir! !

!methodRemoval: Jabulani #esTiradaAArquero:conDireccion:defendiendoLaDireccion:delDelantero:delPenal: stamp: 'I 4/27/2024 19:21:58'!
esTiradaAArquero: arquero conDireccion: direccionRematada defendiendoLaDireccion: direccionArquero delDelantero: delantero
delPenal: penalADecidir
	arquero defiendeJabulaniAColocarConDireccion: direccionRematada
	defendiendoLaDireccion: direccionArquero delDelantero: delantero delPenal: penalADecidir!

!methodRemoval: Jabulani #esTiradaAArquero:conDireccion:defendiendoLaDireccion:conPotenciaDePelotaAColocar:delDelantero:delPenal: stamp: 'I 4/27/2024 19:22:01'!
esTiradaAArquero: arquero conDireccion: direccionRematada defendiendoLaDireccion: direccionArquero conPotenciaDePelotaAColocar: fuerzaBase delDelantero: delantero
delPenal: penalADecidir
	arquero defiendeJabulaniAColocarConDireccion: direccionRematada
	defendiendoLaDireccion: direccionArquero    conPotenciaDePelotaAColocar: fuerzaBase delDelantero: delantero delPenal: penalADecidir!
!Jabulani methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 19:24:24'!
esTiradaAlArquero: arquero defendiendoLaDireccion: direccionArquero delDelantero: delantero
delPenal: penalADecidir
	arquero 	defendiendeLaDireccion: direccionArquero delDelantero: delantero delPenal: penalADecidir! !
!Jabulani methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 19:24:56' prior: 50540431!
esTiradaAlArquero: arquero defendiendoLaDireccion: direccionArquero delDelantero: delantero
delPenal: penalADecidir
	arquero 	defendiendeJabulaniAColocarConDireccion: direccionArquero delDelantero: delantero delPenal: penalADecidir! !
!Jabulani methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 19:25:26' prior: 50540441!
esTiradaAlArquero: arquero defendiendoLaDireccion: direccionArquero delDelantero: delantero
delPenal: penalADecidir
	arquero 	defendiendeJabulaniAColocarEnDireccion: direccionArquero delDelantero: delantero delPenal: penalADecidir! !
!ArqueroElige methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 19:25:30'!
defiendeJabulaniAColocarDireccion: direccionRemate
defendiendoLaDireccion: direccionArquero    conPotenciaDePelotaAColocar: fuerzaPateada delDelantero: delantero
delPenal: penalADecidir 


(direccionRemate = direccionArquero) ifTrue:[self mismaDireccionConFuerza: fuerzaPateada delDelantero: delantero paraPenal: penalADecidir] ifFalse:[penalADecidir ganaDelantero ]! !
!Penales methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 19:30:19'!
esLanzadoAConFuerza: fuerzaBase
	potenciaTiro := fuerzaBase.! !
!DelanteroTiraAColocar methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 19:31:52' prior: 50540371!
tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero delPenal: penalADecidir

	direccionRematada := pelota esLanzadaAColocarConDireccion: direccionTiro.
	fuerzaBase := pelota esPateadaConFuerzaAColocar: fuerzaBase.
	penalADecidir esLanzadoADireccion: direccionRematada.
	penalADecidir esLanzadoAConFuerza: fuerzaBase.
	pelota esTiradaAColocarAlArquero: arquero defendiendoLaDireccion: direccionArquero delPenal: penalADecidir.
	! !
!Jabulani methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 19:32:47'!
esTiradaAColocarAlArquero: arquero defendiendoLaDireccion: direccionArquero delPenal: penalADecidir
	arquero 	defendiendeJabulaniAColocarEnDireccion: direccionArquero  delPenal: penalADecidir! !
!Jabulani methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 19:37:25' prior: 50540501!
esTiradaAColocarAlArquero: arquero defendiendoLaDireccion: direccionArquero delPenal: penalADecidir
	arquero 	defendiendoJabulaniAColocarEnDireccion: direccionArquero  delPenal: penalADecidir! !
!ArqueroEspera methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 19:37:29'!
defiendoJabulaniAColocarEnDireccion: direccionRemate
defendiendoLaDireccion: direccionArquero    conPotenciaDePelotaAColocar: fuerzaPateada delDelantero: delantero
delPenal: penalADecidir 


(direccionRemate x = direccionArquero x ) ifTrue:[self mismaDireccionConFuerza: fuerzaPateada delDelantero: delantero paraPenal: penalADecidir] ifFalse:[penalADecidir ganaDelantero ]! !
!ArqueroEspera methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 19:38:26'!
defiendoJabulaniAColocarEnDireccion: direccionRemate
defendiendoLaDireccion: direccionArquero  
delPenal: penalADecidir 


(direccionRemate x = direccionArquero x ) ifTrue:[self mismaDireccionConFuerza: penalADecidir  delDelantero: penalADecidir varFuerzaResultanteDeTiro paraPenal: penalADecidir] ifFalse:[penalADecidir ganaDelantero ]! !

!methodRemoval: ArqueroEspera #defiendeJabulaniAColocarConDireccion:defendiendoLaDireccion:conPotenciaDePelotaAColocar:delDelantero:delPenal: stamp: 'I 4/27/2024 19:38:41'!
defiendeJabulaniAColocarConDireccion: direccionRemate
defendiendoLaDireccion: direccionArquero    conPotenciaDePelotaAColocar: fuerzaPateada delDelantero: delantero
delPenal: penalADecidir 


(direccionRemate x = direccionArquero x ) ifTrue:[self mismaDireccionConFuerza: fuerzaPateada delDelantero: delantero paraPenal: penalADecidir] ifFalse:[penalADecidir ganaDelantero ]!

!methodRemoval: ArqueroEspera #defiendoJabulaniAColocarEnDireccion:defendiendoLaDireccion:conPotenciaDePelotaAColocar:delDelantero:delPenal: stamp: 'I 4/27/2024 19:38:42'!
defiendoJabulaniAColocarEnDireccion: direccionRemate
defendiendoLaDireccion: direccionArquero    conPotenciaDePelotaAColocar: fuerzaPateada delDelantero: delantero
delPenal: penalADecidir 


(direccionRemate x = direccionArquero x ) ifTrue:[self mismaDireccionConFuerza: fuerzaPateada delDelantero: delantero paraPenal: penalADecidir] ifFalse:[penalADecidir ganaDelantero ]!
!ArqueroEspera methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 19:39:40' prior: 50540534!
defiendoJabulaniAColocarEnDireccion: direccionRemate
defendiendoLaDireccion: direccionArquero  
delPenal: penalADecidir 


(direccionRemate x = direccionArquero x ) ifTrue:[self defiendeConFuerza: penalADecidir  varFuerzaResultanteDeAtajada delDelantero: penalADecidir varFuerzaResultanteDeTiro paraPenal: penalADecidir] ifFalse:[penalADecidir ganaDelantero ]! !
!ArqueroEspera methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 19:41:08'!
defiendeConFuerza: fuerzaAtajada delDelantero: fuerzaLanzada paraPenal: penalADecidir

(fuerzaLanzada>fuerzaAtajada)ifTrue:[penalADecidir ganaDelantero]ifFalse:[penalADecidir ganaArquero].
! !
!DelanteroTiraAColocar methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 19:42:01' prior: 50540482!
tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero delPenal: penalADecidir

	direccionRematada := pelota esLanzadaAColocarConDireccion: direccionTiro.
	fuerzaBase := pelota esPateadaConFuerzaAColocar: fuerzaBase.
	penalADecidir esLanzadoADireccion: direccionRematada.
	penalADecidir esLanzadoConFuerza: fuerzaBase.
	pelota esTiradaAColocarAlArquero: arquero defendiendoLaDireccion: direccionArquero delPenal: penalADecidir.
	! !
!Penales methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 19:42:05'!
esLanzadoConFuerza: fuerzaBase
	potenciaTiro := fuerzaBase.! !

!methodRemoval: Penales #esLanzadoAConFuerza: stamp: 'I 4/27/2024 19:42:08'!
esLanzadoAConFuerza: fuerzaBase
	potenciaTiro := fuerzaBase.!
!Penales methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 19:42:27'!
esAtajadoConFuerza: fuerzaBase
	fuerzaAtajada := fuerzaBase.! !

!methodRemoval: Jabulani #esTiradaAlArquero:defendiendoLaDireccion:delDelantero:delPenal: stamp: 'I 4/27/2024 19:45:02'!
esTiradaAlArquero: arquero defendiendoLaDireccion: direccionArquero delDelantero: delantero
delPenal: penalADecidir
	arquero 	defendiendeJabulaniAColocarEnDireccion: direccionArquero delDelantero: delantero delPenal: penalADecidir!

!methodRemoval: Jabulani #esTiradaAlArquero:conDireccion:defendiendoLaDireccion:delDelantero:delPenal: stamp: 'I 4/27/2024 19:45:03'!
esTiradaAlArquero: arquero conDireccion: direccionRematada defendiendoLaDireccion: direccionArquero delDelantero: delantero
delPenal: penalADecidir
	arquero defiendeJabulaniAColocarConDireccion: direccionRematada
	defendiendoLaDireccion: direccionArquero delDelantero: delantero delPenal: penalADecidir!
!Jabulani methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 19:45:13' prior: 50540510!
esTiradaAColocarAlArquero: arquero defendiendoLaDireccion: direccionArquero delPenal: penalADecidir
	arquero 	defendiendeJabulaniAColocarEnDireccion: direccionArquero  delPenal: penalADecidir! !
!ArqueroEspera methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 19:47:10'!
defiendeJabulaniAColocarEnDireccion: direccionArquero  
delPenal: penalADecidir 


(penalADecidir varDireccionRemateResultante x = direccionArquero x ) ifTrue:[self defiendeConFuerza: penalADecidir  varFuerzaResultanteDeAtajada delDelantero: penalADecidir varFuerzaResultanteDeTiro paraPenal: penalADecidir] ifFalse:[penalADecidir ganaDelantero ]! !
!Jabulani methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 19:47:12' prior: 50540663!
esTiradaAColocarAlArquero: arquero defendiendoLaDireccion: direccionArquero delPenal: penalADecidir
	arquero 	defiendenJabulaniAColocarEnDireccion: direccionArquero  delPenal: penalADecidir! !
!ArqueroEspera methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 19:47:37'!
defiendenJabulaniAColocarEnDireccion: direccionArquero  
delPenal: penalADecidir 


(penalADecidir varDireccionRemateResultante x = direccionArquero x ) ifTrue:[self defiendeConFuerza: penalADecidir  varFuerzaResultanteDeAtajada delDelantero: penalADecidir varFuerzaResultanteDeTiro paraPenal: penalADecidir] ifFalse:[penalADecidir ganaDelantero ]! !
!Jabulani methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 19:47:55' prior: 50540686!
esTiradaAColocarAlArquero: arquero defendiendoLaDireccion: direccionArquero delPenal: penalADecidir
	arquero 	defiendeJabulaniAColocarEnDireccion: direccionArquero  delPenal: penalADecidir! !

!methodRemoval: ArqueroEspera #defiendenJabulaniAColocarEnDireccion:delPenal: stamp: 'I 4/27/2024 19:47:58'!
defiendenJabulaniAColocarEnDireccion: direccionArquero  
delPenal: penalADecidir 


(penalADecidir varDireccionRemateResultante x = direccionArquero x ) ifTrue:[self defiendeConFuerza: penalADecidir  varFuerzaResultanteDeAtajada delDelantero: penalADecidir varFuerzaResultanteDeTiro paraPenal: penalADecidir] ifFalse:[penalADecidir ganaDelantero ]!

!methodRemoval: ArqueroEspera #defiendoJabulaniAColocarEnDireccion:defendiendoLaDireccion:delPenal: stamp: 'I 4/27/2024 19:48:26'!
defiendoJabulaniAColocarEnDireccion: direccionRemate
defendiendoLaDireccion: direccionArquero  
delPenal: penalADecidir 


(direccionRemate x = direccionArquero x ) ifTrue:[self defiendeConFuerza: penalADecidir  varFuerzaResultanteDeAtajada delDelantero: penalADecidir varFuerzaResultanteDeTiro paraPenal: penalADecidir] ifFalse:[penalADecidir ganaDelantero ]!
!ArqueroElige methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 19:49:21'!
defiendeJabulaniAColocarEnDireccion: direccionArquero  delPenal: penalADecidir


(penalADecidir varDireccionRemateResultante x = direccionArquero x ) ifTrue:[self defiendeConFuerza: penalADecidir  varFuerzaResultanteDeAtajada delDelantero: penalADecidir varFuerzaResultanteDeTiro paraPenal: penalADecidir] ifFalse:[penalADecidir ganaDelantero ]! !

!methodRemoval: ArqueroElige #defiendeJabulaniAColocarDireccion:defendiendoLaDireccion:conPotenciaDePelotaAColocar:delDelantero:delPenal: stamp: 'I 4/27/2024 19:49:25'!
defiendeJabulaniAColocarDireccion: direccionRemate
defendiendoLaDireccion: direccionArquero    conPotenciaDePelotaAColocar: fuerzaPateada delDelantero: delantero
delPenal: penalADecidir 


(direccionRemate = direccionArquero) ifTrue:[self mismaDireccionConFuerza: fuerzaPateada delDelantero: delantero paraPenal: penalADecidir] ifFalse:[penalADecidir ganaDelantero ]!

!methodRemoval: ArqueroElige #defiendeJabulaniAColocarConDireccion:defendiendoLaDireccion:conPotenciaDePelotaAColocar:delDelantero:delPenal: stamp: 'I 4/27/2024 19:49:26'!
defiendeJabulaniAColocarConDireccion: direccionRemate
defendiendoLaDireccion: direccionArquero    conPotenciaDePelotaAColocar: fuerzaPateada delDelantero: delantero
delPenal: penalADecidir 


(direccionRemate = direccionArquero) ifTrue:[self mismaDireccionConFuerza: fuerzaPateada delDelantero: delantero paraPenal: penalADecidir] ifFalse:[penalADecidir ganaDelantero ]!
!ArqueroElige methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 19:50:31'!
defiendeJabulaniAColocarEnDireccion: direccionArquero conFuerza:fuerzaAtajada delPenal: penalADecidir
	

(penalADecidir varDireccionRemateResultante x = direccionArquero x ) ifTrue:[self defiendeConFuerza: penalADecidir  varFuerzaResultanteDeAtajada delDelantero: penalADecidir varFuerzaResultanteDeTiro paraPenal: penalADecidir] ifFalse:[penalADecidir ganaDelantero ]! !
!ArqueroElige methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 19:50:50' prior: 50540748!
defiendeJabulaniAColocarEnDireccion: direccionArquero delPenal: penalADecidir
	

(penalADecidir varDireccionRemateResultante x = direccionArquero x ) ifTrue:[self defiendeConFuerza: penalADecidir  varFuerzaResultanteDeAtajada delDelantero: penalADecidir varFuerzaResultanteDeTiro paraPenal: penalADecidir] ifFalse:[penalADecidir ganaDelantero ]! !
!ArqueroElige methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 19:51:39' prior: 50540811!
defiendeJabulaniAColocarEnDireccion: direccionArquero delPenal: penalADecidir
	fuerzaBase := fuerzaBase + (fuerzaBase /2).
	penalADecidir esAtajadoConFuerza: fuerzaBase.

(penalADecidir varDireccionRemateResultante x = direccionArquero x ) ifTrue:[self defiendeConFuerza: penalADecidir  varFuerzaResultanteDeAtajada delDelantero: penalADecidir varFuerzaResultanteDeTiro paraPenal: penalADecidir] ifFalse:[penalADecidir ganaDelantero ]! !

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 19:53:51'!
ERROR!

!methodRemoval: ArqueroElige #defiendeJabulaniAColocarEnDireccion:conFuerza:delPenal: stamp: 'I 4/27/2024 19:57:09'!
defiendeJabulaniAColocarEnDireccion: direccionArquero conFuerza:fuerzaAtajada delPenal: penalADecidir
	

(penalADecidir varDireccionRemateResultante x = direccionArquero x ) ifTrue:[self defiendeConFuerza: penalADecidir  varFuerzaResultanteDeAtajada delDelantero: penalADecidir varFuerzaResultanteDeTiro paraPenal: penalADecidir] ifFalse:[penalADecidir ganaDelantero ]!
!ArqueroElige methodsFor: 'nil' stamp: 'I 4/27/2024 19:57:27'!
defiendeConFuerza: fuerzaAtajada delDelantero: fuerzaLanzada paraPenal: penalADecidir

(fuerzaLanzada>fuerzaAtajada)ifTrue:[penalADecidir ganaDelantero]ifFalse:[penalADecidir ganaArquero].
! !

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 19:58:17'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 19:58:18'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'I 4/27/2024 19:58:20'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 19:58:22'!
ERROR!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 19:58:22'!
ERROR!
!Playera methodsFor: 'nil' stamp: 'I 4/27/2024 20:00:37'!
esPateadaConFuerzaAColocar: fuerzaLlegada
	^fuerzaLlegada / 2 - (((fuerzaLlegada fuerzaATirar / 2)*20)/100)! !
!Playera methodsFor: 'nil' stamp: 'I 4/27/2024 20:01:32'!
esLanzadaAColocarConDireccion: direccionTiro
	^direccionTiro! !
!Playera methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 20:01:47'!
esTiradaAColocarAlArquero: arquero defendiendoLaDireccion: direccionArquero delPenal: penalADecidir
	arquero 	defiendePlayeraAColocarEnDireccion: direccionArquero  delPenal: penalADecidir! !
!ArqueroElige methodsFor: 'nil' stamp: 'I 4/27/2024 20:03:19'!
defiendePlayeraAColocarEnDireccion: direccionArquero  delPenal: penalADecidir
	! !
!ArqueroElige methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 20:05:17' prior: 50540908!
defiendePlayeraAColocarEnDireccion: direccionArquero  delPenal: penalADecidir
	fuerzaBase := fuerzaBase + fuerzaBase .
	penalADecidir esAtajadoConFuerza: fuerzaBase.

(penalADecidir varDireccionRemateResultante x = direccionArquero x ) ifTrue:[self defiendeConFuerza: penalADecidir  varFuerzaResultanteDeAtajada delDelantero: penalADecidir varFuerzaResultanteDeTiro paraPenal: penalADecidir] ifFalse:[penalADecidir ganaDelantero ]! !
!ArqueroElige methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 20:05:24' prior: 50540914!
defiendePlayeraAColocarEnDireccion: direccionArquero  delPenal: penalADecidir
	fuerzaBase := fuerzaBase *2 .
	penalADecidir esAtajadoConFuerza: fuerzaBase.

(penalADecidir varDireccionRemateResultante x = direccionArquero x ) ifTrue:[self defiendeConFuerza: penalADecidir  varFuerzaResultanteDeAtajada delDelantero: penalADecidir varFuerzaResultanteDeTiro paraPenal: penalADecidir] ifFalse:[penalADecidir ganaDelantero ]! !
!ArqueroEspera methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 20:06:30'!
defiendePlayeraAColocarEnDireccion: direccionArquero  delPenal: penalADecidir
	
	penalADecidir ganaDelantero.
! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 20:07:02' prior: 50539614!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	
self direccionValidaParaTiro: direccionTiro direccionValidaArquero: direccionArquero. 
delantero tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero delPenal: self."
(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
]."
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar +  ((delantero fuerzaATirar*20)/100).
	
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [
	(self esAngulo: direccionTiro)ifTrue:[(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)]]ifFalse:[direccionRemate := direccionTiro ].
	direccionRemate  x = direccionArquero x  ifTrue: [
		fuerzaAtajada := arquero fuerza .
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1.
		   
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
                    puntajeDelantero := 1.
		   direccionRemate:= direccionTiro.
        ].
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar .
	(self esAngulo: direccionTiro )ifFalse: [direccionRemate := direccionTiro x @ (direccionTiro y +2)] ifTrue: [(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)]] .
	(direccionRemate y > 2 ) ifTrue: [puntajeArquero:=1] ifFalse:[
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate y = direccionArquero y ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeArquero := 1.
        ].
    ]
].
	"xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 20:07:05'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'I 4/27/2024 20:07:05'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'I 4/27/2024 20:07:05'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'I 4/27/2024 20:07:05'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 20:07:05'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'I 4/27/2024 20:07:05'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'I 4/27/2024 20:07:05'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 20:07:05'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 20:07:05'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 20:07:05'!
ERROR!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 20:07:05'!
ERROR!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 20:07:05'!
ERROR!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'I 4/27/2024 20:07:05'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 20:07:05'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 20:07:05'!
ERROR!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 20:07:05'!
ERROR!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 20:07:05'!
ERROR!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'I 4/27/2024 20:07:05'!
ERROR!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 20:07:05'!
ERROR!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 20:07:05'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 20:07:05'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 20:07:05'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 20:07:05'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 20:07:05'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 20:07:05'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 20:07:05'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 20:07:05'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 20:07:05'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 20:07:05'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 20:07:05'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 20:07:05'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 20:07:05'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 20:07:05'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 20:07:05'!
ERROR!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 20:08:11'!
ERROR!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 20:08:46'!
ERROR!
!ArqueroEspera methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 20:11:18' prior: 50540672!
defiendeJabulaniAColocarEnDireccion: direccionArquero  
delPenal: penalADecidir 

	fuerzaBase := fuerzaBase .
(penalADecidir varDireccionRemateResultante x = direccionArquero x ) ifTrue:[self defiendeConFuerza: penalADecidir  varFuerzaResultanteDeAtajada delDelantero: penalADecidir varFuerzaResultanteDeTiro paraPenal: penalADecidir] ifFalse:[penalADecidir ganaDelantero ]! !

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 20:11:26'!
ERROR!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 20:11:26'!
ERROR!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 20:11:43'!
ERROR!
!ArqueroEspera methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 20:12:24' prior: 50541284!
defiendeJabulaniAColocarEnDireccion: direccionArquero  
delPenal: penalADecidir 

	fuerzaBase := fuerzaBase .
	penalADecidir esAtajadoConFuerza: fuerzaBase.
(penalADecidir varDireccionRemateResultante x = direccionArquero x ) ifTrue:[self defiendeConFuerza: penalADecidir  varFuerzaResultanteDeAtajada delDelantero: penalADecidir varFuerzaResultanteDeTiro paraPenal: penalADecidir] ifFalse:[penalADecidir ganaDelantero ]! !

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 20:12:35'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 20:12:37'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 20:12:38'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 20:12:40'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'I 4/27/2024 20:12:40'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'I 4/27/2024 20:12:40'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'I 4/27/2024 20:12:40'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 20:12:40'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'I 4/27/2024 20:12:40'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'I 4/27/2024 20:12:40'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 20:12:40'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 20:12:40'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 20:12:40'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 20:12:40'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 20:12:40'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'I 4/27/2024 20:12:40'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 20:12:40'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 20:12:40'!
PASSED!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 20:12:40'!
ERROR!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 20:12:40'!
ERROR!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'I 4/27/2024 20:12:40'!
ERROR!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 20:12:40'!
ERROR!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 20:12:40'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 20:12:40'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 20:12:40'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 20:12:40'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 20:12:40'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 20:12:40'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 20:12:40'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 20:12:40'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 20:12:40'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 20:12:40'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 20:12:40'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 20:12:40'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 20:12:40'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 20:12:40'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 20:12:40'!
ERROR!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 20:13:05'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'I 4/27/2024 20:13:05'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'I 4/27/2024 20:13:05'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'I 4/27/2024 20:13:05'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 20:13:05'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'I 4/27/2024 20:13:05'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'I 4/27/2024 20:13:05'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 20:13:05'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 20:13:05'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 20:13:05'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 20:13:05'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 20:13:05'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'I 4/27/2024 20:13:05'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 20:13:05'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 20:13:05'!
PASSED!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 20:13:05'!
ERROR!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 20:13:05'!
ERROR!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'I 4/27/2024 20:13:05'!
ERROR!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 20:13:05'!
ERROR!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 20:13:05'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 20:13:05'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 20:13:05'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 20:13:05'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 20:13:05'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 20:13:05'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 20:13:05'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 20:13:05'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 20:13:05'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 20:13:05'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 20:13:05'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 20:13:06'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 20:13:06'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 20:13:06'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 20:13:06'!
ERROR!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 20:13:54'!
ERROR!
!Playera methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 20:14:16' prior: 50540889!
esPateadaConFuerzaAColocar: fuerzaLlegada
	^fuerzaLlegada  - (((fuerzaLlegada  / 2)*20)/100)! !

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 20:14:38'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 20:14:38'!
FAILURE!

(((fuerzaLlegada  / 2)*20)/100)!

((fuerzaLlegada  *20)/100) !
!Playera methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 20:18:44' prior: 50541611!
esPateadaConFuerzaAColocar: fuerzaLlegada
	^fuerzaLlegada  - ((fuerzaLlegada  *20)/100)  ! !

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 20:18:52'!
PASSED!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 20:18:54'!
PASSED!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'I 4/27/2024 20:18:55'!
PASSED!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 20:18:56'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 20:18:58'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'I 4/27/2024 20:18:58'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'I 4/27/2024 20:18:58'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'I 4/27/2024 20:18:58'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 20:18:58'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'I 4/27/2024 20:18:58'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'I 4/27/2024 20:18:58'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 20:18:58'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 20:18:58'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 20:18:58'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 20:18:58'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 20:18:58'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'I 4/27/2024 20:18:58'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 20:18:58'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 20:18:58'!
PASSED!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 20:18:58'!
PASSED!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 20:18:58'!
PASSED!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'I 4/27/2024 20:18:58'!
PASSED!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 20:18:58'!
PASSED!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 20:18:58'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 20:18:58'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 20:18:58'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 20:18:58'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 20:18:58'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 20:18:58'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 20:18:58'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 20:18:58'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 20:18:58'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 20:18:58'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 20:18:58'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 20:18:58'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 20:18:58'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 20:18:58'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 20:18:58'!
ERROR!
!DelanteroTiraAMatar methodsFor: 'nil' stamp: 'I 4/27/2024 20:20:55'!
tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero delPenal: penalADecidir

	direccionRematada := pelota esLanzadaAMatarConDireccion: direccionTiro.
	fuerzaBase := pelota esPateadaConFuerzaAColocar: fuerzaBase.
	penalADecidir esLanzadoADireccion: direccionRematada.
	penalADecidir esLanzadoConFuerza: fuerzaBase.
	pelota esTiradaAColocarAlArquero: arquero defendiendoLaDireccion: direccionArquero delPenal: penalADecidir.
	! !
!DelanteroTiraAMatar methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 20:21:05' prior: 50541786!
tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero delPenal: penalADecidir

	direccionRematada := pelota esLanzadaAMatarConDireccion: direccionTiro.
	fuerzaBase := pelota esPateadaConFuerzaAMatar: fuerzaBase.
	penalADecidir esLanzadoADireccion: direccionRematada.
	penalADecidir esLanzadoConFuerza: fuerzaBase.
	pelota esTiradaAColocarAlArquero: arquero defendiendoLaDireccion: direccionArquero delPenal: penalADecidir.
	! !
!DelanteroTiraAMatar methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 20:21:15' prior: 50541805!
tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero delPenal: penalADecidir

	direccionRematada := pelota esLanzadaAMatarConDireccion: direccionTiro.
	fuerzaBase := pelota esPateadaConFuerzaAMatar: fuerzaBase.
	penalADecidir esLanzadoADireccion: direccionRematada.
	penalADecidir esLanzadoConFuerza: fuerzaBase.
	pelota esTiradaAMatarAlArquero: arquero defendiendoLaDireccion: direccionArquero delPenal: penalADecidir.
	! !
!Jabulani methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 20:22:48'!
esLanzadaAMatarConDireccion: direccionTiro
	^direccionTiro! !
!Jabulani methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 20:23:03'!
esPateadaConFuerzaAMatar: fuerzaLlegada
	^fuerzaLlegada! !
!Jabulani methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 20:24:40' prior: 50541847!
esPateadaConFuerzaAMatar: fuerzaLlegada
	^fuerzaLlegada + ((fuerzaLlegada * 20)/100)! !
!Jabulani methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 20:35:00' prior: 50541842!
esLanzadaAMatarConDireccion: direccionTiro
	^direccionTiro esAngulo ! !
!Jabulani methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 20:38:49' prior: 50541858!
esLanzadaAMatarConDireccion: direccionTiro
	^direccionTiro! !
!DelanteroTiraAMatar methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 20:40:18' prior: 50541824!
tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero delPenal: penalADecidir

	direccionRematada := pelota esLanzadaAMatarConDireccion: direccionTiro.
	fuerzaBase := pelota esPateadaConFuerzaAMatar: fuerzaBase enPenal: penalADecidir.
	penalADecidir esLanzadoADireccion: direccionRematada.
	penalADecidir esLanzadoConFuerza: fuerzaBase.
	pelota esTiradaAMatarAlArquero: arquero defendiendoLaDireccion: direccionArquero delPenal: penalADecidir.
	! !
!DelanteroTiraAMatar methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 20:41:16' prior: 50541870!
tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero delPenal: penalADecidir

	direccionRematada := pelota esLanzadaAMatarConDireccion: direccionTiro enPenal: penalADecidir.
	fuerzaBase := pelota esPateadaConFuerzaAMatar: fuerzaBase .
	penalADecidir esLanzadoADireccion: direccionRematada.
	penalADecidir esLanzadoConFuerza: fuerzaBase.
	pelota esTiradaAMatarAlArquero: arquero defendiendoLaDireccion: direccionArquero delPenal: penalADecidir.
	! !
!Jabulani methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 20:44:58'!
esLanzadaAMatarConDireccion: direccionTiro enPenal: penalADecidir
	(penalADecidir esAngulo: direccionTiro) ifTrue:[(direccionTiro y < 2)ifTrue:[penalADecidir esLanzadoADireccion:( direccionTiro x @ (direccionTiro y +1))]ifFalse:[penalADecidir esLanzadoADireccion: (direccionTiro x @ (direccionTiro y -1))]]ifFalse:[penalADecidir esLanzadoADireccion: direccionTiro ].! !
!Jabulani methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 20:45:54'!
esTiradaAMatarAlArquero: arquero defendiendoLaDireccion: direccionArquero delPenal: penalADecidir
	arquero 	defiendeJabulaniAMatarEnDireccion: direccionArquero  delPenal: penalADecidir! !
!ArqueroElige methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 20:46:39'!
defiendeJabulaniAMatarEnDireccion: direccionArquero  delPenal: penalADecidir
	fuerzaBase := fuerzaBase .
	penalADecidir esAtajadoConFuerza: fuerzaBase.

(penalADecidir varDireccionRemateResultante x = direccionArquero x ) ifTrue:[self defiendeConFuerza: penalADecidir  varFuerzaResultanteDeAtajada delDelantero: penalADecidir varFuerzaResultanteDeTiro paraPenal: penalADecidir] ifFalse:[penalADecidir ganaDelantero ]! !
!ArqueroEspera methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 20:48:55'!
defiendeJabulaniAMatarEnDireccion: direccionArquero  delPenal: penalADecidir
	penalADecidir ganaDelantero.! !
!Playera methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 20:52:43'!
esTiradaAMatarAlArquero: arquero defendiendoLaDireccion: direccionArquero delPenal: penalADecidir
	arquero 	defiendePlayeraAColocarEnDireccion: direccionArquero  delPenal: penalADecidir! !
!Playera methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 20:53:03'!
esLanzadaAMatarConDireccion: direccionTiro enPenal: penalADecidir
	^direccionTiro! !
!Playera methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 20:57:52' prior: 50541963!
esLanzadaAMatarConDireccion: direccionTiro enPenal: penalADecidir
	(penalADecidir esAngulo: direccionTiro )ifFalse: [penalADecidir esLanzadoADireccion: direccionTiro x @ (direccionTiro y +2)] ifTrue: [(direccionTiro y < 2)ifTrue:[penalADecidir esLanzadoADireccion: direccionTiro x @ (direccionTiro y +1)]ifFalse:[penalADecidir esLanzadoADireccion: direccionTiro x @ (direccionTiro y -1)]] .! !
!DelanteroTiraAColocar methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 20:58:16' prior: 50540606!
tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero delPenal: penalADecidir

	pelota esLanzadaAColocarConDireccion: direccionTiro.
	fuerzaBase := pelota esPateadaConFuerzaAColocar: fuerzaBase.
	
	penalADecidir esLanzadoConFuerza: fuerzaBase.
	pelota esTiradaAColocarAlArquero: arquero defendiendoLaDireccion: direccionArquero delPenal: penalADecidir.
	! !
!Playera methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 20:58:53'!
esPateadaConFuerzaAMatar: fuerzaLlegada
	^fuerzaLlegada   ! !

!methodRemoval: Jabulani #esLanzadaAMatarConDireccion: stamp: 'I 4/27/2024 21:00:15'!
esLanzadaAMatarConDireccion: direccionTiro
	^direccionTiro!
!Playera methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 21:01:08' prior: 50541954!
esTiradaAMatarAlArquero: arquero defendiendoLaDireccion: direccionArquero delPenal: penalADecidir
	arquero 	defiendePlayeraAMatarEnDireccion: direccionArquero  delPenal: penalADecidir! !
!ArqueroElige methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 21:02:00'!
efiendePlayeraAMatarEnDireccion: direccionArquero  delPenal: penalADecidir
	fuerzaBase := fuerzaBase *2 .
	penalADecidir esAtajadoConFuerza: fuerzaBase.

(penalADecidir varDireccionRemateResultante y = direccionArquero y ) ifTrue:[self defiendeConFuerza: penalADecidir  varFuerzaResultanteDeAtajada delDelantero: penalADecidir varFuerzaResultanteDeTiro paraPenal: penalADecidir] ifFalse:[penalADecidir ganaDelantero ]! !
!ArqueroEspera methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 21:02:25'!
efiendePlayeraAMatarEnDireccion: direccionArquero  delPenal: penalADecidir
	
	penalADecidir ganaArquero.
! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 21:02:28'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'I 4/27/2024 21:02:28'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'I 4/27/2024 21:02:28'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'I 4/27/2024 21:02:28'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 21:02:28'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'I 4/27/2024 21:02:28'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'I 4/27/2024 21:02:28'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 21:02:28'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 21:02:28'!
ERROR!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 21:02:28'!
ERROR!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 21:02:28'!
ERROR!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 21:02:28'!
ERROR!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'I 4/27/2024 21:02:28'!
ERROR!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 21:02:28'!
ERROR!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 21:02:28'!
ERROR!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 21:02:28'!
ERROR!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 21:02:28'!
ERROR!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'I 4/27/2024 21:02:28'!
ERROR!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 21:02:28'!
FAILURE!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:02:28'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:02:28'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:02:28'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:02:28'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 21:02:28'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 21:02:28'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 21:02:28'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 21:02:28'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 21:02:28'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 21:02:28'!
FAILURE!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 21:02:28'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 21:02:28'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 21:02:28'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 21:02:28'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 21:02:28'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 21:02:40'!
ERROR!
!DelanteroTiraAColocar methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 21:05:49' prior: 50541985!
tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero delPenal: penalADecidir

	penalADecidir esLanzadoADireccion: (pelota esLanzadaAColocarConDireccion: direccionTiro).
	fuerzaBase := pelota esPateadaConFuerzaAColocar: fuerzaBase.
	
	penalADecidir esLanzadoConFuerza: fuerzaBase.
	pelota esTiradaAColocarAlArquero: arquero defendiendoLaDireccion: direccionArquero delPenal: penalADecidir.
	! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 21:05:52'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'I 4/27/2024 21:05:52'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'I 4/27/2024 21:05:52'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'I 4/27/2024 21:05:52'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 21:05:52'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'I 4/27/2024 21:05:52'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'I 4/27/2024 21:05:52'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 21:05:52'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 21:05:52'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 21:05:52'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 21:05:52'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 21:05:52'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'I 4/27/2024 21:05:52'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 21:05:52'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 21:05:53'!
PASSED!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 21:05:53'!
PASSED!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 21:05:53'!
PASSED!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'I 4/27/2024 21:05:53'!
PASSED!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 21:05:53'!
PASSED!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:05:53'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:05:53'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:05:53'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:05:53'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 21:05:53'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 21:05:53'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 21:05:53'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 21:05:53'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 21:05:53'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 21:05:53'!
FAILURE!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 21:05:53'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 21:05:53'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 21:05:53'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 21:05:53'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 21:05:53'!
ERROR!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:06:12'!
ERROR!
!DelanteroTiraAMatar methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 21:06:52' prior: 50541890!
tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero delPenal: penalADecidir

	pelota esLanzadaAMatarConDireccion: direccionTiro enPenal: penalADecidir.
	fuerzaBase := pelota esPateadaConFuerzaAMatar: fuerzaBase .
	penalADecidir esLanzadoADireccion: direccionRematada.
	penalADecidir esLanzadoConFuerza: fuerzaBase.
	pelota esTiradaAMatarAlArquero: arquero defendiendoLaDireccion: direccionArquero delPenal: penalADecidir.
	! !

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:06:56'!
ERROR!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:06:56'!
ERROR!
!DelanteroTiraAMatar methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 21:10:33' prior: 50542338!
tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero delPenal: penalADecidir

	pelota esLanzadaAMatarConDireccion: direccionTiro enPenal: penalADecidir.
	fuerzaBase := pelota esPateadaConFuerzaAMatar: fuerzaBase .
	penalADecidir esLanzadoConFuerza: fuerzaBase.
	pelota esTiradaAMatarAlArquero: arquero defendiendoLaDireccion: direccionArquero delPenal: penalADecidir.
	! !

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:10:38'!
PASSED!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:10:39'!
PASSED!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:10:41'!
PASSED!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:10:42'!
PASSED!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 21:10:43'!
PASSED!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 21:10:45'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 21:10:45'!
ERROR!
!ArqueroEspera methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 21:14:22'!
defiendePlayeraAMatarEnDireccion: direccionArquero  delPenal: penalADecidir
	
	penalADecidir ganaArquero.
! !

!methodRemoval: ArqueroEspera #efiendePlayeraAMatarEnDireccion:delPenal: stamp: 'I 4/27/2024 21:14:24'!
efiendePlayeraAMatarEnDireccion: direccionArquero  delPenal: penalADecidir
	
	penalADecidir ganaArquero.
!
!ArqueroElige methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 21:14:29'!
defiendePlayeraAMatarEnDireccion: direccionArquero  delPenal: penalADecidir
	fuerzaBase := fuerzaBase *2 .
	penalADecidir esAtajadoConFuerza: fuerzaBase.

(penalADecidir varDireccionRemateResultante y = direccionArquero y ) ifTrue:[self defiendeConFuerza: penalADecidir  varFuerzaResultanteDeAtajada delDelantero: penalADecidir varFuerzaResultanteDeTiro paraPenal: penalADecidir] ifFalse:[penalADecidir ganaDelantero ]! !

!methodRemoval: ArqueroElige #efiendePlayeraAMatarEnDireccion:delPenal: stamp: 'I 4/27/2024 21:14:31'!
efiendePlayeraAMatarEnDireccion: direccionArquero  delPenal: penalADecidir
	fuerzaBase := fuerzaBase *2 .
	penalADecidir esAtajadoConFuerza: fuerzaBase.

(penalADecidir varDireccionRemateResultante y = direccionArquero y ) ifTrue:[self defiendeConFuerza: penalADecidir  varFuerzaResultanteDeAtajada delDelantero: penalADecidir varFuerzaResultanteDeTiro paraPenal: penalADecidir] ifFalse:[penalADecidir ganaDelantero ]!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 21:14:37'!
PASSED!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 21:14:39'!
PASSED!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 21:14:41'!
PASSED!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 21:14:42'!
PASSED!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 21:14:44'!
PASSED!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 21:14:45'!
PASSED!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 21:14:47'!
FAILURE!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 21:14:47'!
FAILURE!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 21:14:51'!
PASSED!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 21:14:53'!
PASSED!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 21:14:55'!
PASSED!
!ArqueroElige methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 21:17:53' prior: 50542424!
defiendePlayeraAMatarEnDireccion: direccionArquero  delPenal: penalADecidir
	fuerzaBase := fuerzaBase *2 .
	penalADecidir esAtajadoConFuerza: fuerzaBase.

((penalADecidir varDireccionRemateResultante y = direccionArquero y) and:[penalADecidir direccionValidaParaTiro: penalADecidir varDireccionRemateResultante direccionValidaArquero: direccionArquero]) ifTrue:[self defiendeConFuerza: penalADecidir  varFuerzaResultanteDeAtajada delDelantero: penalADecidir varFuerzaResultanteDeTiro paraPenal: penalADecidir] ifFalse:[penalADecidir ganaDelantero ]! !

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 21:18:02'!
FAILURE!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 21:18:02'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'I 4/27/2024 21:18:53' prior: 50540954!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión]."
	
	
self direccionValidaParaTiro: direccionTiro direccionValidaArquero: direccionArquero. 
delantero tiralAlArcoConDireccion: direccionTiro conPelota: pelota conArquero: arquero arqueroDefendiendoDireccion: direccionArquero delPenal: self."
(delantero estrategia = #aColocar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar / 2.
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +(arquero fuerza/2).
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
            direccionTiro x = direccionArquero  x ifTrue: [
		fuerzaAtajada := arquero fuerza.
                (potenciaTiro) > fuerzaAtajada ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
        ].
	direccionRemate := direccionTiro.
	
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar / 2 - (((delantero fuerzaATirar / 2)*20)/100) .
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionTiro  = direccionArquero  ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeDelantero := 1.
        ].
	direccionRemate := direccionTiro.
    ]
].
(delantero estrategia = #aMatar) ifTrue: [
    pelota pelotaUsada= #Jabulani ifTrue: [
	
	potenciaTiro := delantero fuerzaATirar +  ((delantero fuerzaATirar*20)/100).
	
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [
	(self esAngulo: direccionTiro)ifTrue:[(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)]]ifFalse:[direccionRemate := direccionTiro ].
	direccionRemate  x = direccionArquero x  ifTrue: [
		fuerzaAtajada := arquero fuerza .
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1.
		   
                ].
	
		].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
                    puntajeDelantero := 1.
		   direccionRemate:= direccionTiro.
        ].
    ].
    pelota pelotaUsada = #Playera ifTrue: [
       
	potenciaTiro := delantero fuerzaATirar .
	(self esAngulo: direccionTiro )ifFalse: [direccionRemate := direccionTiro x @ (direccionTiro y +2)] ifTrue: [(direccionTiro y < 2)ifTrue:[direccionRemate := direccionTiro x @ (direccionTiro y +1)]ifFalse:[direccionRemate := direccionTiro x @ (direccionTiro y -1)]] .
	(direccionRemate y > 2 ) ifTrue: [puntajeArquero:=1] ifFalse:[
        arquero estrategia = #EligeDireccionAntesTiro ifTrue: [direccionRemate y = direccionArquero y ifTrue: [
		fuerzaAtajada := arquero fuerza +arquero fuerza.
                (potenciaTiro) > ( fuerzaAtajada) ifTrue: [
                    puntajeDelantero := 1
                ] ifFalse:[puntajeArquero := 1]
            ]ifFalse: [
                    puntajeDelantero := 1
                ].
	
		].].
        arquero estrategia = #EsperaTiroYSeAdelanta ifTrue: [
	puntajeArquero := 1.
        ].
    ]
].
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 21:18:55'!
FAILURE!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 21:18:55'!
FAILURE!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 21:18:59'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 21:18:59'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 21:19:05'!
FAILURE!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 21:19:05'!
FAILURE!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 21:19:08'!
PASSED!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 21:19:09'!
PASSED!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 21:19:11'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 21:19:11'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 21:19:14'!
PASSED!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 21:19:16'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 21:19:17'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'I 4/27/2024 21:19:17'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'I 4/27/2024 21:19:17'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'I 4/27/2024 21:19:17'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 21:19:17'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'I 4/27/2024 21:19:17'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'I 4/27/2024 21:19:17'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 21:19:17'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 21:19:17'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 21:19:17'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 21:19:17'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 21:19:17'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'I 4/27/2024 21:19:17'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 21:19:17'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 21:19:17'!
PASSED!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 21:19:17'!
PASSED!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 21:19:17'!
PASSED!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'I 4/27/2024 21:19:17'!
PASSED!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 21:19:17'!
PASSED!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:19:17'!
PASSED!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:19:17'!
PASSED!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:19:17'!
PASSED!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:19:17'!
PASSED!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 21:19:17'!
PASSED!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 21:19:17'!
PASSED!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 21:19:17'!
PASSED!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 21:19:17'!
PASSED!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 21:19:17'!
PASSED!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 21:19:17'!
PASSED!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 21:19:17'!
PASSED!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 21:19:17'!
FAILURE!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 21:19:17'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 21:19:17'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 21:19:17'!
PASSED!
!ArqueroElige methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 21:21:12' prior: 50542503!
defiendePlayeraAMatarEnDireccion: direccionArquero  delPenal: penalADecidir
	fuerzaBase := fuerzaBase *2 .
	penalADecidir esAtajadoConFuerza: fuerzaBase.

((penalADecidir varDireccionRemateResultante y = direccionArquero y) and:[penalADecidir direccionValidaParaTiro: penalADecidir varDireccionRemateResultante ]) ifTrue:[self defiendeConFuerza: penalADecidir  varFuerzaResultanteDeAtajada delDelantero: penalADecidir varFuerzaResultanteDeTiro paraPenal: penalADecidir] ifFalse:[penalADecidir ganaDelantero ]! !
!Penales methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 21:21:43'!
direccionValidaParaTiro: direccionTiro 
 	^((direccionTiro x between: 0 and: 2) and: [direccionTiro y between: 0 and: 2])! !

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 21:21:49'!
FAILURE!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 21:21:49'!
FAILURE!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 21:21:52'!
PASSED!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 21:21:53'!
PASSED!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 21:21:54'!
PASSED!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 21:21:56'!
PASSED!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 21:21:57'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 21:21:59'!
FAILURE!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 21:21:59'!
PASSED!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 21:21:59'!
FAILURE!
!ArqueroElige methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 21:25:40' prior: 50542908!
defiendePlayeraAMatarEnDireccion: direccionArquero  delPenal: penalADecidir
	fuerzaBase := fuerzaBase *2 .
	penalADecidir esAtajadoConFuerza: fuerzaBase.

(penalADecidir direccionValidaParaTiro: penalADecidir varDireccionRemateResultante ) ifTrue:[self defiendeConFuerza: penalADecidir  varFuerzaResultanteDeAtajada delDelantero: penalADecidir varFuerzaResultanteDeTiro paraPenal: penalADecidir] ifFalse:[penalADecidir ganaArquero ]! !
!ArqueroElige methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 21:26:30' prior: 50543105!
defiendePlayeraAMatarEnDireccion: direccionArquero  delPenal: penalADecidir
	fuerzaBase := fuerzaBase *2 .
	penalADecidir esAtajadoConFuerza: fuerzaBase.

((penalADecidir direccionValidaParaTiro: penalADecidir varDireccionRemateResultante )and:[(penalADecidir varDireccionRemateResultante y = direccionArquero y) ]) ifTrue:[self defiendeConFuerza: penalADecidir  varFuerzaResultanteDeAtajada delDelantero: penalADecidir varFuerzaResultanteDeTiro paraPenal: penalADecidir] ifFalse:[penalADecidir ganaArquero ]! !

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 21:26:35'!
PASSED!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 21:26:37'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 21:26:38'!
FAILURE!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 21:26:38'!
FAILURE!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 21:26:38'!
PASSED!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 21:26:38'!
PASSED!
!ArqueroElige methodsFor: 'as yet unclassified' stamp: 'I 4/27/2024 21:31:18' prior: 50543122!
defiendePlayeraAMatarEnDireccion: direccionArquero  delPenal: penalADecidir
	fuerzaBase := fuerzaBase *2 .
	penalADecidir esAtajadoConFuerza: fuerzaBase.

((penalADecidir direccionValidaParaTiro: penalADecidir varDireccionRemateResultante )) ifTrue:[(penalADecidir varDireccionRemateResultante y = direccionArquero y)  ifTrue:[self defiendeConFuerza: penalADecidir  varFuerzaResultanteDeAtajada delDelantero: penalADecidir varFuerzaResultanteDeTiro paraPenal: penalADecidir]ifFalse:[penalADecidir ganaDelantero]] ifFalse:[penalADecidir ganaArquero ]! !

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 21:31:21'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 21:31:23'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 21:32:19'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'I 4/27/2024 21:47:36'!
PASSED!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'I 4/27/2024 21:47:36'!
PASSED!

----SNAPSHOT----(28 April 2024 01:45:11) CuisUniversity-6169.image priorSource: 6647428!

----QUIT----(28 April 2024 01:45:22) CuisUniversity-6169.image priorSource: 6790398!

----STARTUP---- (28 April 2024 12:23:02) as /home/ivan/Documents/Facu/Inge 1/linux64/linux64/CuisUniversity-6169.image!


----End fileIn of /home/ivan/Downloads/ISW1-2023-1C-Parcial-1-SinScanNiEsnnn.st----!

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'I 4/28/2024 12:34:13'!
PASSED!

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'I 4/28/2024 12:34:13'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'I 4/28/2024 12:34:13'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'I 4/28/2024 12:34:13'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'I 4/28/2024 12:34:13'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'I 4/28/2024 12:34:13'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'I 4/28/2024 12:34:13'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'I 4/28/2024 12:34:13'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'I 4/28/2024 12:34:13'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'I 4/28/2024 12:34:13'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'I 4/28/2024 12:34:13'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'I 4/28/2024 12:34:13'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'I 4/28/2024 12:34:13'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'I 4/28/2024 12:34:13'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'I 4/28/2024 12:34:13'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'I 4/28/2024 12:34:13'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'I 4/28/2024 12:34:13'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'I 4/28/2024 12:34:13'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'I 4/28/2024 12:34:13'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'I 4/28/2024 12:34:13'!
PASSED!

!testRun: #TestDePerforación #test20NoSePuedeDarGolpeConMechaRota stamp: 'I 4/28/2024 12:34:13'!
PASSED!

!testRun: #TestDePerforación #test21NoHabarCapasDelMismoTipoSeguidas stamp: 'I 4/28/2024 12:34:13'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'I 4/28/2024 12:34:17'!
PASSED!

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'I 4/28/2024 12:34:17'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'I 4/28/2024 12:34:17'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'I 4/28/2024 12:34:17'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'I 4/28/2024 12:34:17'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'I 4/28/2024 12:34:17'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'I 4/28/2024 12:34:17'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'I 4/28/2024 12:34:17'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'I 4/28/2024 12:34:17'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'I 4/28/2024 12:34:17'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'I 4/28/2024 12:34:17'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'I 4/28/2024 12:34:17'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'I 4/28/2024 12:34:17'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'I 4/28/2024 12:34:17'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'I 4/28/2024 12:34:17'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'I 4/28/2024 12:34:17'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'I 4/28/2024 12:34:17'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'I 4/28/2024 12:34:17'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'I 4/28/2024 12:34:17'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'I 4/28/2024 12:34:17'!
PASSED!

!testRun: #TestDePerforación #test20NoSePuedeDarGolpeConMechaRota stamp: 'I 4/28/2024 12:34:17'!
PASSED!

!testRun: #TestDePerforación #test21NoHabarCapasDelMismoTipoSeguidas stamp: 'I 4/28/2024 12:34:17'!
PASSED!

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'I 4/28/2024 12:34:23'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'I 4/28/2024 12:34:23'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'I 4/28/2024 12:34:23'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'I 4/28/2024 12:34:23'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'I 4/28/2024 12:34:23'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'I 4/28/2024 12:34:23'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'I 4/28/2024 12:34:23'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'I 4/28/2024 12:34:23'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'I 4/28/2024 12:34:23'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'I 4/28/2024 12:34:23'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'I 4/28/2024 12:34:23'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'I 4/28/2024 12:34:23'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'I 4/28/2024 12:34:23'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'I 4/28/2024 12:34:23'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'I 4/28/2024 12:34:23'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'I 4/28/2024 12:34:23'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'I 4/28/2024 12:34:23'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'I 4/28/2024 12:34:23'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'I 4/28/2024 12:34:23'!
PASSED!

!testRun: #TestDePerforación #test20NoSePuedeDarGolpeConMechaRota stamp: 'I 4/28/2024 12:34:23'!
PASSED!

!testRun: #TestDePerforación #test21NoHabarCapasDelMismoTipoSeguidas stamp: 'I 4/28/2024 12:34:23'!
PASSED!

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'I 4/28/2024 12:36:51'!
PASSED!

Object subclass: #EstadoMecha
	instanceVariableNames: 'mecha'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #EstadoMecha category: #'ISW1-2023-1C-Parcial-1' stamp: 'I 4/28/2024 13:15:28'!
Object subclass: #EstadoMecha
	instanceVariableNames: 'mecha'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #Perforadora stamp: 'I 4/28/2024 13:34:28'!
Object subclass: #Perforadora
	instanceVariableNames: 'mechaPuesta vecesQueGolpeoCapaActual capasDeSueloDebajo container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #SinMecha stamp: 'I 4/28/2024 13:34:28'!
Mecha subclass: #SinMecha
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #MechaRota stamp: 'I 4/28/2024 13:34:29'!
Mecha subclass: #MechaRota
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #MechaSoft stamp: 'I 4/28/2024 13:34:29'!
MechaFuncional subclass: #MechaSoft
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #MechaDeWidia stamp: 'I 4/28/2024 13:34:29'!
MechaFuncional subclass: #MechaDeWidia
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #MechaDeDiamante stamp: 'I 4/28/2024 13:34:29'!
MechaFuncional subclass: #MechaDeDiamante
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #MechaFuncional stamp: 'I 4/28/2024 13:34:30'!
Mecha subclass: #MechaFuncional
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #Mecha stamp: 'I 4/28/2024 13:34:30'!
Object subclass: #Mecha
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #EstadoMecha stamp: 'I 4/28/2024 13:34:30'!
Object subclass: #EstadoMecha
	instanceVariableNames: 'mecha'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #CapaDeTierra stamp: 'I 4/28/2024 13:34:31'!
CapaDeSueloPeforable subclass: #CapaDeTierra
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #CapaDeConcreto stamp: 'I 4/28/2024 13:34:31'!
CapaDeSueloPeforable subclass: #CapaDeConcreto
	instanceVariableNames: 'resistencia'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #CapaArenosa stamp: 'I 4/28/2024 13:34:31'!
CapaDeSueloPeforable subclass: #CapaArenosa
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #CapaDeSueloPeforable stamp: 'I 4/28/2024 13:34:31'!
CapaDeSuelo subclass: #CapaDeSueloPeforable
	instanceVariableNames: 'altura'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #CapaConPiedras stamp: 'I 4/28/2024 13:34:32'!
CapaDeSuelo subclass: #CapaConPiedras
	instanceVariableNames: 'piedras'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #CapaDeSuelo stamp: 'I 4/28/2024 13:34:32'!
Object subclass: #CapaDeSuelo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #TestDePerforación stamp: 'I 4/28/2024 13:34:32'!
TestCase subclass: #TestDePerforación
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

----End fileIn of /home/ivan/Downloads/ISW1-2022-2C-1erParcial.st----!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'I 4/28/2024 13:35:06'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'I 4/28/2024 13:35:06'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'I 4/28/2024 13:35:06'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'I 4/28/2024 13:35:06'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'I 4/28/2024 13:35:06'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'I 4/28/2024 13:35:06'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'I 4/28/2024 13:35:06'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'I 4/28/2024 13:35:06'!
PASSED!

Pirate subclass: #SimplePirate
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #SimplePirate category: #'ISW1-2022-2C-1erParcial' stamp: 'I 4/28/2024 13:49:00'!
Pirate subclass: #SimplePirate
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Pirate subclass: #Captain
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Captain category: #'ISW1-2022-2C-1erParcial' stamp: 'I 4/28/2024 13:49:09'!
Pirate subclass: #Captain
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!
!Bucanero methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 13:49:45' prior: 50545451!
aCaptainIWasMeantToBe

	rank := Captain new.! !
!Bucanero methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 13:49:56' prior: 50545456 overrides: 16932297!
initialize

	rank := SimplePirate new.! !
!Bucanero methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 13:51:17' prior: 50545460!
searchTreasureIn: island with: aMap

	rank = #SimplePirate ifTrue: [ self error: 'I am a simple pirate!!' ].
	rank = #Captain ifTrue: [ ^ true "Aye, Aye!! La implementación está fuera del scope del parcial." ].
	! !
!Corsario methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 13:51:32' prior: 50545496!
aCaptainIWasMeantToBe

	rank := Captain new! !
!Corsario methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 13:51:46' prior: 50545516!
initializeWith: aMap

	rank := SimplePirate new.
	map := aMap! !
!Filibustero methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 13:52:03' prior: 50545652!
aCaptainIWasMeantToBe

	rank := Captain new! !
!Filibustero methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 13:52:09' prior: 50545657 overrides: 16932297!
initialize

	rank := SimplePirate new.! !
!Crew methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 13:58:06' prior: 50545591!
moveTo: aPosition

	| acc ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.
	ix := 1.
	
	[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		pirate removeTerrain: terrain withBoolValue: acc.
		
		(pirate isKindOf: Corsario) ifTrue: [ 
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ 
				pirate drawDirectionTo: aPosition.
				acc := acc & true 
			].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [ 
				island clearTerrainAt: aPosition.
				acc := acc & false
			].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		ix := ix + 1.
	].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !
!Bucanero methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 13:58:42'!
removeTerrain: terrain withBoolValue: acc! !
!Crew methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 14:25:13' prior: 50545927!
moveTo: aPosition

	| acc ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.
	ix := 1.
	
	[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		pirate removeTerrain: terrain inIland:  island withBoolValue: acc.
		
		(pirate isKindOf: Corsario) ifTrue: [ 
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ 
				pirate drawDirectionTo: aPosition.
				acc := acc & true 
			].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [ 
				island clearTerrainAt: aPosition.
				acc := acc & false
			].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		ix := ix + 1.
	].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !
!Bucanero methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 14:25:49'!
removeTerrain: terrain inIland:  island withBoolValue: aBoolean

	! !

Island subclass: #Tree
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Tree category: #'ISW1-2022-2C-1erParcial' stamp: 'I 4/28/2024 14:52:44'!
Island subclass: #Tree
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Island subclass: #Diggable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Diggable category: #'ISW1-2022-2C-1erParcial' stamp: 'I 4/28/2024 14:52:51'!
Island subclass: #Diggable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Island subclass: #Empty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Empty category: #'ISW1-2022-2C-1erParcial' stamp: 'I 4/28/2024 14:52:56'!
Island subclass: #Empty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!
!Bucanero methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 14:57:28'!
removeTerrain: terrain inIsland:  island withBoolValue: aBoolean
	

	! !
!Crew methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 14:57:32' prior: 50545968!
moveTo: aPosition

	| acc ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.
	ix := 1.
	
	[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		pirate removeTerrain: terrain inIsland:  island withBoolValue: acc.
		
		(pirate isKindOf: Corsario) ifTrue: [ 
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ 
				pirate drawDirectionTo: aPosition.
				acc := acc & true 
			].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [ 
				island clearTerrainAt: aPosition.
				acc := acc & false
			].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		ix := ix + 1.
	].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !

!methodRemoval: Bucanero #removeTerrain:inIland:withBoolValue: stamp: 'I 4/28/2024 14:57:36'!
removeTerrain: terrain inIland:  island withBoolValue: aBoolean

	!
!Crew methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 14:58:44' prior: 50546048!
moveTo: aPosition

	| acc ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.
	ix := 1.
	
	[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		acc := acc & pirate removeTerrain: terrain inIsland: island .
		
		(pirate isKindOf: Corsario) ifTrue: [ 
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ 
				pirate drawDirectionTo: aPosition.
				acc := acc & true 
			].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [ 
				island clearTerrainAt: aPosition.
				acc := acc & false
			].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		ix := ix + 1.
	].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !
!Bucanero methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 14:58:46'!
removeTerrain: terrain inIsland:  island 
	island

	! !

!methodRemoval: Bucanero #removeTerrain:inIsland:withBoolValue: stamp: 'I 4/28/2024 14:58:49'!
removeTerrain: terrain inIsland:  island withBoolValue: aBoolean
	

	!

!methodRemoval: Bucanero #removeTerrain:withBoolValue: stamp: 'I 4/28/2024 14:58:57'!
removeTerrain: terrain withBoolValue: acc!
!Bucanero methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 14:59:51'!
removeTerrain: terrain 
	

	! !
!Crew methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 14:59:55' prior: 50546090!
moveTo: aPosition

	| acc ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.
	ix := 1.
	
	[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		acc := acc & pirate removeTerrain: terrain .
		
		(pirate isKindOf: Corsario) ifTrue: [ 
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ 
				pirate drawDirectionTo: aPosition.
				acc := acc & true 
			].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [ 
				island clearTerrainAt: aPosition.
				acc := acc & false
			].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		ix := ix + 1.
	].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !

!methodRemoval: Bucanero #removeTerrain:inIsland: stamp: 'I 4/28/2024 14:59:57'!
removeTerrain: terrain inIsland:  island 
	island

	!
!Island methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 15:01:13' prior: 50545723!
terrainAt: aPosition

	| ix |
	
	ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(aPosition = pos) ifTrue: [ ^ Tree new ].		
		ix := ix + 1.
	].

	ix := 1.
	[ix <= digsAt size] whileTrue: [ | pos |
		pos := digsAt at: ix.
		(aPosition = pos) ifTrue: [ ^ Diggable new ].
		ix := ix + 1.
	].

	^ Empty new.
	
! !
!Bucanero methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 15:04:54' prior: 50546140!
removeTerrain: terrain 
	^terrain esRemovidoPorPirataBucanero: self

	! !
!Crew methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 15:05:52' prior: 50546144!
moveTo: aPosition

	| acc ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.
	ix := 1.
	
	[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		acc := acc & pirate removeTerrain: terrain inLocation: aPosition .
		
		(pirate isKindOf: Corsario) ifTrue: [ 
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ 
				pirate drawDirectionTo: aPosition.
				acc := acc & true 
			].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [ 
				island clearTerrainAt: aPosition.
				acc := acc & false
			].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		ix := ix + 1.
	].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !
!Bucanero methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 15:06:09'!
removeTerrain: terrain inLocation: aPosition 
	^terrain esRemovidoPorPirataBucanero: self InLocation: aPosition

	! !
!Tree methodsFor: 'no messages' stamp: 'I 4/28/2024 15:07:10'!
esRemovidoPorPirataBucanero: pirate InLocation: aPosition
	^false! !
!Empty methodsFor: 'no messages' stamp: 'I 4/28/2024 15:07:35'!
esRemovidoPorPirataBucanero: pirate InLocation: aPosition
	^true.! !
!Diggable methodsFor: 'nil' stamp: 'I 4/28/2024 15:07:43'!
esRemovidoPorPirataBucanero: pirate InLocation: aPosition
	^true.! !
!Diggable methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 15:08:06'!
esRemovidoPorPirataFilibustero: pirate InLocation: aPosition
	^true.! !
!Diggable methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 15:08:21'!
esRemovidoPorPirataCorsario: pirate InLocation: aPosition
	^true.! !
!Empty methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 15:08:43'!
esRemovidoPorPirataFilibustero: pirate InLocation: aPosition
	^true.! !
!Empty methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 15:08:53'!
esRemovidoPorPirataCorsario: pirate InLocation: aPosition
	^true.! !
!Tree methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 15:09:51'!
esRemovidoPorPirataFilibustero: pirate InLocation: aPosition
	self clearTerrainAt: aPosition.
	^false.! !
!Tree methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 15:10:10'!
esRemovidoPorPirataCorsario: pirate InLocation: aPosition

	^false.! !
!Empty methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 15:10:49' prior: 50546275!
esRemovidoPorPirataCorsario: pirate InLocation: aPosition
	self drawDirectionTo: aPosition.
	^true.! !
!Crew methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 15:11:19' prior: 50546204!
moveTo: aPosition

	| acc ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.
	ix := 1.
	
	[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		acc := acc & pirate removeTerrain: terrain inLocation: aPosition.
		ix := ix + 1.
	].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'I 4/28/2024 15:11:23'!
ERROR!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'I 4/28/2024 15:11:23'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'I 4/28/2024 15:11:23'!
ERROR!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'I 4/28/2024 15:11:23'!
ERROR!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'I 4/28/2024 15:11:23'!
ERROR!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'I 4/28/2024 15:11:23'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'I 4/28/2024 15:11:23'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'I 4/28/2024 15:11:23'!
ERROR!
!Crew methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 15:05:52' prior: 50546297!
moveTo: aPosition

	| acc ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.
	ix := 1.
	
	[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		acc := acc & pirate removeTerrain: terrain inLocation: aPosition .
		
		(pirate isKindOf: Corsario) ifTrue: [ 
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ 
				pirate drawDirectionTo: aPosition.
				acc := acc & true 
			].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [ 
				island clearTerrainAt: aPosition.
				acc := acc & false
			].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		ix := ix + 1.
	].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !
!Crew methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 15:13:06' prior: 50546336!
moveTo: aPosition

	| acc ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.
	ix := 1.
	
	[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		"acc := acc & pirate removeTerrain: terrain inLocation: aPosition ."
		
		(pirate isKindOf: Corsario) ifTrue: [ 
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ 
				pirate drawDirectionTo: aPosition.
				acc := acc & true 
			].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [ 
				island clearTerrainAt: aPosition.
				acc := acc & false
			].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		ix := ix + 1.
	].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'I 4/28/2024 15:13:07'!
FAILURE!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'I 4/28/2024 15:13:07'!
FAILURE!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'I 4/28/2024 15:13:07'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'I 4/28/2024 15:13:07'!
FAILURE!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'I 4/28/2024 15:13:07'!
FAILURE!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'I 4/28/2024 15:13:07'!
FAILURE!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'I 4/28/2024 15:13:07'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'I 4/28/2024 15:13:07'!
FAILURE!
!Crew methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 15:13:22' prior: 50546373!
moveTo: aPosition

	| acc ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.
	ix := 1.
	
	[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		acc := acc & pirate removeTerrain: terrain inLocation: aPosition.
		"
		(pirate isKindOf: Corsario) ifTrue: [ 
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ 
				pirate drawDirectionTo: aPosition.
				acc := acc & true 
			].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [ 
				island clearTerrainAt: aPosition.
				acc := acc & false
			].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		"
		ix := ix + 1.
	].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !
!Bucanero methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 15:15:05' prior: 50545896!
searchTreasureIn: island with: aMap
	rank searchTreasureIn: island with: aMap. 
	rank = #SimplePirate ifTrue: [ self error: 'I am a simple pirate!!' ].
	rank = #Captain ifTrue: [ ^ true "Aye, Aye!! La implementación está fuera del scope del parcial." ].
	! !
!Captain methodsFor: 'no messages' stamp: 'I 4/28/2024 15:15:25'!
searchTreasureIn: island with: aMap. 
	^ true "Aye, Aye!! La implementación está fuera del scope del parcial." ! !
!Captain methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 15:15:34' prior: 50546483!
searchTreasureIn: island with: aMap
	^ true "Aye, Aye!! La implementación está fuera del scope del parcial." ! !
!SimplePirate methodsFor: 'nil' stamp: 'I 4/28/2024 15:15:53'!
searchTreasureIn: island with: aMap
	self error: 'I am a simple pirate!!'.! !
!Bucanero methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 15:16:06' prior: 50546472!
searchTreasureIn: island with: aMap
	rank searchTreasureIn: island with: aMap. 
	! !
!Corsario methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 15:16:15' prior: 50545521!
searchTreasureIn: island with: aMap

	rank searchTreasureIn: island with: aMap. ! !
!Filibustero methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 15:16:24' prior: 50545661!
searchTreasureIn: island with: aMap

	rank searchTreasureIn: island with: aMap. 
	! !
!Corsario methodsFor: 'nil' stamp: 'I 4/28/2024 15:17:31'!
removeTerrain: terrain inLocation: aPosition 
	^terrain esRemovidoPorPirataBucanero: self InLocation: aPosition

	! !
!Filibustero methodsFor: 'nil' stamp: 'I 4/28/2024 15:17:35'!
removeTerrain: terrain inLocation: aPosition 
	^terrain esRemovidoPorPirataBucanero: self InLocation: aPosition

	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'I 4/28/2024 15:17:39'!
ERROR!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'I 4/28/2024 15:17:39'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'I 4/28/2024 15:17:39'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'I 4/28/2024 15:17:39'!
FAILURE!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'I 4/28/2024 15:17:39'!
FAILURE!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'I 4/28/2024 15:17:39'!
FAILURE!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'I 4/28/2024 15:17:39'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'I 4/28/2024 15:17:39'!
PASSED!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'I 4/28/2024 15:17:44'!
ERROR!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'I 4/28/2024 15:17:44'!
ERROR!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'I 4/28/2024 15:19:14'!
ERROR!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'I 4/28/2024 15:19:28'!
ERROR!
!Filibustero methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 15:20:06' prior: 50546525!
removeTerrain: terrain inLocation: aPosition 
	^terrain esRemovidoPorPirataBucanero: self InLocation: aPosition

	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'I 4/28/2024 15:20:19'!
ERROR!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'I 4/28/2024 15:21:55'!
ERROR!
!Filibustero methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 15:23:08'!
removeTerrain: terrain inLocation: aPosition withBooleanValue: aBoolean
	^terrain esRemovidoPorPirataBucanero: self InLocation: aPosition

	! !

!methodRemoval: Filibustero #removeTerrain:inLocation:withBooleanValue: stamp: 'I 4/28/2024 15:24:17'!
removeTerrain: terrain inLocation: aPosition withBooleanValue: aBoolean
	^terrain esRemovidoPorPirataBucanero: self InLocation: aPosition

	!
!Island methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 15:29:29' prior: 50546184!
terrainAt: aPosition

	| ix |
	
	ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(aPosition = pos) ifTrue: [ ^#Tree  ].		
		ix := ix + 1.
	].

	ix := 1.
	[ix <= digsAt size] whileTrue: [ | pos |
		pos := digsAt at: ix.
		(aPosition = pos) ifTrue: [ ^#Diggable ].
		ix := ix + 1.
	].

	^#Empty .
	
! !

!classRemoval: #Empty stamp: 'I 4/28/2024 15:29:36'!
Island subclass: #Empty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Diggable stamp: 'I 4/28/2024 15:29:54'!
Island subclass: #Diggable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Tree stamp: 'I 4/28/2024 15:29:57'!
Island subclass: #Tree
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Object subclass: #Terrain
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Terrain category: #'ISW1-2022-2C-1erParcial' stamp: 'I 4/28/2024 15:30:03'!
Object subclass: #Terrain
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Terrain subclass: #Tree
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Tree category: #'ISW1-2022-2C-1erParcial' stamp: 'I 4/28/2024 15:30:14'!
Terrain subclass: #Tree
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Terrain subclass: #Diggable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Diggable category: #'ISW1-2022-2C-1erParcial' stamp: 'I 4/28/2024 15:30:17'!
Terrain subclass: #Diggable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Terrain subclass: #Empty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Empty category: #'ISW1-2022-2C-1erParcial' stamp: 'I 4/28/2024 15:30:22'!
Terrain subclass: #Empty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!
!Island methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 15:41:46' prior: 50546598!
terrainAt: aPosition

	| ix |
	
	ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(aPosition = pos) ifTrue: [ ^Tree new  ].		
		ix := ix + 1.
	].

	ix := 1.
	[ix <= digsAt size] whileTrue: [ | pos |
		pos := digsAt at: ix.
		(aPosition = pos) ifTrue: [ ^Diggable new ].
		ix := ix + 1.
	].

	^Empty new.
	
! !
!Crew methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 15:42:53' prior: 50546435!
moveTo: aPosition

	| acc ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.
	ix := 1.
	
	[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		acc := acc & pirate removeTerrain: terrain inIsland: island inLocation: aPosition.
		"
		(pirate isKindOf: Corsario) ifTrue: [ 
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ 
				pirate drawDirectionTo: aPosition.
				acc := acc & true 
			].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [ 
				island clearTerrainAt: aPosition.
				acc := acc & false
			].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		"
		ix := ix + 1.
	].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !

!methodRemoval: Bucanero #removeTerrain:inLocation: stamp: 'I 4/28/2024 15:43:06'!
removeTerrain: terrain inLocation: aPosition 
	^terrain esRemovidoPorPirataBucanero: self InLocation: aPosition

	!

!methodRemoval: Bucanero #removeTerrain: stamp: 'I 4/28/2024 15:43:09'!
removeTerrain: terrain 
	^terrain esRemovidoPorPirataBucanero: self

	!
!Bucanero methodsFor: 'nil' stamp: 'I 4/28/2024 15:44:09'!
removeTerrain: terrain inIsland: island inLocation: aPosition
	^terrain isRemoveByBucanero: self inIsland: island inLocation: aPosition! !
!Terrain methodsFor: 'nil' stamp: 'I 4/28/2024 15:45:27'!
isRemoveByBucanero: aBucanero inIsland: island inLocation: aPosition
	^self subclassResponsibility.
	! !
!Tree methodsFor: 'nil' stamp: 'I 4/28/2024 15:46:00' overrides: 50546744!
isRemoveByBucanero: aBucanero inIsland: island inLocation: aPosition
	^false! !
!Tree methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 15:47:39'!
isRemoveByFilibustero: aFilibustero inIsland: island inLocation: aPosition
	^false! !
!Tree methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 15:48:01' prior: 50546755!
isRemoveByFilibustero: aFilibustero inIsland: island inLocation: aPosition
	island clearTerrainAt: aPosition.
	^false! !
!Tree methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 15:48:41'!
isRemoveByCorsario: aCorsario inIsland: island inLocation: aPosition

	^false! !
!Empty methodsFor: 'nil' stamp: 'I 4/28/2024 15:50:09' overrides: 50546744!
isRemoveByBucanero: aBucanero inIsland: island inLocation: aPosition
	^true.! !
!Empty methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 15:50:24'!
isRemoveByFilibustero: aFilibustero inIsland: island inLocation: aPosition
	^true.! !
!Empty methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:07:19' prior: 50546777!
isRemoveByFilibustero: aFilibusteri inIsland: island inLocation: aPosition
	^true.! !
!Empty methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:07:52'!
isRemoveByCorsario: aCorsario inIsland: island inLocation: aPosition
	aCorsario drawDirectionTo: aPosition.
	^true.! !
!Diggable methodsFor: 'nil' stamp: 'I 4/28/2024 16:08:06' overrides: 50546744!
isRemoveByBucanero: aBucanero inIsland: island inLocation: aPosition
	^true.! !
!Diggable methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:08:47'!
isRemoveByFilibustero: aFilibustero inIsland: island inLocation: aPosition
	^true.! !
!Diggable methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:09:04'!
isRemoveByCorsario: aCorsario inIsland: island inLocation: aPosition
	^true.! !
!Terrain methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:09:22'!
isRemoveByCorsario: aCorsario inIsland: island inLocation: aPosition
	^self subclassResponsibility.
	! !
!Terrain methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:09:35'!
isRemoveByFilibustero: aFilibustero inIsland: island inLocation: aPosition
	^self subclassResponsibility.
	! !
!Crew methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:12:31' prior: 50546690!
moveTo: aPosition

	| acc ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.
	ix := 1.
	
	[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		acc := acc & pirate canMoveTo: aPosition in: terrain at: island.
		"
		(pirate isKindOf: Corsario) ifTrue: [ 
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ 
				pirate drawDirectionTo: aPosition.
				acc := acc & true 
			].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [ 
				island clearTerrainAt: aPosition.
				acc := acc & false
			].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		"
		ix := ix + 1.
	].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !
!Bucanero methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:12:41'!
canMoveTo: aPosition in: terrain at: island
	^terrain isRemoveByBucanero: self inIsland: island inLocation: aPosition! !

!methodRemoval: Bucanero #removeTerrain:inIsland:inLocation: stamp: 'I 4/28/2024 16:12:43'!
removeTerrain: terrain inIsland: island inLocation: aPosition
	^terrain isRemoveByBucanero: self inIsland: island inLocation: aPosition!
!Corsario methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:13:29'!
canMoveTo: aPosition in: terrain at: island
	^terrain isRemoveByCorsario: self inIsland: island inLocation: aPosition

	! !
!Filibustero methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:13:37'!
canMoveTo: aPosition in: terrain at: island
	^terrain isRemoveByCorsario: self inIsland: island inLocation: aPosition

	! !

!methodRemoval: Filibustero #removeTerrain:inLocation: stamp: 'I 4/28/2024 16:13:39'!
removeTerrain: terrain inLocation: aPosition 
	^terrain esRemovidoPorPirataBucanero: self InLocation: aPosition

	!
!Filibustero methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:13:46' prior: 50546881!
canMoveTo: aPosition in: terrain at: island
	^terrain isRemoveByFilibustero: self inIsland: island inLocation: aPosition

	! !
!Crew methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:14:58' prior: 50546824!
moveTo: aPosition

	| acc ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.
	ix := 1.
	
	[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		acc := acc & (pirate canMoveTo: aPosition in: terrain at: island).
		"
		(pirate isKindOf: Corsario) ifTrue: [ 
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ 
				pirate drawDirectionTo: aPosition.
				acc := acc & true 
			].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [ 
				island clearTerrainAt: aPosition.
				acc := acc & false
			].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		"
		ix := ix + 1.
	].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'I 4/28/2024 16:15:14'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'I 4/28/2024 16:15:15'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'I 4/28/2024 16:15:17'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'I 4/28/2024 16:15:18'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'I 4/28/2024 16:15:19'!
FAILURE!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'I 4/28/2024 16:15:19'!
FAILURE!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'I 4/28/2024 16:15:25'!
FAILURE!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'I 4/28/2024 16:15:25'!
FAILURE!
!Crew methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:19:06' prior: 50546902!
moveTo: aPosition

	| moved terrain |
	
	terrain := island terrainAt: aPosition.
	
	moved := pirates inject: true into: [ :canMove :pirate | canMove & (pirate canMoveTo: aPosition in: terrain at: island )	].
		"
		(pirate isKindOf: Corsario) ifTrue: [ 
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ 
				pirate drawDirectionTo: aPosition.
				acc := acc & true 
			].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [ 
				island clearTerrainAt: aPosition.
				acc := acc & false
			].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		"
	"nos movemos si todos pueden moverse"
	moved ifTrue: [ island crewAt: aPosition ].
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'I 4/28/2024 16:19:09'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'I 4/28/2024 16:19:26'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'I 4/28/2024 16:19:27'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'I 4/28/2024 16:19:27'!
ERROR!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'I 4/28/2024 16:19:30'!
FAILURE!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'I 4/28/2024 16:19:30'!
FAILURE!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'I 4/28/2024 16:19:34'!
PASSED!
!Island methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:23:28' prior: 50546676!
terrainAt: aPosition

	| ix |
	self searchInColection: treesAt isSatisfyThePosition: aPosition withClosureValue: [^Tree new].
	ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(aPosition = pos) ifTrue: [ ^Tree new  ].		
		ix := ix + 1.
	].

	ix := 1.
	[ix <= digsAt size] whileTrue: [ | pos |
		pos := digsAt at: ix.
		(aPosition = pos) ifTrue: [ ^Diggable new ].
		ix := ix + 1.
	].

	^Empty new.
	
! !
!Island methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:24:01' prior: 50547021!
terrainAt: aPosition

	| ix |
	self searchInColection: treesAt ifSatisfyThePosition: aPosition withClosureValue: [^Tree new].
	ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(aPosition = pos) ifTrue: [ ^Tree new  ].		
		ix := ix + 1.
	].

	ix := 1.
	[ix <= digsAt size] whileTrue: [ | pos |
		pos := digsAt at: ix.
		(aPosition = pos) ifTrue: [ ^Diggable new ].
		ix := ix + 1.
	].

	^Empty new.
	
! !
!Island methodsFor: 'nil' stamp: 'I 4/28/2024 16:24:11'!
searchInColection: aCollectionToSerach ifSatisfyThePosition: aPosition withClosureValue: aBlockToValue
	! !
!Island methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:26:46' prior: 50547054!
searchInColection: aCollectionToSearch ifSatisfyThePosition: aPosition withClosureValue: aBlockToValue
	| index |
	index := 1.
	[index <= aCollectionToSearch size] whileTrue:[|pos|
		pos := aCollectionToSearch at: index.
		(pos = aPosition) ifTrue: aBlockToValue.
		index := index + 1.
		].! !
!Island methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:26:53' prior: 50547061!
searchInColection: aCollectionToSearch ifSatisfyThePosition: aPosition withClosureValue: aBlockToValue
	| index |
	index := 1.
	[index <= aCollectionToSearch size] whileTrue:[|pos|
		pos := aCollectionToSearch at: index.
		(pos = aPosition) ifTrue: aBlockToValue.
		index := index + 1.
	].! !
!Island methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:27:34' prior: 50547038!
terrainAt: aPosition

	| ix |
	self searchInColection: treesAt ifSatisfyThePosition: aPosition withClosureValue: [^Tree new].
	"ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(aPosition = pos) ifTrue: [ ^Tree new  ].		
		ix := ix + 1.
	].

	ix := 1.
	[ix <= digsAt size] whileTrue: [ | pos |
		pos := digsAt at: ix.
		(aPosition = pos) ifTrue: [ ^Diggable new ].
		ix := ix + 1.
	]."
	self searchInColection: digsAt ifSatisfyThePosition: aPosition withClosureValue: [^Diggable new].

	^Empty new.
	
! !
!Island methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:27:39' prior: 50547085!
terrainAt: aPosition


	self searchInColection: treesAt ifSatisfyThePosition: aPosition withClosureValue: [^Tree new].
	"ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(aPosition = pos) ifTrue: [ ^Tree new  ].		
		ix := ix + 1.
	].

	ix := 1.
	[ix <= digsAt size] whileTrue: [ | pos |
		pos := digsAt at: ix.
		(aPosition = pos) ifTrue: [ ^Diggable new ].
		ix := ix + 1.
	]."
	self searchInColection: digsAt ifSatisfyThePosition: aPosition withClosureValue: [^Diggable new].

	^Empty new.
	
! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'I 4/28/2024 16:27:47'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'I 4/28/2024 16:27:49'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'I 4/28/2024 16:27:50'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'I 4/28/2024 16:27:51'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'I 4/28/2024 16:27:51'!
ERROR!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'I 4/28/2024 16:27:54'!
FAILURE!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'I 4/28/2024 16:27:54'!
FAILURE!
!Island methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:33:47' prior: 50545709!
isEmptyAt: aPosition

	self searchInColection: treesAt ifSatisfyThePosition: aPosition withClosureValue: [^false].

	^ true! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'I 4/28/2024 16:33:51'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'I 4/28/2024 16:33:53'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'I 4/28/2024 16:33:54'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'I 4/28/2024 16:33:56'!
PASSED!
!Island methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:34:02' prior: 50547105!
terrainAt: aPosition


	self searchInColection: treesAt ifSatisfyThePosition: aPosition withClosureValue: [^Tree new].
	
	self searchInColection: digsAt ifSatisfyThePosition: aPosition withClosureValue: [^Diggable new].

	^Empty new.
	
! !
!Crew methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:41:27' prior: 50545555!
buryTreasureAt: aPosition

	| ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	ix := 1.
	[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		pirates canBurySecretAt: aPosition in: terrain at:island.
		(pirate isKindOf: Corsario) ifTrue: [ 
			terrain = #Tree ifTrue: [].
			terrain = #Empty ifTrue: [].
			terrain = #Diggable ifTrue: [ 				pirate drawTreasureMarkAt: aPosition ].
		].
		
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [].
			terrain = #Empty ifTrue: [].
			terrain = #Diggable ifTrue: [].
		].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ self error: 'Arrgh!! I cannot dig this type of terrain!!' ].
			terrain = #Empty ifTrue: [ self error: 'Arrgh!! I cannot dig this type of terrain!!' ]	.
			terrain = #Diggable ifTrue: [ island receiveTreasureAt: aPosition ].
		].
		
		ix := ix + 1.
	].
	! !
!Bucanero methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:41:44'!
canBurySecretAt: aPosition in: terrain at:island
	^terrain isRemoveByBucanero: self inIsland: island inLocation: aPosition! !
!Bucanero methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:42:21' prior: 50547209!
canBurySecretAt: aPosition in: terrain at:island
	^terrain canBuryByBucanero: self inIsland: island inLocation: aPosition! !
!Corsario methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:42:45'!
canBurySecretAt: aPosition in: terrain at:island
	^terrain canBuryByBucanero: self inIsland: island inLocation: aPosition! !
!Corsario methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:42:52' prior: 50547223!
canBurySecretAt: aPosition in: terrain at:island
	^terrain canBuryByCorsario: self inIsland: island inLocation: aPosition! !
!Filibustero methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:43:08'!
canBurySecretAt: aPosition in: terrain at:island
	^terrain canBuryByFilibustero: self inIsland: island inLocation: aPosition! !
!Terrain methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:43:36'!
canBuryByFilibustero: aFilibustero inIsland: island inLocation: aPosition
	self subclassResponsibility! !
!Terrain methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:43:47'!
canBuryByBucanero: aBucanero inIsland: island inLocation: aPosition
	self subclassResponsibility! !
!Terrain methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:43:57'!
canBuryByCorsario: aCorsario inIsland: island inLocation: aPosition
	self subclassResponsibility! !
!Tree methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:44:08' overrides: 50547250!
canBuryByBucanero: aBucanero inIsland: island inLocation: aPosition
	self subclassResponsibility! !
!Diggable methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:44:08' overrides: 50547250!
canBuryByBucanero: aBucanero inIsland: island inLocation: aPosition
	self subclassResponsibility! !
!Empty methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:44:08' overrides: 50547250!
canBuryByBucanero: aBucanero inIsland: island inLocation: aPosition
	self subclassResponsibility! !
!Terrain methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:44:08' prior: 50547250!
canBuryByBucanero: aBucanero inIsland: island inLocation: aPosition

	self subclassResponsibility! !
!Tree methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:44:15' overrides: 50547256!
canBuryByCorsario: aCorsario inIsland: island inLocation: aPosition
	self subclassResponsibility! !
!Diggable methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:44:15' overrides: 50547256!
canBuryByCorsario: aCorsario inIsland: island inLocation: aPosition
	self subclassResponsibility! !
!Empty methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:44:15' overrides: 50547256!
canBuryByCorsario: aCorsario inIsland: island inLocation: aPosition
	self subclassResponsibility! !
!Terrain methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:44:15' prior: 50547256!
canBuryByCorsario: aCorsario inIsland: island inLocation: aPosition

	self subclassResponsibility! !
!Tree methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:44:21' overrides: 50547244!
canBuryByFilibustero: aFilibustero inIsland: island inLocation: aPosition
	self subclassResponsibility! !
!Diggable methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:44:21' overrides: 50547244!
canBuryByFilibustero: aFilibustero inIsland: island inLocation: aPosition
	self subclassResponsibility! !
!Empty methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:44:21' overrides: 50547244!
canBuryByFilibustero: aFilibustero inIsland: island inLocation: aPosition
	self subclassResponsibility! !
!Terrain methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:44:21' prior: 50547244!
canBuryByFilibustero: aFilibustero inIsland: island inLocation: aPosition

	self subclassResponsibility! !
!Tree methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:44:34' prior: 50547262 overrides: 50547281!
canBuryByBucanero: aBucanero inIsland: island inLocation: aPosition
	! !
!Tree methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:44:59' prior: 50547340 overrides: 50547281!
canBuryByBucanero: aBucanero inIsland: island inLocation: aPosition
	self error: 'Arrgh!! I cannot dig this type of terrain!!'! !
!Tree methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:45:12' prior: 50547287 overrides: 50547306!
canBuryByCorsario: aCorsario inIsland: island inLocation: aPosition
	! !
!Tree methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:45:16' prior: 50547312 overrides: 50547333!
canBuryByFilibustero: aFilibustero inIsland: island inLocation: aPosition
	! !
!Tree methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:45:21' prior: 50547360 overrides: 50547333!
canBuryByFilibustero: aFilibustero inIsland: island inLocation: aPosition
	! !
!Empty methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:45:35' prior: 50547275 overrides: 50547281!
canBuryByBucanero: aBucanero inIsland: island inLocation: aPosition
	self error: 'Arrgh!! I cannot dig this type of terrain!!'! !
!Empty methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:45:42' prior: 50547300 overrides: 50547306!
canBuryByCorsario: aCorsario inIsland: island inLocation: aPosition
! !
!Empty methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:45:46' prior: 50547326 overrides: 50547333!
canBuryByFilibustero: aFilibustero inIsland: island inLocation: aPosition
	! !
!Diggable methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:46:11' prior: 50547269 overrides: 50547281!
canBuryByBucanero: aBucanero inIsland: island inLocation: aPosition
	island receiveTreasureAt: aPosition! !
!Diggable methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:46:26' prior: 50547319 overrides: 50547333!
canBuryByFilibustero: aFilibustero inIsland: island inLocation: aPosition
	! !
!Diggable methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:46:44' prior: 50547294 overrides: 50547306!
canBuryByCorsario: aCorsario inIsland: island inLocation: aPosition
	aCorsario drawTreasureMarkAt: aPosition.! !

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'I 4/28/2024 16:46:48'!
ERROR!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'I 4/28/2024 16:46:48'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'I 4/28/2024 16:46:51'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'I 4/28/2024 16:46:51'!
ERROR!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'I 4/28/2024 16:46:55'!
PASSED!
!Crew methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:47:11' prior: 50547178!
buryTreasureAt: aPosition

	| ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	ix := 1.
	[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		pirates canBurySecretAt: aPosition in: terrain at:island.
		ix := ix + 1.
	].
	! !

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'I 4/28/2024 16:47:15'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'I 4/28/2024 16:47:17'!
ERROR!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'I 4/28/2024 16:47:17'!
ERROR!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'I 4/28/2024 16:47:42'!
ERROR!
!Crew methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:48:31' prior: 50547428!
buryTreasureAt: aPosition

	| ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	ix := 1.
	[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		pirate canBurySecretAt: aPosition in: terrain at:island.
		ix := ix + 1.
	].
	! !

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'I 4/28/2024 16:48:35'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'I 4/28/2024 16:48:36'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'I 4/28/2024 16:48:38'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'I 4/28/2024 16:48:38'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'I 4/28/2024 16:48:42'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'I 4/28/2024 16:48:43'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'I 4/28/2024 16:48:45'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'I 4/28/2024 16:48:46'!
PASSED!
!Bucanero methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:51:11' prior: 50546502!
searchTreasureIn: island with: aMap
	^rank searchTreasureIn: island with: aMap. 
	! !

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'I 4/28/2024 16:51:19'!
PASSED!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'I 4/28/2024 16:51:19'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'I 4/28/2024 16:51:19'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'I 4/28/2024 16:51:19'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'I 4/28/2024 16:51:19'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'I 4/28/2024 16:51:19'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'I 4/28/2024 16:51:19'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'I 4/28/2024 16:51:19'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'I 4/28/2024 16:51:19'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'I 4/28/2024 16:51:21'!
PASSED!
!Corsario methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:51:47' prior: 50546508!
searchTreasureIn: island with: aMap

	^rank searchTreasureIn: island with: aMap. ! !
!Filibustero methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:51:52' prior: 50546514!
searchTreasureIn: island with: aMap

	^rank searchTreasureIn: island with: aMap. 
	! !

!methodRemoval: Corsario #removeTerrain:inLocation: stamp: 'I 4/28/2024 16:52:01'!
removeTerrain: terrain inLocation: aPosition 
	^terrain esRemovidoPorPirataBucanero: self InLocation: aPosition

	!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'I 4/28/2024 16:52:10'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'I 4/28/2024 16:52:10'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'I 4/28/2024 16:52:10'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'I 4/28/2024 16:52:10'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'I 4/28/2024 16:52:10'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'I 4/28/2024 16:52:10'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'I 4/28/2024 16:52:10'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'I 4/28/2024 16:52:10'!
PASSED!
!Crew methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:52:45' prior: 50547453!
buryTreasureAt: aPosition

	| index terrain |
	
	terrain := island terrainAt: aPosition.
	
	index := 1.
	[index <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: index.
		pirate canBurySecretAt: aPosition in: terrain at:island.
		index := index + 1.
	].
	! !
!Crew methodsFor: 'as yet unclassified' stamp: 'I 4/28/2024 16:52:57' prior: 50546965!
moveTo: aPosition

	| moved terrain |
	
	terrain := island terrainAt: aPosition.
	
	moved := pirates inject: true into: [ :canMove :pirate | canMove & (pirate canMoveTo: aPosition in: terrain at: island )	].
		
	"nos movemos si todos pueden moverse"
	moved ifTrue: [ island crewAt: aPosition ].
	
	! !

----QUIT----(28 April 2024 16:53:52) CuisUniversity-6169.image priorSource: 6790488!

----STARTUP---- (29 April 2024 11:36:49) as /home/ivan/Documents/Facu/Inge 1/linux64/linux64/CuisUniversity-6169.image!


Pirate subclass: #Corsario
	instanceVariableNames: 'rank map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Corsario category: #'ISW1-2022-2C-1erParcial' stamp: 'I 4/29/2024 11:37:26'!
Pirate subclass: #Corsario
	instanceVariableNames: 'rank map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Object subclass: #PiraterRank
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #PiraterRank category: #'ISW1-2022-2C-1erParcial' stamp: 'I 4/29/2024 11:37:47'!
Object subclass: #PiraterRank
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Object subclass: #PirateRank
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #PirateRank category: #'ISW1-2022-2C-1erParcial' stamp: 'I 4/29/2024 11:38:05'!
Object subclass: #PirateRank
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #PiraterRank stamp: 'I 4/29/2024 11:38:07'!
Object subclass: #PiraterRank
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

PirateRank subclass: #Captain
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Captain category: #'ISW1-2022-2C-1erParcial' stamp: 'I 4/29/2024 11:38:12'!
PirateRank subclass: #Captain
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

PirateRank subclass: #SimplePirate
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #SimplePirate category: #'ISW1-2022-2C-1erParcial' stamp: 'I 4/29/2024 11:38:17'!
PirateRank subclass: #SimplePirate
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Pirate subclass: #Bucanero
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Bucanero category: #'ISW1-2022-2C-1erParcial' stamp: 'I 4/29/2024 11:38:24'!
Pirate subclass: #Bucanero
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Pirate subclass: #Filibustero
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Filibustero category: #'ISW1-2022-2C-1erParcial' stamp: 'I 4/29/2024 11:38:30'!
Pirate subclass: #Filibustero
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'I 4/29/2024 11:38:32'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'I 4/29/2024 11:38:32'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'I 4/29/2024 11:38:32'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'I 4/29/2024 11:38:32'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'I 4/29/2024 11:38:32'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'I 4/29/2024 11:38:32'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'I 4/29/2024 11:38:32'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'I 4/29/2024 11:38:32'!
PASSED!
!Pirate methodsFor: 'nil' stamp: 'I 4/29/2024 11:39:24' overrides: 16932297!
initialize

	! !

Pirate subclass: #Bucanero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Bucanero category: #'ISW1-2022-2C-1erParcial' stamp: 'I 4/29/2024 11:39:36'!
Pirate subclass: #Bucanero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Pirate subclass: #Corsario
	instanceVariableNames: 'map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Corsario category: #'ISW1-2022-2C-1erParcial' stamp: 'I 4/29/2024 11:39:40'!
Pirate subclass: #Corsario
	instanceVariableNames: 'map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Pirate subclass: #Filibustero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Filibustero category: #'ISW1-2022-2C-1erParcial' stamp: 'I 4/29/2024 11:39:44'!
Pirate subclass: #Filibustero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Object subclass: #Pirate
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Pirate category: #'ISW1-2022-2C-1erParcial' stamp: 'I 4/29/2024 11:39:48'!
Object subclass: #Pirate
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!
!Pirate methodsFor: 'as yet unclassified' stamp: 'I 4/29/2024 11:39:51' prior: 50547715 overrides: 16932297!
initialize

	rank := SimplePirate new! !
!Pirate methodsFor: 'as yet unclassified' stamp: 'I 4/29/2024 11:39:59'!
aCaptainIWasMeantToBe

	rank := Captain new! !
!Pirate methodsFor: 'as yet unclassified' stamp: 'I 4/29/2024 11:40:07'!
buryTreasureTo: aPosition in: terrain at: island 
	
	self subclassResponsibility! !
!Pirate methodsFor: 'as yet unclassified' stamp: 'I 4/29/2024 11:40:16'!
canMoveTo: aPosition in: terrain at: island 
	
	self subclassResponsibility! !
!Pirate methodsFor: 'as yet unclassified' stamp: 'I 4/29/2024 11:40:27'!
searchTreasureIn: island with: aMap

	^rank searchTreasureFor: self at: island with: aMap! !
!PirateRank methodsFor: 'nil' stamp: 'I 4/29/2024 11:40:54'!
searchTreasureIn: island with: aMap
	self subclassResponsibility! !
!PirateRank methodsFor: 'as yet unclassified' stamp: 'I 4/29/2024 11:41:31'!
searchTreasureFor: aPirate at: anIsland with: aMap 

	self subclassResponsibility
! !

!methodRemoval: PirateRank #searchTreasureIn:with: stamp: 'I 4/29/2024 11:41:36'!
searchTreasureIn: island with: aMap
	self subclassResponsibility!
!Captain methodsFor: 'as yet unclassified' stamp: 'I 4/29/2024 11:41:41' overrides: 50547795!
searchTreasureFor: aPirate at: anIsland with: aMa
	^ true "Aye, Aye!! La implementación está fuera del scope del parcial." ! !
!SimplePirate methodsFor: 'as yet unclassified' stamp: 'I 4/29/2024 11:41:45' overrides: 50547795!
searchTreasureFor: aPirate at: anIsland with: aMa
	self error: 'I am a simple pirate!!'.! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'I 4/29/2024 11:41:50'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'I 4/29/2024 11:41:50'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'I 4/29/2024 11:41:50'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'I 4/29/2024 11:41:50'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'I 4/29/2024 11:41:50'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'I 4/29/2024 11:41:50'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'I 4/29/2024 11:41:50'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'I 4/29/2024 11:41:50'!
PASSED!
!Crew methodsFor: 'as yet unclassified' stamp: 'I 4/29/2024 14:17:33' prior: 50547568!
buryTreasureAt: aPosition

	| terrain |
	
	terrain := island terrainAt: aPosition.
	pirates do: [ :pirate | pirate buryTreasureTo: aPosition in: terrain at: island ]."
	index := 1.
	[index <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: index.
		pirate canBurySecretAt: aPosition in: terrain at:island.
		index := index + 1.
	].22"
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'I 4/29/2024 14:17:38'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'I 4/29/2024 14:17:38'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'I 4/29/2024 14:17:38'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'I 4/29/2024 14:17:38'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'I 4/29/2024 14:17:38'!
FAILURE!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'I 4/29/2024 14:17:38'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'I 4/29/2024 14:17:38'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'I 4/29/2024 14:17:38'!
ERROR!
!Crew methodsFor: 'as yet unclassified' stamp: 'I 4/29/2024 14:18:02' prior: 50547845!
buryTreasureAt: aPosition

	| terrain |
	
	terrain := island terrainAt: aPosition.
	pirates do: [ :pirate | pirate canBuryTreasureAt: aPosition in: terrain at: island ]."
	index := 1.
	[index <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: index.
		pirate canBurySecretAt: aPosition in: terrain at:island.
		index := index + 1.
	].22"
	! !
!Crew methodsFor: 'as yet unclassified' stamp: 'I 4/29/2024 14:18:18' prior: 50547884!
buryTreasureAt: aPosition

	| terrain |
	
	terrain := island terrainAt: aPosition.
	pirates do: [ :pirate | pirate canBurySecretAt: aPosition in: terrain at: island ]."
	index := 1.
	[index <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: index.
		pirate canBurySecretAt: aPosition in: terrain at:island.
		index := index + 1.
	].22"
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'I 4/29/2024 14:18:19'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'I 4/29/2024 14:18:19'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'I 4/29/2024 14:18:19'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'I 4/29/2024 14:18:19'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'I 4/29/2024 14:18:19'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'I 4/29/2024 14:18:19'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'I 4/29/2024 14:18:19'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'I 4/29/2024 14:18:19'!
PASSED!

----QUIT----(29 April 2024 15:27:24) CuisUniversity-6169.image priorSource: 6910125!

----STARTUP---- (29 April 2024 22:37:14) as /home/ivan/Documents/Facu/Inge 1/linux64/linux64/CuisUniversity-6169.image!


----End fileIn of /home/ivan/Downloads/ISW1-2024-1C-Parcial.st----!

Integer parent!

Integer superclass!

Integer superclass = (Fraction superclass)!
!Floor methodsFor: 'totals' stamp: 'I 4/29/2024 22:39:14' prior: 50548689!
totalRoomsThatAre: roomToVerify
	
	^rooms count: [ :room | room state class = roomToVerify class or:[(room  superclass )= (roomToVerify superclass)]]
		
! !

!testRun: #HotelTest #test01CannotCreateHotelWithoutFloors stamp: 'I 4/29/2024 22:39:16'!
PASSED!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 4/29/2024 22:39:16'!
ERROR!

!testRun: #HotelTest #test03HotelCanReceiveATypeOfGuestInRoomAtFloor stamp: 'I 4/29/2024 22:39:16'!
ERROR!

!testRun: #HotelTest #test04HotelCanTakeAReservationForARoomAtFloor stamp: 'I 4/29/2024 22:39:16'!
ERROR!

!testRun: #HotelTest #test05HotelCanReceiveWithReservationATypeOfGuestInRoomAtFloor stamp: 'I 4/29/2024 22:39:16'!
ERROR!

!testRun: #HotelTest #test06HotelCannotReceiveWithReservationWithoutPreviousReservation stamp: 'I 4/29/2024 22:39:16'!
ERROR!

!testRun: #HotelTest #test07HotelProfitsAreTheSumOfEachFloorProfits stamp: 'I 4/29/2024 22:39:16'!
ERROR!

!testRun: #HotelTest #test08HotelLossesAreTheSumOfEachFloorLosses stamp: 'I 4/29/2024 22:39:16'!
ERROR!

!testRun: #HotelTest #test09HotelCannotReserveANonexistentRoom stamp: 'I 4/29/2024 22:39:16'!
ERROR!

!testRun: #HotelTest #test10HotelCannotReserveANonexistentFloor stamp: 'I 4/29/2024 22:39:16'!
ERROR!

!testRun: #HotelTest #test11HotelCannotReceiveAtNonexistentRoom stamp: 'I 4/29/2024 22:39:16'!
ERROR!

!testRun: #HotelTest #test12HotelCannotReceiveAtNonexistentFloor stamp: 'I 4/29/2024 22:39:16'!
ERROR!

!testRun: #HotelTest #test13HotelCannotReceiveWithReservationAtNonexistentRoom stamp: 'I 4/29/2024 22:39:16'!
ERROR!

!testRun: #HotelTest #test01CannotCreateHotelWithoutFloors stamp: 'I 4/29/2024 22:39:20'!
PASSED!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 4/29/2024 22:39:20'!
ERROR!

!testRun: #HotelTest #test03HotelCanReceiveATypeOfGuestInRoomAtFloor stamp: 'I 4/29/2024 22:39:20'!
ERROR!

!testRun: #HotelTest #test04HotelCanTakeAReservationForARoomAtFloor stamp: 'I 4/29/2024 22:39:20'!
ERROR!

!testRun: #HotelTest #test05HotelCanReceiveWithReservationATypeOfGuestInRoomAtFloor stamp: 'I 4/29/2024 22:39:20'!
ERROR!

!testRun: #HotelTest #test06HotelCannotReceiveWithReservationWithoutPreviousReservation stamp: 'I 4/29/2024 22:39:20'!
ERROR!

!testRun: #HotelTest #test07HotelProfitsAreTheSumOfEachFloorProfits stamp: 'I 4/29/2024 22:39:20'!
ERROR!

!testRun: #HotelTest #test08HotelLossesAreTheSumOfEachFloorLosses stamp: 'I 4/29/2024 22:39:20'!
ERROR!

!testRun: #HotelTest #test09HotelCannotReserveANonexistentRoom stamp: 'I 4/29/2024 22:39:20'!
ERROR!

!testRun: #HotelTest #test10HotelCannotReserveANonexistentFloor stamp: 'I 4/29/2024 22:39:20'!
ERROR!

!testRun: #HotelTest #test11HotelCannotReceiveAtNonexistentRoom stamp: 'I 4/29/2024 22:39:20'!
ERROR!

!testRun: #HotelTest #test12HotelCannotReceiveAtNonexistentFloor stamp: 'I 4/29/2024 22:39:20'!
ERROR!

!testRun: #HotelTest #test13HotelCannotReceiveWithReservationAtNonexistentRoom stamp: 'I 4/29/2024 22:39:20'!
ERROR!

!testRun: #HotelTest #test04HotelCanTakeAReservationForARoomAtFloor stamp: 'I 4/29/2024 22:39:28'!
ERROR!

!testRun: #HotelTest #test04HotelCanTakeAReservationForARoomAtFloor stamp: 'I 4/29/2024 22:39:41'!
ERROR!

!testRun: #HotelTest #test04HotelCanTakeAReservationForARoomAtFloor stamp: 'I 4/29/2024 22:39:47'!
ERROR!

!testRun: #RoomTest #test01NewRoomsAreAvailable stamp: 'I 4/29/2024 22:39:57'!
PASSED!

!testRun: #RoomTest #test02ReceivingAGuestMakesTheRoomOccupied stamp: 'I 4/29/2024 22:39:57'!
PASSED!

!testRun: #RoomTest #test03ReservingARoomMakesTheRoomReservedAndOccupied stamp: 'I 4/29/2024 22:39:57'!
PASSED!

!testRun: #RoomTest #test04CannotReceiveAGuestInAOccupiedRoom stamp: 'I 4/29/2024 22:39:57'!
PASSED!

!testRun: #RoomTest #test05CannotReceiveAGuestInAReservedRoom stamp: 'I 4/29/2024 22:39:57'!
PASSED!

!testRun: #RoomTest #test06ReceivingOnReservationMakesTheRoomOccupied stamp: 'I 4/29/2024 22:39:57'!
PASSED!

!testRun: #RoomTest #test07CannotReceiveOnReservationAnAvailableRoom stamp: 'I 4/29/2024 22:39:57'!
PASSED!

!testRun: #RoomTest #test08CannotReceiveOnReservationAnOccupiedRoom stamp: 'I 4/29/2024 22:39:57'!
PASSED!

!testRun: #RoomTest #test09ProfitOfAvailableRoomIsCeroPesos stamp: 'I 4/29/2024 22:39:57'!
PASSED!

!testRun: #RoomTest #test10ProfitOfReservedRoomIsHalfTheMinPriceInList stamp: 'I 4/29/2024 22:39:57'!
PASSED!

!testRun: #RoomTest #test11ProfitOfOccupiedRoomDependsOnGuestType stamp: 'I 4/29/2024 22:39:57'!
PASSED!

!testRun: #RoomTest #test12NoProfitOnOccupiedRoomByUnknownGuestType stamp: 'I 4/29/2024 22:39:57'!
PASSED!

!testRun: #RoomTest #test13LossesOfAvailableRoomIsHalfTheMaxPriceInList stamp: 'I 4/29/2024 22:39:57'!
PASSED!

!testRun: #RoomTest #test14LossesOfReservedRoomIsCeroPesos stamp: 'I 4/29/2024 22:39:57'!
PASSED!

!testRun: #RoomTest #test15LossesOfOccupiedRoomIsCeroPesos stamp: 'I 4/29/2024 22:39:57'!
PASSED!

!testRun: #RoomTest #test16CannotReserveWhenReserved stamp: 'I 4/29/2024 22:39:57'!
PASSED!

!testRun: #RoomTest #test17CannotReserveWhenOccupied stamp: 'I 4/29/2024 22:39:57'!
PASSED!

!testRun: #FloorTest #test01CannotCreateFloorWithoutRooms stamp: 'I 4/29/2024 22:39:59'!
PASSED!

!testRun: #FloorTest #test02CannotCreateFloorWithNoIntergerNumberOfRooms stamp: 'I 4/29/2024 22:39:59'!
PASSED!

!testRun: #FloorTest #test03CannotCreateFloorWithoutPrices stamp: 'I 4/29/2024 22:39:59'!
PASSED!

!testRun: #FloorTest #test04WhenAFloorIsCreatedAllTheRoomsAreAvailable stamp: 'I 4/29/2024 22:39:59'!
PASSED!

!testRun: #FloorTest #test05WhenAFloorReceivesAGuestInARoomReducesTheAvailableRoomsByOneAndIncreaseOccupiedByOne stamp: 'I 4/29/2024 22:39:59'!
PASSED!

!testRun: #FloorTest #test06WhenAFloorReceivesOnReservationAGuestInARoomKeepsTheAvailableRoomsAndOccupiedAndReducesTheReservedByOne stamp: 'I 4/29/2024 22:39:59'!
PASSED!

!testRun: #FloorTest #test07WhenARoomIsReservedTheFloorAvailableRoomsReducesByOneAndIncreaseReservedAndOccupiedByOne stamp: 'I 4/29/2024 22:39:59'!
PASSED!

!testRun: #FloorTest #test08TotalProfitShouldBeTheSumOfOccupiedRoomsProfits stamp: 'I 4/29/2024 22:39:59'!
PASSED!

!testRun: #FloorTest #test09TotalLossesShouldBeTheSumOfAvailableRoomsLosses stamp: 'I 4/29/2024 22:39:59'!
PASSED!

!testRun: #HotelTest #test01CannotCreateHotelWithoutFloors stamp: 'I 4/29/2024 22:40:01'!
PASSED!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 4/29/2024 22:40:01'!
ERROR!

!testRun: #HotelTest #test03HotelCanReceiveATypeOfGuestInRoomAtFloor stamp: 'I 4/29/2024 22:40:01'!
ERROR!

!testRun: #HotelTest #test04HotelCanTakeAReservationForARoomAtFloor stamp: 'I 4/29/2024 22:40:01'!
ERROR!

!testRun: #HotelTest #test05HotelCanReceiveWithReservationATypeOfGuestInRoomAtFloor stamp: 'I 4/29/2024 22:40:01'!
ERROR!

!testRun: #HotelTest #test06HotelCannotReceiveWithReservationWithoutPreviousReservation stamp: 'I 4/29/2024 22:40:01'!
ERROR!

!testRun: #HotelTest #test07HotelProfitsAreTheSumOfEachFloorProfits stamp: 'I 4/29/2024 22:40:01'!
ERROR!

!testRun: #HotelTest #test08HotelLossesAreTheSumOfEachFloorLosses stamp: 'I 4/29/2024 22:40:01'!
ERROR!

!testRun: #HotelTest #test09HotelCannotReserveANonexistentRoom stamp: 'I 4/29/2024 22:40:01'!
ERROR!

!testRun: #HotelTest #test10HotelCannotReserveANonexistentFloor stamp: 'I 4/29/2024 22:40:01'!
ERROR!

!testRun: #HotelTest #test11HotelCannotReceiveAtNonexistentRoom stamp: 'I 4/29/2024 22:40:01'!
ERROR!

!testRun: #HotelTest #test12HotelCannotReceiveAtNonexistentFloor stamp: 'I 4/29/2024 22:40:01'!
ERROR!

!testRun: #HotelTest #test13HotelCannotReceiveWithReservationAtNonexistentRoom stamp: 'I 4/29/2024 22:40:01'!
ERROR!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 4/29/2024 22:40:06'!
ERROR!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 4/29/2024 22:40:32'!
ERROR!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 4/29/2024 22:40:48'!
ERROR!
!Floor methodsFor: 'totals' stamp: 'I 4/29/2024 22:41:19' prior: 50549364!
totalRoomsThatAre: roomToVerify
	
	^rooms count: [ :room | room state class = roomToVerify class ]
		
! !
!Floor methodsFor: 'totals' stamp: 'I 4/29/2024 22:41:49' prior: 50549610!
totalRoomsThatAre: roomToVerify
	
	^rooms count: [ :room | room state class = (roomToVerify class) ]
		
! !

!testRun: #HotelTest #test01CannotCreateHotelWithoutFloors stamp: 'I 4/29/2024 22:41:51'!
PASSED!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 4/29/2024 22:41:51'!
FAILURE!

!testRun: #HotelTest #test03HotelCanReceiveATypeOfGuestInRoomAtFloor stamp: 'I 4/29/2024 22:41:51'!
PASSED!

!testRun: #HotelTest #test04HotelCanTakeAReservationForARoomAtFloor stamp: 'I 4/29/2024 22:41:51'!
FAILURE!

!testRun: #HotelTest #test05HotelCanReceiveWithReservationATypeOfGuestInRoomAtFloor stamp: 'I 4/29/2024 22:41:51'!
PASSED!

!testRun: #HotelTest #test06HotelCannotReceiveWithReservationWithoutPreviousReservation stamp: 'I 4/29/2024 22:41:51'!
PASSED!

!testRun: #HotelTest #test07HotelProfitsAreTheSumOfEachFloorProfits stamp: 'I 4/29/2024 22:41:51'!
PASSED!

!testRun: #HotelTest #test08HotelLossesAreTheSumOfEachFloorLosses stamp: 'I 4/29/2024 22:41:51'!
PASSED!

!testRun: #HotelTest #test09HotelCannotReserveANonexistentRoom stamp: 'I 4/29/2024 22:41:51'!
PASSED!

!testRun: #HotelTest #test10HotelCannotReserveANonexistentFloor stamp: 'I 4/29/2024 22:41:51'!
PASSED!

!testRun: #HotelTest #test11HotelCannotReceiveAtNonexistentRoom stamp: 'I 4/29/2024 22:41:51'!
PASSED!

!testRun: #HotelTest #test12HotelCannotReceiveAtNonexistentFloor stamp: 'I 4/29/2024 22:41:51'!
PASSED!

!testRun: #HotelTest #test13HotelCannotReceiveWithReservationAtNonexistentRoom stamp: 'I 4/29/2024 22:41:51'!
FAILURE!

!testRun: #HotelTest #test01CannotCreateHotelWithoutFloors stamp: 'I 4/29/2024 22:41:52'!
PASSED!

!testRun: #HotelTest #test03HotelCanReceiveATypeOfGuestInRoomAtFloor stamp: 'I 4/29/2024 22:41:52'!
PASSED!

!testRun: #HotelTest #test05HotelCanReceiveWithReservationATypeOfGuestInRoomAtFloor stamp: 'I 4/29/2024 22:41:52'!
PASSED!

!testRun: #HotelTest #test06HotelCannotReceiveWithReservationWithoutPreviousReservation stamp: 'I 4/29/2024 22:41:52'!
PASSED!

!testRun: #HotelTest #test07HotelProfitsAreTheSumOfEachFloorProfits stamp: 'I 4/29/2024 22:41:52'!
PASSED!

!testRun: #HotelTest #test08HotelLossesAreTheSumOfEachFloorLosses stamp: 'I 4/29/2024 22:41:52'!
PASSED!

!testRun: #HotelTest #test09HotelCannotReserveANonexistentRoom stamp: 'I 4/29/2024 22:41:52'!
PASSED!

!testRun: #HotelTest #test10HotelCannotReserveANonexistentFloor stamp: 'I 4/29/2024 22:41:52'!
PASSED!

!testRun: #HotelTest #test11HotelCannotReceiveAtNonexistentRoom stamp: 'I 4/29/2024 22:41:52'!
PASSED!

!testRun: #HotelTest #test12HotelCannotReceiveAtNonexistentFloor stamp: 'I 4/29/2024 22:41:52'!
PASSED!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 4/29/2024 22:41:52'!
FAILURE!

!testRun: #HotelTest #test04HotelCanTakeAReservationForARoomAtFloor stamp: 'I 4/29/2024 22:41:52'!
FAILURE!

!testRun: #HotelTest #test13HotelCannotReceiveWithReservationAtNonexistentRoom stamp: 'I 4/29/2024 22:41:52'!
FAILURE!

!testRun: #HotelTest #test01CannotCreateHotelWithoutFloors stamp: 'I 4/29/2024 22:41:53'!
PASSED!

!testRun: #HotelTest #test03HotelCanReceiveATypeOfGuestInRoomAtFloor stamp: 'I 4/29/2024 22:41:53'!
PASSED!

!testRun: #HotelTest #test05HotelCanReceiveWithReservationATypeOfGuestInRoomAtFloor stamp: 'I 4/29/2024 22:41:53'!
PASSED!

!testRun: #HotelTest #test06HotelCannotReceiveWithReservationWithoutPreviousReservation stamp: 'I 4/29/2024 22:41:53'!
PASSED!

!testRun: #HotelTest #test07HotelProfitsAreTheSumOfEachFloorProfits stamp: 'I 4/29/2024 22:41:53'!
PASSED!

!testRun: #HotelTest #test08HotelLossesAreTheSumOfEachFloorLosses stamp: 'I 4/29/2024 22:41:53'!
PASSED!

!testRun: #HotelTest #test09HotelCannotReserveANonexistentRoom stamp: 'I 4/29/2024 22:41:53'!
PASSED!

!testRun: #HotelTest #test10HotelCannotReserveANonexistentFloor stamp: 'I 4/29/2024 22:41:53'!
PASSED!

!testRun: #HotelTest #test11HotelCannotReceiveAtNonexistentRoom stamp: 'I 4/29/2024 22:41:53'!
PASSED!

!testRun: #HotelTest #test12HotelCannotReceiveAtNonexistentFloor stamp: 'I 4/29/2024 22:41:53'!
PASSED!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 4/29/2024 22:41:53'!
FAILURE!

!testRun: #HotelTest #test04HotelCanTakeAReservationForARoomAtFloor stamp: 'I 4/29/2024 22:41:53'!
FAILURE!

!testRun: #HotelTest #test13HotelCannotReceiveWithReservationAtNonexistentRoom stamp: 'I 4/29/2024 22:41:53'!
FAILURE!

!testRun: #HotelTest #test01CannotCreateHotelWithoutFloors stamp: 'I 4/29/2024 22:41:54'!
PASSED!

!testRun: #HotelTest #test03HotelCanReceiveATypeOfGuestInRoomAtFloor stamp: 'I 4/29/2024 22:41:54'!
PASSED!

!testRun: #HotelTest #test05HotelCanReceiveWithReservationATypeOfGuestInRoomAtFloor stamp: 'I 4/29/2024 22:41:54'!
PASSED!

!testRun: #HotelTest #test06HotelCannotReceiveWithReservationWithoutPreviousReservation stamp: 'I 4/29/2024 22:41:54'!
PASSED!

!testRun: #HotelTest #test07HotelProfitsAreTheSumOfEachFloorProfits stamp: 'I 4/29/2024 22:41:54'!
PASSED!

!testRun: #HotelTest #test08HotelLossesAreTheSumOfEachFloorLosses stamp: 'I 4/29/2024 22:41:54'!
PASSED!

!testRun: #HotelTest #test09HotelCannotReserveANonexistentRoom stamp: 'I 4/29/2024 22:41:54'!
PASSED!

!testRun: #HotelTest #test10HotelCannotReserveANonexistentFloor stamp: 'I 4/29/2024 22:41:54'!
PASSED!

!testRun: #HotelTest #test11HotelCannotReceiveAtNonexistentRoom stamp: 'I 4/29/2024 22:41:54'!
PASSED!

!testRun: #HotelTest #test12HotelCannotReceiveAtNonexistentFloor stamp: 'I 4/29/2024 22:41:54'!
PASSED!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 4/29/2024 22:41:54'!
FAILURE!

!testRun: #HotelTest #test04HotelCanTakeAReservationForARoomAtFloor stamp: 'I 4/29/2024 22:41:54'!
FAILURE!

!testRun: #HotelTest #test13HotelCannotReceiveWithReservationAtNonexistentRoom stamp: 'I 4/29/2024 22:41:54'!
FAILURE!
!Floor methodsFor: 'totals' stamp: 'i 4/29/2024 21:47:55' prior: 50549616!
totalRoomsThatAre: roomToVerify
	
	^rooms count: [ :room | room state class = roomToVerify class or:[((room state class) superclass )= ((roomToVerify class)superclass)]]
		
! !
!Floor methodsFor: 'totals' stamp: 'I 4/29/2024 22:43:59' prior: 50549798!
totalRoomsThatAre: roomToVerify
	
	^rooms count: [ :room | room state class = (roomToVerify class )or:[((room state class) superclass )= ((roomToVerify class)superclass)]]
		
! !

!testRun: #HotelTest #test01CannotCreateHotelWithoutFloors stamp: 'I 4/29/2024 22:44:02'!
PASSED!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 4/29/2024 22:44:02'!
FAILURE!

!testRun: #HotelTest #test03HotelCanReceiveATypeOfGuestInRoomAtFloor stamp: 'I 4/29/2024 22:44:02'!
FAILURE!

!testRun: #HotelTest #test04HotelCanTakeAReservationForARoomAtFloor stamp: 'I 4/29/2024 22:44:02'!
PASSED!

!testRun: #HotelTest #test05HotelCanReceiveWithReservationATypeOfGuestInRoomAtFloor stamp: 'I 4/29/2024 22:44:02'!
FAILURE!

!testRun: #HotelTest #test06HotelCannotReceiveWithReservationWithoutPreviousReservation stamp: 'I 4/29/2024 22:44:02'!
PASSED!

!testRun: #HotelTest #test07HotelProfitsAreTheSumOfEachFloorProfits stamp: 'I 4/29/2024 22:44:02'!
PASSED!

!testRun: #HotelTest #test08HotelLossesAreTheSumOfEachFloorLosses stamp: 'I 4/29/2024 22:44:02'!
PASSED!

!testRun: #HotelTest #test09HotelCannotReserveANonexistentRoom stamp: 'I 4/29/2024 22:44:02'!
PASSED!

!testRun: #HotelTest #test10HotelCannotReserveANonexistentFloor stamp: 'I 4/29/2024 22:44:02'!
PASSED!

!testRun: #HotelTest #test11HotelCannotReceiveAtNonexistentRoom stamp: 'I 4/29/2024 22:44:02'!
PASSED!

!testRun: #HotelTest #test12HotelCannotReceiveAtNonexistentFloor stamp: 'I 4/29/2024 22:44:02'!
PASSED!

!testRun: #HotelTest #test13HotelCannotReceiveWithReservationAtNonexistentRoom stamp: 'I 4/29/2024 22:44:02'!
PASSED!

!testRun: #HotelTest #test01CannotCreateHotelWithoutFloors stamp: 'I 4/29/2024 22:44:14'!
PASSED!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 4/29/2024 22:44:14'!
FAILURE!

!testRun: #HotelTest #test03HotelCanReceiveATypeOfGuestInRoomAtFloor stamp: 'I 4/29/2024 22:44:14'!
FAILURE!

!testRun: #HotelTest #test04HotelCanTakeAReservationForARoomAtFloor stamp: 'I 4/29/2024 22:44:14'!
PASSED!

!testRun: #HotelTest #test05HotelCanReceiveWithReservationATypeOfGuestInRoomAtFloor stamp: 'I 4/29/2024 22:44:14'!
FAILURE!

!testRun: #HotelTest #test06HotelCannotReceiveWithReservationWithoutPreviousReservation stamp: 'I 4/29/2024 22:44:14'!
PASSED!

!testRun: #HotelTest #test07HotelProfitsAreTheSumOfEachFloorProfits stamp: 'I 4/29/2024 22:44:14'!
PASSED!

!testRun: #HotelTest #test08HotelLossesAreTheSumOfEachFloorLosses stamp: 'I 4/29/2024 22:44:14'!
PASSED!

!testRun: #HotelTest #test09HotelCannotReserveANonexistentRoom stamp: 'I 4/29/2024 22:44:14'!
PASSED!

!testRun: #HotelTest #test10HotelCannotReserveANonexistentFloor stamp: 'I 4/29/2024 22:44:14'!
PASSED!

!testRun: #HotelTest #test11HotelCannotReceiveAtNonexistentRoom stamp: 'I 4/29/2024 22:44:14'!
PASSED!

!testRun: #HotelTest #test12HotelCannotReceiveAtNonexistentFloor stamp: 'I 4/29/2024 22:44:14'!
PASSED!

!testRun: #HotelTest #test13HotelCannotReceiveWithReservationAtNonexistentRoom stamp: 'I 4/29/2024 22:44:14'!
PASSED!

!testRun: #HotelTest #test03HotelCanReceiveATypeOfGuestInRoomAtFloor stamp: 'I 4/29/2024 22:44:41'!
FAILURE!
!Floor methodsFor: 'totals' stamp: 'I 4/29/2024 22:45:37' prior: 50549806!
totalRoomsThatAre: roomToVerify
	
	^rooms count: [ :room | room state class = (roomToVerify class )and:[((room state class) superclass )= ((roomToVerify class)superclass)]]
		
! !

!testRun: #HotelTest #test01CannotCreateHotelWithoutFloors stamp: 'I 4/29/2024 22:45:39'!
PASSED!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 4/29/2024 22:45:39'!
FAILURE!

!testRun: #HotelTest #test03HotelCanReceiveATypeOfGuestInRoomAtFloor stamp: 'I 4/29/2024 22:45:39'!
PASSED!

!testRun: #HotelTest #test04HotelCanTakeAReservationForARoomAtFloor stamp: 'I 4/29/2024 22:45:39'!
FAILURE!

!testRun: #HotelTest #test05HotelCanReceiveWithReservationATypeOfGuestInRoomAtFloor stamp: 'I 4/29/2024 22:45:39'!
PASSED!

!testRun: #HotelTest #test06HotelCannotReceiveWithReservationWithoutPreviousReservation stamp: 'I 4/29/2024 22:45:39'!
PASSED!

!testRun: #HotelTest #test07HotelProfitsAreTheSumOfEachFloorProfits stamp: 'I 4/29/2024 22:45:39'!
PASSED!

!testRun: #HotelTest #test08HotelLossesAreTheSumOfEachFloorLosses stamp: 'I 4/29/2024 22:45:39'!
PASSED!

!testRun: #HotelTest #test09HotelCannotReserveANonexistentRoom stamp: 'I 4/29/2024 22:45:39'!
PASSED!

!testRun: #HotelTest #test10HotelCannotReserveANonexistentFloor stamp: 'I 4/29/2024 22:45:39'!
PASSED!

!testRun: #HotelTest #test11HotelCannotReceiveAtNonexistentRoom stamp: 'I 4/29/2024 22:45:39'!
PASSED!

!testRun: #HotelTest #test12HotelCannotReceiveAtNonexistentFloor stamp: 'I 4/29/2024 22:45:39'!
PASSED!

!testRun: #HotelTest #test13HotelCannotReceiveWithReservationAtNonexistentRoom stamp: 'I 4/29/2024 22:45:39'!
FAILURE!

!testRun: #HotelTest #test01CannotCreateHotelWithoutFloors stamp: 'I 4/29/2024 22:45:53'!
PASSED!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 4/29/2024 22:45:53'!
FAILURE!

!testRun: #HotelTest #test03HotelCanReceiveATypeOfGuestInRoomAtFloor stamp: 'I 4/29/2024 22:45:53'!
PASSED!

!testRun: #HotelTest #test04HotelCanTakeAReservationForARoomAtFloor stamp: 'I 4/29/2024 22:45:53'!
FAILURE!

!testRun: #HotelTest #test05HotelCanReceiveWithReservationATypeOfGuestInRoomAtFloor stamp: 'I 4/29/2024 22:45:53'!
PASSED!

!testRun: #HotelTest #test06HotelCannotReceiveWithReservationWithoutPreviousReservation stamp: 'I 4/29/2024 22:45:53'!
PASSED!

!testRun: #HotelTest #test07HotelProfitsAreTheSumOfEachFloorProfits stamp: 'I 4/29/2024 22:45:53'!
PASSED!

!testRun: #HotelTest #test08HotelLossesAreTheSumOfEachFloorLosses stamp: 'I 4/29/2024 22:45:53'!
PASSED!

!testRun: #HotelTest #test09HotelCannotReserveANonexistentRoom stamp: 'I 4/29/2024 22:45:53'!
PASSED!

!testRun: #HotelTest #test10HotelCannotReserveANonexistentFloor stamp: 'I 4/29/2024 22:45:53'!
PASSED!

!testRun: #HotelTest #test11HotelCannotReceiveAtNonexistentRoom stamp: 'I 4/29/2024 22:45:53'!
PASSED!

!testRun: #HotelTest #test12HotelCannotReceiveAtNonexistentFloor stamp: 'I 4/29/2024 22:45:53'!
PASSED!

!testRun: #HotelTest #test13HotelCannotReceiveWithReservationAtNonexistentRoom stamp: 'I 4/29/2024 22:45:53'!
FAILURE!
!Floor methodsFor: 'totals' stamp: 'I 4/29/2024 22:48:31' prior: 50549906!
totalRoomsThatAre: roomToVerify
	
	^rooms count: [ :room | room state class = (roomToVerify class )and:[((room state class) superclass )= ((roomToVerify class)superclass)]]
		
! !

!testRun: #HotelTest #test01CannotCreateHotelWithoutFloors stamp: 'I 4/29/2024 23:26:37'!
PASSED!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 4/29/2024 23:26:37'!
FAILURE!

!testRun: #HotelTest #test03HotelCanReceiveATypeOfGuestInRoomAtFloor stamp: 'I 4/29/2024 23:26:37'!
PASSED!

!testRun: #HotelTest #test04HotelCanTakeAReservationForARoomAtFloor stamp: 'I 4/29/2024 23:26:37'!
FAILURE!

!testRun: #HotelTest #test05HotelCanReceiveWithReservationATypeOfGuestInRoomAtFloor stamp: 'I 4/29/2024 23:26:37'!
PASSED!

!testRun: #HotelTest #test06HotelCannotReceiveWithReservationWithoutPreviousReservation stamp: 'I 4/29/2024 23:26:37'!
PASSED!

!testRun: #HotelTest #test07HotelProfitsAreTheSumOfEachFloorProfits stamp: 'I 4/29/2024 23:26:37'!
PASSED!

!testRun: #HotelTest #test08HotelLossesAreTheSumOfEachFloorLosses stamp: 'I 4/29/2024 23:26:37'!
PASSED!

!testRun: #HotelTest #test09HotelCannotReserveANonexistentRoom stamp: 'I 4/29/2024 23:26:37'!
PASSED!

!testRun: #HotelTest #test10HotelCannotReserveANonexistentFloor stamp: 'I 4/29/2024 23:26:37'!
PASSED!

!testRun: #HotelTest #test11HotelCannotReceiveAtNonexistentRoom stamp: 'I 4/29/2024 23:26:37'!
PASSED!

!testRun: #HotelTest #test12HotelCannotReceiveAtNonexistentFloor stamp: 'I 4/29/2024 23:26:37'!
PASSED!

!testRun: #HotelTest #test13HotelCannotReceiveWithReservationAtNonexistentRoom stamp: 'I 4/29/2024 23:26:37'!
FAILURE!

!testRun: #HotelTest #test03HotelCanReceiveATypeOfGuestInRoomAtFloor stamp: 'I 4/29/2024 23:26:58'!
PASSED!

!testRun: #HotelTest #test01CannotCreateHotelWithoutFloors stamp: 'I 4/30/2024 01:21:55'!
PASSED!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 4/30/2024 01:21:55'!
FAILURE!

!testRun: #HotelTest #test03HotelCanReceiveATypeOfGuestInRoomAtFloor stamp: 'I 4/30/2024 01:21:55'!
PASSED!

!testRun: #HotelTest #test04HotelCanTakeAReservationForARoomAtFloor stamp: 'I 4/30/2024 01:21:55'!
FAILURE!

!testRun: #HotelTest #test05HotelCanReceiveWithReservationATypeOfGuestInRoomAtFloor stamp: 'I 4/30/2024 01:21:55'!
PASSED!

!testRun: #HotelTest #test06HotelCannotReceiveWithReservationWithoutPreviousReservation stamp: 'I 4/30/2024 01:21:55'!
PASSED!

!testRun: #HotelTest #test07HotelProfitsAreTheSumOfEachFloorProfits stamp: 'I 4/30/2024 01:21:55'!
PASSED!

!testRun: #HotelTest #test08HotelLossesAreTheSumOfEachFloorLosses stamp: 'I 4/30/2024 01:21:55'!
PASSED!

!testRun: #HotelTest #test09HotelCannotReserveANonexistentRoom stamp: 'I 4/30/2024 01:21:55'!
PASSED!

!testRun: #HotelTest #test10HotelCannotReserveANonexistentFloor stamp: 'I 4/30/2024 01:21:55'!
PASSED!

!testRun: #HotelTest #test11HotelCannotReceiveAtNonexistentRoom stamp: 'I 4/30/2024 01:21:55'!
PASSED!

!testRun: #HotelTest #test12HotelCannotReceiveAtNonexistentFloor stamp: 'I 4/30/2024 01:21:55'!
PASSED!

!testRun: #HotelTest #test13HotelCannotReceiveWithReservationAtNonexistentRoom stamp: 'I 4/30/2024 01:21:55'!
FAILURE!

1 + false!
!Hotel methodsFor: 'testing' stamp: 'I 4/30/2024 01:28:03' prior: 50548903!
isEmpty


	^self totalRoomsAvailable & (self findThoseThatVerify: RoomIsAvailable new)
	
! !
!Hotel methodsFor: 'testing' stamp: 'I 4/30/2024 01:28:06' prior: 50550102!
isEmpty


	^self totalRoomsAvailable = (self findThoseThatVerify: RoomIsAvailable new)
	
! !

self totalRoomsAvailable!
!Hotel methodsFor: 'testing' stamp: 'I 4/30/2024 01:29:51' prior: 50550108!
isEmpty


	^self totalRoomsAvailable = (self findThoseThatVerify: Room new)
	
! !

self totalRoomsAvailable !

!testRun: #HotelTest #test01CannotCreateHotelWithoutFloors stamp: 'I 4/30/2024 01:30:19'!
PASSED!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 4/30/2024 01:30:19'!
PASSED!

!testRun: #HotelTest #test03HotelCanReceiveATypeOfGuestInRoomAtFloor stamp: 'I 4/30/2024 01:30:19'!
PASSED!

!testRun: #HotelTest #test04HotelCanTakeAReservationForARoomAtFloor stamp: 'I 4/30/2024 01:30:19'!
FAILURE!

!testRun: #HotelTest #test05HotelCanReceiveWithReservationATypeOfGuestInRoomAtFloor stamp: 'I 4/30/2024 01:30:19'!
PASSED!

!testRun: #HotelTest #test06HotelCannotReceiveWithReservationWithoutPreviousReservation stamp: 'I 4/30/2024 01:30:19'!
PASSED!

!testRun: #HotelTest #test07HotelProfitsAreTheSumOfEachFloorProfits stamp: 'I 4/30/2024 01:30:19'!
PASSED!

!testRun: #HotelTest #test08HotelLossesAreTheSumOfEachFloorLosses stamp: 'I 4/30/2024 01:30:19'!
PASSED!

!testRun: #HotelTest #test09HotelCannotReserveANonexistentRoom stamp: 'I 4/30/2024 01:30:19'!
PASSED!

!testRun: #HotelTest #test10HotelCannotReserveANonexistentFloor stamp: 'I 4/30/2024 01:30:19'!
PASSED!

!testRun: #HotelTest #test11HotelCannotReceiveAtNonexistentRoom stamp: 'I 4/30/2024 01:30:19'!
PASSED!

!testRun: #HotelTest #test12HotelCannotReceiveAtNonexistentFloor stamp: 'I 4/30/2024 01:30:19'!
PASSED!

!testRun: #HotelTest #test13HotelCannotReceiveWithReservationAtNonexistentRoom stamp: 'I 4/30/2024 01:30:19'!
FAILURE!

----QUIT----(30 April 2024 01:46:09) CuisUniversity-6169.image priorSource: 6921159!

----STARTUP---- (2 May 2024 20:31:03) as /home/ivan/Documents/Facu/Inge 1/linux64/linux64/CuisUniversity-6169.image!


----End fileIn of /home/ivan/Downloads/ISW1-2024-1C-Parcial-Solucion(1).st----!

----STARTUP---- (2 May 2024 20:36:18) as /home/ivan/Documents/Facu/Inge 1/linux64/linux64/CuisUniversity-6169.image!

!Hotel methodsFor: 'totals' stamp: 'I 5/2/2024 20:37:08' prior: 50548893!
totalRoomsOccupied


	^floors sum: [:floor | floor totalRoomsOccupied]. 

! !
!Hotel methodsFor: 'totals' stamp: 'I 5/2/2024 20:37:30' prior: 50548898!
totalRoomsReserved

	
	^floors sum: [:floor | floor totalRoomsReserved]. 
	! !

!testRun: #HotelTest #test01CannotCreateHotelWithoutFloors stamp: 'I 5/2/2024 20:37:36'!
PASSED!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 5/2/2024 20:37:36'!
PASSED!

!testRun: #HotelTest #test03HotelCanReceiveATypeOfGuestInRoomAtFloor stamp: 'I 5/2/2024 20:37:36'!
PASSED!

!testRun: #HotelTest #test04HotelCanTakeAReservationForARoomAtFloor stamp: 'I 5/2/2024 20:37:36'!
PASSED!

!testRun: #HotelTest #test05HotelCanReceiveWithReservationATypeOfGuestInRoomAtFloor stamp: 'I 5/2/2024 20:37:36'!
PASSED!

!testRun: #HotelTest #test06HotelCannotReceiveWithReservationWithoutPreviousReservation stamp: 'I 5/2/2024 20:37:36'!
PASSED!

!testRun: #HotelTest #test07HotelProfitsAreTheSumOfEachFloorProfits stamp: 'I 5/2/2024 20:37:36'!
PASSED!

!testRun: #HotelTest #test08HotelLossesAreTheSumOfEachFloorLosses stamp: 'I 5/2/2024 20:37:36'!
PASSED!

!testRun: #HotelTest #test09HotelCannotReserveANonexistentRoom stamp: 'I 5/2/2024 20:37:36'!
PASSED!

!testRun: #HotelTest #test10HotelCannotReserveANonexistentFloor stamp: 'I 5/2/2024 20:37:36'!
PASSED!

!testRun: #HotelTest #test11HotelCannotReceiveAtNonexistentRoom stamp: 'I 5/2/2024 20:37:36'!
PASSED!

!testRun: #HotelTest #test12HotelCannotReceiveAtNonexistentFloor stamp: 'I 5/2/2024 20:37:36'!
PASSED!

!testRun: #HotelTest #test13HotelCannotReceiveWithReservationAtNonexistentRoom stamp: 'I 5/2/2024 20:37:36'!
PASSED!

!methodRemoval: Floor #totalRoomsThatAre: stamp: 'I 5/2/2024 20:37:44'!
totalRoomsThatAre: roomToVerify
	
	^rooms count: [ :room | room state class = (roomToVerify class )and:[((room state class) superclass )= ((roomToVerify class)superclass)]]
		
!

!testRun: #FloorTest #test01CannotCreateFloorWithoutRooms stamp: 'I 5/2/2024 20:37:46'!
PASSED!

!testRun: #FloorTest #test02CannotCreateFloorWithNoIntergerNumberOfRooms stamp: 'I 5/2/2024 20:37:46'!
PASSED!

!testRun: #FloorTest #test03CannotCreateFloorWithoutPrices stamp: 'I 5/2/2024 20:37:46'!
PASSED!

!testRun: #FloorTest #test04WhenAFloorIsCreatedAllTheRoomsAreAvailable stamp: 'I 5/2/2024 20:37:46'!
PASSED!

!testRun: #FloorTest #test05WhenAFloorReceivesAGuestInARoomReducesTheAvailableRoomsByOneAndIncreaseOccupiedByOne stamp: 'I 5/2/2024 20:37:46'!
PASSED!

!testRun: #FloorTest #test06WhenAFloorReceivesOnReservationAGuestInARoomKeepsTheAvailableRoomsAndOccupiedAndReducesTheReservedByOne stamp: 'I 5/2/2024 20:37:46'!
PASSED!

!testRun: #FloorTest #test07WhenARoomIsReservedTheFloorAvailableRoomsReducesByOneAndIncreaseReservedAndOccupiedByOne stamp: 'I 5/2/2024 20:37:46'!
PASSED!

!testRun: #FloorTest #test08TotalProfitShouldBeTheSumOfOccupiedRoomsProfits stamp: 'I 5/2/2024 20:37:46'!
PASSED!

!testRun: #FloorTest #test09TotalLossesShouldBeTheSumOfAvailableRoomsLosses stamp: 'I 5/2/2024 20:37:46'!
PASSED!

!testRun: #HotelTest #test01CannotCreateHotelWithoutFloors stamp: 'I 5/2/2024 20:37:50'!
PASSED!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 5/2/2024 20:37:50'!
ERROR!

!testRun: #HotelTest #test03HotelCanReceiveATypeOfGuestInRoomAtFloor stamp: 'I 5/2/2024 20:37:50'!
ERROR!

!testRun: #HotelTest #test04HotelCanTakeAReservationForARoomAtFloor stamp: 'I 5/2/2024 20:37:50'!
ERROR!

!testRun: #HotelTest #test05HotelCanReceiveWithReservationATypeOfGuestInRoomAtFloor stamp: 'I 5/2/2024 20:37:50'!
ERROR!

!testRun: #HotelTest #test06HotelCannotReceiveWithReservationWithoutPreviousReservation stamp: 'I 5/2/2024 20:37:50'!
ERROR!

!testRun: #HotelTest #test07HotelProfitsAreTheSumOfEachFloorProfits stamp: 'I 5/2/2024 20:37:50'!
ERROR!

!testRun: #HotelTest #test08HotelLossesAreTheSumOfEachFloorLosses stamp: 'I 5/2/2024 20:37:50'!
ERROR!

!testRun: #HotelTest #test09HotelCannotReserveANonexistentRoom stamp: 'I 5/2/2024 20:37:50'!
ERROR!

!testRun: #HotelTest #test10HotelCannotReserveANonexistentFloor stamp: 'I 5/2/2024 20:37:50'!
ERROR!

!testRun: #HotelTest #test11HotelCannotReceiveAtNonexistentRoom stamp: 'I 5/2/2024 20:37:50'!
ERROR!

!testRun: #HotelTest #test12HotelCannotReceiveAtNonexistentFloor stamp: 'I 5/2/2024 20:37:50'!
ERROR!

!testRun: #HotelTest #test13HotelCannotReceiveWithReservationAtNonexistentRoom stamp: 'I 5/2/2024 20:37:50'!
ERROR!

!testRun: #HotelTest #test01CannotCreateHotelWithoutFloors stamp: 'I 5/2/2024 20:37:55'!
PASSED!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 5/2/2024 20:37:55'!
ERROR!

!testRun: #HotelTest #test03HotelCanReceiveATypeOfGuestInRoomAtFloor stamp: 'I 5/2/2024 20:37:55'!
ERROR!

!testRun: #HotelTest #test04HotelCanTakeAReservationForARoomAtFloor stamp: 'I 5/2/2024 20:37:55'!
ERROR!

!testRun: #HotelTest #test05HotelCanReceiveWithReservationATypeOfGuestInRoomAtFloor stamp: 'I 5/2/2024 20:37:55'!
ERROR!

!testRun: #HotelTest #test06HotelCannotReceiveWithReservationWithoutPreviousReservation stamp: 'I 5/2/2024 20:37:55'!
ERROR!

!testRun: #HotelTest #test07HotelProfitsAreTheSumOfEachFloorProfits stamp: 'I 5/2/2024 20:37:55'!
ERROR!

!testRun: #HotelTest #test08HotelLossesAreTheSumOfEachFloorLosses stamp: 'I 5/2/2024 20:37:55'!
ERROR!

!testRun: #HotelTest #test09HotelCannotReserveANonexistentRoom stamp: 'I 5/2/2024 20:37:55'!
ERROR!

!testRun: #HotelTest #test10HotelCannotReserveANonexistentFloor stamp: 'I 5/2/2024 20:37:55'!
ERROR!

!testRun: #HotelTest #test11HotelCannotReceiveAtNonexistentRoom stamp: 'I 5/2/2024 20:37:55'!
ERROR!

!testRun: #HotelTest #test12HotelCannotReceiveAtNonexistentFloor stamp: 'I 5/2/2024 20:37:55'!
ERROR!

!testRun: #HotelTest #test13HotelCannotReceiveWithReservationAtNonexistentRoom stamp: 'I 5/2/2024 20:37:55'!
ERROR!

!testRun: #HotelTest #test01CannotCreateHotelWithoutFloors stamp: 'I 5/2/2024 20:38:10'!
PASSED!

!testRun: #HotelTest #test01CannotCreateHotelWithoutFloors stamp: 'I 5/2/2024 20:38:10'!
PASSED!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 5/2/2024 20:38:10'!
ERROR!

!testRun: #HotelTest #test03HotelCanReceiveATypeOfGuestInRoomAtFloor stamp: 'I 5/2/2024 20:38:10'!
ERROR!

!testRun: #HotelTest #test04HotelCanTakeAReservationForARoomAtFloor stamp: 'I 5/2/2024 20:38:10'!
ERROR!

!testRun: #HotelTest #test05HotelCanReceiveWithReservationATypeOfGuestInRoomAtFloor stamp: 'I 5/2/2024 20:38:10'!
ERROR!

!testRun: #HotelTest #test06HotelCannotReceiveWithReservationWithoutPreviousReservation stamp: 'I 5/2/2024 20:38:10'!
ERROR!

!testRun: #HotelTest #test07HotelProfitsAreTheSumOfEachFloorProfits stamp: 'I 5/2/2024 20:38:10'!
ERROR!

!testRun: #HotelTest #test08HotelLossesAreTheSumOfEachFloorLosses stamp: 'I 5/2/2024 20:38:10'!
ERROR!

!testRun: #HotelTest #test09HotelCannotReserveANonexistentRoom stamp: 'I 5/2/2024 20:38:10'!
ERROR!

!testRun: #HotelTest #test10HotelCannotReserveANonexistentFloor stamp: 'I 5/2/2024 20:38:10'!
ERROR!

!testRun: #HotelTest #test11HotelCannotReceiveAtNonexistentRoom stamp: 'I 5/2/2024 20:38:10'!
ERROR!

!testRun: #HotelTest #test12HotelCannotReceiveAtNonexistentFloor stamp: 'I 5/2/2024 20:38:10'!
ERROR!

!testRun: #HotelTest #test13HotelCannotReceiveWithReservationAtNonexistentRoom stamp: 'I 5/2/2024 20:38:10'!
ERROR!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 5/2/2024 20:38:16'!
ERROR!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 5/2/2024 20:38:44'!
ERROR!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 5/2/2024 20:38:58'!
ERROR!
!Hotel methodsFor: 'totals' stamp: 'I 5/2/2024 20:39:55' prior: 50548885!
totalRooms


	^floors sum: [ :aFloor | aFloor totalRooms ]

! !

!testRun: #HotelTest #test01CannotCreateHotelWithoutFloors stamp: 'I 5/2/2024 20:39:56'!
PASSED!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 5/2/2024 20:39:56'!
ERROR!

!testRun: #HotelTest #test03HotelCanReceiveATypeOfGuestInRoomAtFloor stamp: 'I 5/2/2024 20:39:56'!
PASSED!

!testRun: #HotelTest #test04HotelCanTakeAReservationForARoomAtFloor stamp: 'I 5/2/2024 20:39:56'!
PASSED!

!testRun: #HotelTest #test05HotelCanReceiveWithReservationATypeOfGuestInRoomAtFloor stamp: 'I 5/2/2024 20:39:56'!
PASSED!

!testRun: #HotelTest #test06HotelCannotReceiveWithReservationWithoutPreviousReservation stamp: 'I 5/2/2024 20:39:56'!
PASSED!

!testRun: #HotelTest #test07HotelProfitsAreTheSumOfEachFloorProfits stamp: 'I 5/2/2024 20:39:56'!
PASSED!

!testRun: #HotelTest #test08HotelLossesAreTheSumOfEachFloorLosses stamp: 'I 5/2/2024 20:39:56'!
PASSED!

!testRun: #HotelTest #test09HotelCannotReserveANonexistentRoom stamp: 'I 5/2/2024 20:39:56'!
PASSED!

!testRun: #HotelTest #test10HotelCannotReserveANonexistentFloor stamp: 'I 5/2/2024 20:39:56'!
PASSED!

!testRun: #HotelTest #test11HotelCannotReceiveAtNonexistentRoom stamp: 'I 5/2/2024 20:39:56'!
PASSED!

!testRun: #HotelTest #test12HotelCannotReceiveAtNonexistentFloor stamp: 'I 5/2/2024 20:39:56'!
PASSED!

!testRun: #HotelTest #test13HotelCannotReceiveWithReservationAtNonexistentRoom stamp: 'I 5/2/2024 20:39:56'!
PASSED!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 5/2/2024 20:39:56'!
ERROR!

!testRun: #HotelTest #test01CannotCreateHotelWithoutFloors stamp: 'I 5/2/2024 20:40:00'!
PASSED!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 5/2/2024 20:40:00'!
ERROR!

!testRun: #HotelTest #test03HotelCanReceiveATypeOfGuestInRoomAtFloor stamp: 'I 5/2/2024 20:40:00'!
PASSED!

!testRun: #HotelTest #test04HotelCanTakeAReservationForARoomAtFloor stamp: 'I 5/2/2024 20:40:00'!
PASSED!

!testRun: #HotelTest #test05HotelCanReceiveWithReservationATypeOfGuestInRoomAtFloor stamp: 'I 5/2/2024 20:40:00'!
PASSED!

!testRun: #HotelTest #test06HotelCannotReceiveWithReservationWithoutPreviousReservation stamp: 'I 5/2/2024 20:40:00'!
PASSED!

!testRun: #HotelTest #test07HotelProfitsAreTheSumOfEachFloorProfits stamp: 'I 5/2/2024 20:40:00'!
PASSED!

!testRun: #HotelTest #test08HotelLossesAreTheSumOfEachFloorLosses stamp: 'I 5/2/2024 20:40:00'!
PASSED!

!testRun: #HotelTest #test09HotelCannotReserveANonexistentRoom stamp: 'I 5/2/2024 20:40:00'!
PASSED!

!testRun: #HotelTest #test10HotelCannotReserveANonexistentFloor stamp: 'I 5/2/2024 20:40:00'!
PASSED!

!testRun: #HotelTest #test11HotelCannotReceiveAtNonexistentRoom stamp: 'I 5/2/2024 20:40:00'!
PASSED!

!testRun: #HotelTest #test12HotelCannotReceiveAtNonexistentFloor stamp: 'I 5/2/2024 20:40:00'!
PASSED!

!testRun: #HotelTest #test13HotelCannotReceiveWithReservationAtNonexistentRoom stamp: 'I 5/2/2024 20:40:00'!
PASSED!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 5/2/2024 20:40:00'!
ERROR!

!testRun: #HotelTest #test01CannotCreateHotelWithoutFloors stamp: 'I 5/2/2024 20:40:06'!
PASSED!

!testRun: #HotelTest #test07HotelProfitsAreTheSumOfEachFloorProfits stamp: 'I 5/2/2024 20:40:08'!
PASSED!

!testRun: #HotelTest #test13HotelCannotReceiveWithReservationAtNonexistentRoom stamp: 'I 5/2/2024 20:40:10'!
PASSED!

!testRun: #HotelTest #test12HotelCannotReceiveAtNonexistentFloor stamp: 'I 5/2/2024 20:40:11'!
PASSED!

!testRun: #HotelTest #test11HotelCannotReceiveAtNonexistentRoom stamp: 'I 5/2/2024 20:40:12'!
PASSED!

!testRun: #HotelTest #test10HotelCannotReserveANonexistentFloor stamp: 'I 5/2/2024 20:40:13'!
PASSED!

!testRun: #HotelTest #test09HotelCannotReserveANonexistentRoom stamp: 'I 5/2/2024 20:40:15'!
PASSED!

!testRun: #HotelTest #test08HotelLossesAreTheSumOfEachFloorLosses stamp: 'I 5/2/2024 20:40:16'!
PASSED!

!testRun: #HotelTest #test06HotelCannotReceiveWithReservationWithoutPreviousReservation stamp: 'I 5/2/2024 20:40:17'!
PASSED!

!testRun: #HotelTest #test07HotelProfitsAreTheSumOfEachFloorProfits stamp: 'I 5/2/2024 20:40:19'!
PASSED!

!testRun: #HotelTest #test06HotelCannotReceiveWithReservationWithoutPreviousReservation stamp: 'I 5/2/2024 20:40:21'!
PASSED!

!testRun: #HotelTest #test05HotelCanReceiveWithReservationATypeOfGuestInRoomAtFloor stamp: 'I 5/2/2024 20:40:22'!
PASSED!

!testRun: #HotelTest #test04HotelCanTakeAReservationForARoomAtFloor stamp: 'I 5/2/2024 20:40:23'!
PASSED!

!testRun: #HotelTest #test03HotelCanReceiveATypeOfGuestInRoomAtFloor stamp: 'I 5/2/2024 20:40:25'!
PASSED!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 5/2/2024 20:40:27'!
ERROR!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 5/2/2024 20:40:27'!
ERROR!
!Hotel methodsFor: 'testing' stamp: 'I 5/2/2024 20:41:13' prior: 50550115!
isEmpty


	^self totalRoomsAvailable = availableRoomsCount
	
! !

!testRun: #HotelTest #test01CannotCreateHotelWithoutFloors stamp: 'I 5/2/2024 20:41:18'!
PASSED!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 5/2/2024 20:41:18'!
PASSED!

!testRun: #HotelTest #test03HotelCanReceiveATypeOfGuestInRoomAtFloor stamp: 'I 5/2/2024 20:41:18'!
PASSED!

!testRun: #HotelTest #test04HotelCanTakeAReservationForARoomAtFloor stamp: 'I 5/2/2024 20:41:18'!
PASSED!

!testRun: #HotelTest #test05HotelCanReceiveWithReservationATypeOfGuestInRoomAtFloor stamp: 'I 5/2/2024 20:41:18'!
PASSED!

!testRun: #HotelTest #test06HotelCannotReceiveWithReservationWithoutPreviousReservation stamp: 'I 5/2/2024 20:41:18'!
PASSED!

!testRun: #HotelTest #test07HotelProfitsAreTheSumOfEachFloorProfits stamp: 'I 5/2/2024 20:41:18'!
PASSED!

!testRun: #HotelTest #test08HotelLossesAreTheSumOfEachFloorLosses stamp: 'I 5/2/2024 20:41:18'!
PASSED!

!testRun: #HotelTest #test09HotelCannotReserveANonexistentRoom stamp: 'I 5/2/2024 20:41:18'!
PASSED!

!testRun: #HotelTest #test10HotelCannotReserveANonexistentFloor stamp: 'I 5/2/2024 20:41:18'!
PASSED!

!testRun: #HotelTest #test11HotelCannotReceiveAtNonexistentRoom stamp: 'I 5/2/2024 20:41:18'!
PASSED!

!testRun: #HotelTest #test12HotelCannotReceiveAtNonexistentFloor stamp: 'I 5/2/2024 20:41:18'!
PASSED!

!testRun: #HotelTest #test13HotelCannotReceiveWithReservationAtNonexistentRoom stamp: 'I 5/2/2024 20:41:18'!
PASSED!
!Hotel methodsFor: 'guests' stamp: 'I 5/2/2024 20:50:27' prior: 50548934!
reserveRoom: aRoomNumber atFloor: aFloorNumber

	| room |
	room := self atRoom: aRoomNumber inFloor: aFloorNumber." 
	floor := floors at: aFloorNumber ifAbsent:  [ self class signalFloorNumberDoesNotExist ].
	room := floor rooms at: aRoomNumber ifAbsent: [ self class signalRoomNumberDoesNotExist ].
	 "
	room reserve.
	
	availableRoomsCount := availableRoomsCount - 1.
! !
!Hotel methodsFor: 'guests' stamp: 'I 5/2/2024 20:50:53' prior: 50548921!
receiveWithReservation: aGuestType atFloor: aFloorNumber atRoom: aRoomNumber

	| room |
	room := self atRoom: aRoomNumber inFloor: aFloorNumber. "
	floor := floors at: aFloorNumber ifAbsent:  [ self class signalFloorNumberDoesNotExist ].
	room := floor rooms at: aRoomNumber ifAbsent: [ self class signalRoomNumberDoesNotExist ].
"
	room receiveWithReservation: aGuestType.

! !
!Hotel methodsFor: 'guests' stamp: 'I 5/2/2024 20:51:07' prior: 50548908!
receive: aGuestType atFloor: aFloorNumber atRoom: aRoomNumber

	| room |
	room := self atRoom: aRoomNumber inFloor: "
	floor := floors at: aFloorNumber ifAbsent:  [ self class signalFloorNumberDoesNotExist ].
	room := floor rooms at: aRoomNumber ifAbsent: [ self class signalRoomNumberDoesNotExist ].
"
	room receive: aGuestType.
	
	availableRoomsCount := availableRoomsCount - 1.
! !
!Hotel methodsFor: 'guests' stamp: 'I 5/2/2024 20:51:32' prior: 50550636!
receive: aGuestType atFloor: aFloorNumber atRoom: aRoomNumber

	| room |
	room := self atRoom: aRoomNumber inFloor. "
	floor := floors at: aFloorNumber ifAbsent:  [ self class signalFloorNumberDoesNotExist ].
	room := floor rooms at: aRoomNumber ifAbsent: [ self class signalRoomNumberDoesNotExist ].
"
	room receive: aGuestType.
	
	availableRoomsCount := availableRoomsCount - 1.
! !
!Hotel methodsFor: 'guests' stamp: 'I 5/2/2024 20:52:11' prior: 50550651!
receive: aGuestType atFloor: aFloorNumber atRoom: aRoomNumber

	| room |
	room := self atRoom: aRoomNumber  inFloor: aFloorNumber. "
	floor := floors at: aFloorNumber ifAbsent:  [ self class signalFloorNumberDoesNotExist ].
	room := floor rooms at: aRoomNumber ifAbsent: [ self class signalRoomNumberDoesNotExist ].
"
	room receive: aGuestType.
	
	availableRoomsCount := availableRoomsCount - 1.
! !
!Hotel methodsFor: 'guests' stamp: 'I 5/2/2024 20:52:23' prior: 50550666!
receive: aGuestType atFloor: aFloorNumber atRoom: aRoomNumber

	| room |
	room := self atRoom: aRoomNumber inFloor: aFloorNumber. "
	floor := floors at: aFloorNumber ifAbsent:  [ self class signalFloorNumberDoesNotExist ].
	room := floor rooms at: aRoomNumber ifAbsent: [ self class signalRoomNumberDoesNotExist ].
"
	room receive: aGuestType.
	
	availableRoomsCount := availableRoomsCount - 1.
! !

!methodRemoval: Hotel #findThoseThatVerify: stamp: 'I 5/2/2024 20:55:02'!
findThoseThatVerify: roomThatVerify
	|total|
	total := 0.
	
	floors do: [: floor | |roomTotal|
			roomTotal := floor totalRoomsThatAre: roomThatVerify.
			total := total + roomTotal.].
			
	^total.!
!Hotel methodsFor: 'guests' stamp: 'I 5/2/2024 20:55:15'!
atRoom: aRoomNumber inFloor: aFloorNumber
        | floor room |
	
	floor := floors at: aFloorNumber ifAbsent:  [ self class signalFloorNumberDoesNotExist ].
	room := floor rooms at: aRoomNumber ifAbsent: [ self class signalRoomNumberDoesNotExist ].
	
	^ room! !

!testRun: #HotelTest #test01CannotCreateHotelWithoutFloors stamp: 'I 5/2/2024 20:55:23'!
PASSED!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'I 5/2/2024 20:55:23'!
PASSED!

!testRun: #HotelTest #test03HotelCanReceiveATypeOfGuestInRoomAtFloor stamp: 'I 5/2/2024 20:55:23'!
PASSED!

!testRun: #HotelTest #test04HotelCanTakeAReservationForARoomAtFloor stamp: 'I 5/2/2024 20:55:23'!
PASSED!

!testRun: #HotelTest #test05HotelCanReceiveWithReservationATypeOfGuestInRoomAtFloor stamp: 'I 5/2/2024 20:55:23'!
PASSED!

!testRun: #HotelTest #test06HotelCannotReceiveWithReservationWithoutPreviousReservation stamp: 'I 5/2/2024 20:55:23'!
PASSED!

!testRun: #HotelTest #test07HotelProfitsAreTheSumOfEachFloorProfits stamp: 'I 5/2/2024 20:55:23'!
PASSED!

!testRun: #HotelTest #test08HotelLossesAreTheSumOfEachFloorLosses stamp: 'I 5/2/2024 20:55:23'!
PASSED!

!testRun: #HotelTest #test09HotelCannotReserveANonexistentRoom stamp: 'I 5/2/2024 20:55:23'!
PASSED!

!testRun: #HotelTest #test10HotelCannotReserveANonexistentFloor stamp: 'I 5/2/2024 20:55:23'!
PASSED!

!testRun: #HotelTest #test11HotelCannotReceiveAtNonexistentRoom stamp: 'I 5/2/2024 20:55:23'!
PASSED!

!testRun: #HotelTest #test12HotelCannotReceiveAtNonexistentFloor stamp: 'I 5/2/2024 20:55:23'!
PASSED!

!testRun: #HotelTest #test13HotelCannotReceiveWithReservationAtNonexistentRoom stamp: 'I 5/2/2024 20:55:23'!
PASSED!

----End fileIn of /home/ivan/Documents/Facu/Inge 1/linux64/linux64/Packages/System/Collections-CompactArrays.pck.st----!

----End fileIn of /home/ivan/Documents/Facu/Inge 1/linux64/linux64/Packages/Features/Compression.pck.st----!

----End fileIn of /home/ivan/Documents/Facu/Inge 1/linux64/linux64/Packages/Features/Sound.pck.st----!

----End fileIn of /home/ivan/Documents/Facu/Inge 1/linux64/linux64/Packages/Features/Cryptography-DigitalSignatures.pck.st----!

----End fileIn of /home/ivan/Documents/Facu/Inge 1/linux64/linux64/Packages/Features/Identities-UUID.pck.st----!

----End fileIn of /home/ivan/Documents/Facu/Inge 1/linux64/linux64/Packages/System/Network-Kernel.pck.st----!

----End fileIn of /home/ivan/Downloads/WebClient.pck.st----!

----End fileIn of /home/ivan/Downloads/TDDBabyStepsGame.st----!

----QUIT----(3 May 2024 01:26:42) CuisUniversity-6169.image priorSource: 6992458!

----STARTUP---- (5 May 2024 16:04:45) as /home/ivan/Documents/Facu/Inge 1/linux64/linux64/CuisUniversity-6169.image!


TDDBabyStepsGame !

TDDBabyStepsGame !

TDDBabyStepsGame !

TDDBabyStepsGame !

TDDBabyStepsGame start!

TDDBabyStepsGameRot13 start!

!classDefinition: #TDDBabyStepsRot13Test category: #TDDBabyStepsGameRot13 stamp: 'I 5/5/2024 16:05:39'!
TestCase subclass: #TDDBabyStepsRot13Test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TDDBabyStepsGameRot13'!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:06:38'!
test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $n equals: $a asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:06:47'!
ERROR!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:07:12'!
ERROR!

----End fileIn of /home/ivan/Documents/Facu/Inge 1/linux64/linux64/Packages/TerseGuide.pck.st----!

$a!

$a asString!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:14:11'!
ERROR!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:15:01'!
ERROR!

----SNAPSHOT----(5 May 2024 16:20:31) CuisUniversity-6169.image priorSource: 8274423!

$ superclass!

$ class!
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 16:22:25'!
asRot13
	($a = self) ifTrue:[^$n].! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:23:02'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:23:02'!
test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $z equals: $m asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:23:02'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:23:02'!
test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $z equals: $m asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:23:02'!
test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $z equals: $m asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:23:02'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:23:08'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:23:08'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:23:19'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:23:19'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:23:19'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:23:19'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:23:24'!
FAILURE!
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 16:23:51' prior: 50593192!
asRot13
	($a = self) ifTrue:[^$n].
	^$z! !

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:23:55'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:23:55'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:23:55'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:23:56'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:23:56'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:23:56'!
test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $a equals: $n asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:23:56'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:23:56'!
test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $a equals: $n asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:23:56'!
test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $a equals: $n asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:23:56'!
FAILURE!

$n asRot13!
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 16:25:25' prior: 50593259!
asRot13
	($a = self) ifTrue:[^$n].
	($n = self) ifTrue:[^$a].
	^$z! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:25:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:25:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:25:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:25:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:25:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:25:32'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:25:32'!
test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $m equals: $z asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:25:32'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:25:32'!
test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $m equals: $z asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:25:32'!
test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $m equals: $z asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:25:32'!
FAILURE!
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 16:25:48' prior: 50593314!
asRot13
	($a = self) ifTrue:[^$n].
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m].
	^$z! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:25:52'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:25:52'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:25:52'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:25:52'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:25:52'!
test05CharOnTheBelowRangeDoesntChange
	
	self assert: $` equals: $` asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 16:25:52'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 16:25:52'!
test05CharOnTheBelowRangeDoesntChange
	
	self assert: $` equals: $` asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:25:52'!
test05CharOnTheBelowRangeDoesntChange
	
	self assert: $` equals: $` asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 16:25:52'!
FAILURE!
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 16:28:55' prior: 50593374!
asRot13
	(((self between: $a and: $z) or: [self between: $A and: $Z])not) ifTrue:[^self].
	($a = self) ifTrue:[^$n].
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m].
	^$z! !

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 16:28:57'!
ERROR!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 16:28:57'!
ERROR!
lity !
as methodsFor: 'paths' stamp: 'jmv 7/20/2021 10:23:09'!
Transformation withRadians: 0.1).
f := FontFamily familyName: 'DejaVu Sans' pointSize: 72.
s := 'Latin text in VectorGraphics'.
(c drawString: s from: 1 to: s size atBaseline: 100@100 font: f color: Color black) print.
c strokeWidth: 1 color: Color red do: [ c moveTo: 100@100; lineTo: 1000@100 ].
Display forceToScreen
	"
	^ aString asUnicodeString displayOnVectorEngine: engine from: firstIndex to: lastIndex
		at: aPoint font: aTrueTypeFont color: aColor.!
8    8.74
				1.0    2.35    10.16
				1.0    2.90    11.48
				1.0    -1.37    1.18
				2.0    -0.66    -1.58    -2.24    -0.93
				2.0    1.80    -0.13    0.93    -2.24
				1.0    4.65    6.74
				1.0    3.11    3.04
				1.0    4.70    2.38
				2.0    6.41    3.53    5.75    1.95
				1.0    7.50    6.17
				1.0    6.19    3.00
				1.0    7.78    2.35
				2.0    9.49    3.49    8.83    1.91
				1.0    10.36    5.60
				1.0    9.27    2.96
				1.0    10.85    2.31
				2.0    12.56    3.45    11.91    1.87
				1.0    13.44    5.57
				1.0    14.97    9.26
				2.0    14.95    16.69    16.28    12.43
				1.0    8.62    19.31
				2.0    5.55    17.87    7.04    19.97
				1.0    5.33    17.34
			] asFloat32Array` ].!
top+d maxY: aRectangle top+lh-d rx: r ry: r ].!
== aKey ifTrue:
			[^method removeProperty: aKey]].
	^aBlock value!
y
	 pointers to the corresponding elements of this array.  The identityHashes remain
	 with the pointers rather than with the objects so that objects in hashed structures
	 should still be properly indexed after the mutation.

	Warning. This is a dangerous operation and it could lead to a crash if some object in receiver or argument is receiver of a method currently in execution. See #anyReceiverInStackIn: See senders for examples."

	<primitive: 128 error: ec>
	ec == #'bad receiver' ifTrue:
		[^self error: 'receiver must be of class Array'].
	ec == #'bad argument' ifTrue:
		[^self error: (otherArray class == Array
						ifTrue: ['arg must be of class Array']
						ifFalse: ['receiver and argument must have the same size'])].
	ec == #'inappropriate operation' ifTrue:
		[^self error: 'can''t become immediates such as SmallIntegers or Characters'].
	ec == #'no modification' ifTrue:
		[^self error: 'can''t become immutable objects'].
	ec == #'object is pinned' ifTrue:
		[^self error: 'can''t become pinned objects'].
	ec == #'insufficient object memory' ifTrue:
		[| maxRequired |
		 "In Spur, two-way become may involve making each pair of objects into a forwarder into a copy of the other.
		 So if become fails with #'insufficient object memory', garbage collect, and if necessary, grow memory."
		 maxRequired := (self sum: [:obj | obj class byteSizeOfInstanceOfSize: obj basicSize] ifEmpty: [0])
						+ (otherArray sum: [:obj | obj class byteSizeOfInstanceOfSize: obj basicSize] ifEmpty: [0]).
		 (Smalltalk garbageCollectMost < maxRequired
		  and: [Smalltalk garbageCollect < maxRequired]) ifTrue:
			[Smalltalk growMemoryByAtLeast: maxRequired].
		 ^self elementsExchangeIdentityWith: otherArray].
	self primitiveFailed!
mergeSortFrom: first to: last src: src dst: dst by: aBlock
	"Private!! Split the range to be sorted in half, sort each half, and merge the two half-ranges into dst."

	| middle |
	first = last ifTrue: [^ self].
	middle := (first + last) // 2.
	self mergeSortFrom: first to: middle src: dst dst: src by: aBlock.
	self mergeSortFrom: middle + 1 to: last src: dst dst: src by: aBlock.
	src mergeFirst: first middle: middle last: last into: dst by: aBlock.
!
: 3 put: thirdObject.
	newCollection at: 4 put: fourthObject.
	newCollection at: 5 put: fifthObject.
	^newCollection!
values.  aStream is not binary.  (See class comment). 4 bytes in aStream goes to 3 bytes in output."

	| me |
	aStream position: 0.
	me := self new mimeStream: aStream.
	me dataStream: (ReadWriteStream on: (ByteArray new: aStream size * 3 // 4)).
	me mimeDecodeToByteArray.
	me dataStream position: 0.
	^ me dataStream!
mpiling' stamp: 'eem 5/13/2008 09:50'!
10-11	= 32-bit indexable (Bitmap)
		12-15	= 16-bit indexable
		16-23	= 8-bit indexable
		24-31	= compiled methods (CompiledMethod)"
	| instSpec |
	instSpec := self instSpec.
	instSpec < 9 ifTrue: [^Smalltalk wordSize].
	instSpec >= 16 ifTrue: [^1].
	instSpec >= 12 ifTrue: [^2].
	instSpec >= 10 ifTrue: [^4].
	^8!
able sized"

	format := aFormatInstanceDescription

!
20/1996 10:50:05'!
of the right type (Integer, 
	Float, or Form) or if the combination rule is not implemented. 
	In addition to the original 16 combination rules, this BitBlt supports
	16	fail (to simulate paint)
	17	fail (to simulate mask)
	18	sourceWord + destinationWord
	19	sourceWord - destinationWord
	20	rgbAdd: sourceWord with: destinationWord
	21	rgbSub: sourceWord with: destinationWord
	22	rgbDiff: sourceWord with: destinationWord
	23	tallyIntoMap: destinationWord
	24	alphaBlend: sourceWord with: destinationWord
	25	pixPaint: sourceWord with: destinationWord
	26	pixMask: sourceWord with: destinationWord
	27	rgbMax: sourceWord with: destinationWord
	28	rgbMin: sourceWord with: destinationWord
	29	rgbMin: sourceWord bitInvert32 with: destinationWord
"
	<primitive: 'primitiveCopyBits' module: 'BitBltPlugin'>

	"No alpha specified -- re-run with alpha = 1.0"
	(combinationRule >= 30 and: [combinationRule <= 31]) ifTrue: [
		^ self copyBitsTranslucent: 255].

	"Check for unimplmented rules"
	combinationRule = Form oldPaint ifTrue: [^ self oldPaintBits].
	combinationRule = Form oldErase1bitShape ifTrue: [^ self oldErase1bitShapeBits].

	"Check if BitBlt doesn't support full color maps"
	(colorMap notNil and:[colorMap isColormap]) ifTrue:[
		colorMap := colorMap colors.
		^self copyBits].
	"Check if clipping gots us way out of range"
	self clipRange ifTrue:[self roundVariables. ^self copyBitsAgain].

	'Bad BitBlt argument (Maybe a Float or Fraction?); will retry rounding.' print.
	"Convert all numeric parameters to integers and try again."
	self roundVariables.
	^ self copyBitsAgain!
stY.
				bbH := height - (clipY - destY).
				dy := clipY].
	(dy + bbH) > (clipY + clipHeight)
		ifTrue: [bbH := bbH - ((dy + bbH) - (clipY + clipHeight))].
	sourceForm ifNotNil:[
		sx < 0
			ifTrue: [dx := dx - sx.
					bbW := bbW + sx.
					sx := 0].
		sx + bbW > sourceForm width
			ifTrue: [bbW := bbW - (sx + bbW - sourceForm width)].
		sy < 0
			ifTrue: [dy := dy - sy.
					bbH := bbH + sy.
					sy := 0].
		sy + bbH > sourceForm height
			ifTrue: [bbH := bbH - (sy + bbH - sourceForm height)].
	].
	(bbW <= 0 or:[bbH <= 0]) ifTrue:[
		sourceX := sourceY := destX := destY := clipX := clipY := width := height := 0.
		^true].
	(sx = sourceX 
		and:[sy = sourceY 
		and:[dx = destX 
		and:[dy = destY 
		and:[bbW = width 
		and:[bbH = height]]]]]) ifTrue:[^false].
	sourceX := sx.
	sourceY := sy.
	destX := dx.
	destY := dy.
	width := bbW.
	height := bbH.
	^true!
3:16'!
Y := rect top+borderWidth.

	"left"
	destX := rect left.
	self copyBits.

	"right"
	destX := rect right - borderWidth.
	self copyBits!
is BigEndian:
		Most significant bye of first word in self goes to first position in result.
	This means that for a BigEndian 8bpp Form, pixels are in the right order in the ByteArray
	
	Form lena asGrayForm bits asByteArray copyFrom: 1 to: 4.
	(Form lena asGrayForm asFormOfDepth: 8) bits asByteArray copyFrom: 1 to: 4.
	(0 to: 3) collect: [ :x | ((Form lena asGrayForm colorAt: x@0) luminance * 255) rounded ].
	"
	| f bytes hack |
	f := Form extent: 4@self size depth: 8 bits: self.
	bytes := ByteArray new: self size * 4.
	hack := Form new hackBits: bytes.
	Smalltalk isLittleEndian ifTrue: [hack swapEndianness].
	hack copyBits: f boundingBox
		from: f
		at: `0@0`
		clippingBox: hack boundingBox
		rule: Form over.

	"f displayOn: hack."
	^ bytes!
Array
	 or: [numArgs ~= anArray size]) ifTrue:
		[^ContextPart primitiveFailTokenFor: nil].
	sz := self basicSize.
	newContext stackp: sz + numArgs.
	1 to: numArgs do:
		[:i| newContext at: i put: (anArray at: i)].
	1 to: sz do:
		[:i| newContext at: i + numArgs put: (self at: i)].
	^newContext!
.org/wiki/Currying
	[ :a :b | a + b ] value: 1 value: 2
	[ :a :b | a + b ] curried value: 1 :: value: 2
	"
	^self argumentCount caseOf: {
		[ 1] -> [[ :arg1 | [ self value: arg1 ]]].
		[ 2] -> [[ :arg1 | [ :arg2 | self value: arg1 value: arg2 ]]].
		[ 3] -> [[ :arg1 | [ :arg2 :arg3 | self value: arg1 value: arg2 value: arg3 ]]].
		[ 4] -> [[ :arg1 | [ :arg2 :arg3 :arg4 | self value: arg1 value: arg2 value: arg3 value: arg4 ]]] }
	otherwise: [ self error: 'can not curry' ]!
ments bytecode."
	stackPointer := stackPointer + 1!
a block'].
	scanner nextByte = Encoder pushNilCode ifTrue:
		[joinOffsets := Dictionary new.
		 [scanner pc < blockEnd] whileTrue:
			[line := symbolicLines at: scanner pc.
			 prior := stackPointer.
			 thePc := scanner pc.
			 scanner interpretNextInstructionFor: self.
			 Transcript newLine; print: prior; nextPutAll: '->'; print: stackPointer;  tab; print: thePc; tab; nextPutAll: line]].
	^stackPointer!
ith: aTempVariableNode!
ifTrue:
			[temp name: temp definingScope remoteTempNodeName]]!
oxedFloat64 methodsFor: 'comparing' stamp: 'di 11/6/1998 13:56'!
g' stamp: 'KenD 10/26/2020 13:16:39'!
is an existing class in this system.
Redefining it might cause serious problems.
Is this really what you want to do?'))
				ifFalse: [ ^ false ]].
	"ar 8/29/1999: Use oldClass superclass for defining oldClass
	since oldClass superclass knows the definerClass of oldClass."
	oldClass ifNotNil: [ oldClass := oldClass superclass ].
	class := Compiler
				evaluate: defString
				notifying: aRequestor
				logged: true.
	(class isKindOf: Behavior)
		ifTrue: [
				self changed: #systemCategoryRoots.
				self changed: #classList.
				self changed: #clearUserEdits.
				self setClass: class selector: nil.
				"self clearUserEditFlag; editClass."
				^ true ]
		ifFalse: [ ^ false ]!
anged.
	self changed: #classCommentText.
!
!
temCategory!
unsigned integer quantity starting from the given byte index"
	
	bigEndian ifFalse: [
		self 
			at: index + 1 put: (value bitShift: -8);
			at: index put: (value bitAnd: 16rFF).
		^value ].
	self
		at: index put: (value bitShift: -8);
		at: index+1 put: (value bitAnd: 16rFF).
	^value!
t any preceeding extensions."

	self subclassResponsibility!
ray new: 16).
	currentStop := categoryIndex := 0.
	[(categoryIndex := categoryIndex + 1) <= categoryArray size]
		whileTrue: 
			[(categoryStops at: categoryIndex) > currentStop
				ifTrue: 
					[keptCategories nextPut: (categoryArray at: categoryIndex).
					keptStops nextPut: (currentStop := categoryStops at: categoryIndex)]].
	categoryArray := keptCategories contents.
	categoryStops := keptStops contents.
	categoryArray isEmpty
		ifTrue: [
			categoryArray := Array with: Default.
			categoryStops := Array with: 0]

	"ClassOrganizer allInstancesDo: [:co | co removeEmptyCategories]."!
sMoveToSomePackage: ])
			ifTrue: [ ^ self scanClassRemoval: tokens ].
		(firstToken == #methodRemoval: or: [ firstToken == #methodMoveToSomePackage: ])
			ifTrue: [ ^ self scanMethodRemoval: tokens ].
		(secondToken == #methodsFor: or: [ 
			tokens size > 2 and: [			tokens third == #methodsFor: ] ])
			ifTrue: [ ^ self scanMethodDefinition: tokens ].
		secondToken == #commentStamp:
			ifTrue: [ ^ self scanClassComment: tokens ].
		firstToken == #provides:
			ifTrue: [ ^ self scanFeatureProvision: tokens ].
		firstToken == #requires:
			ifTrue: [ ^ self scanFeatureRequirement: tokens ].
		firstToken == #classRenamed:
			ifTrue: [ ^ self scanClassRenamed: tokens ].
		]!
st.
		listIndex := 0.
		self clearSelections ].
	self changed: #list!
newChangeList add: (changeList at: i).
			newList add: (list at: i)]].
	newChangeList size < changeList size
		ifTrue: [
			changeList := newChangeList.
			list := newList.
			listIndex := 0.
			self clearSelections ].
	self changed: #list

	!
selecting changes with errors, then removing them, etc., but it had some problems and that solution is more a hack.
So, instances of this class will keep errors when filing in a change, and it allows the posibility to show the change with the error in a change list window.

A doit change that signaled a MessageNotUnderstood is assume to not be an error becuase those kinds of things are evaluations in specific contexts that will obiously generate errors.
All doits with errors could be assume not to be errors, but I limited to MNU type of errors to avoid filtering errors that should be shown.!
lassVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!
r: 'exceptions' stamp: 'HAW 3/17/2019 06:00:37'!
esNotImplement: senderSelector asSymbol].
		
	(senderToAdd sendsOrRefersTo: self oldSelector) ifFalse: [ ^self inform: senderToAdd classAndSelector, ' does not refer to #', self oldSelector ].
	
	self addToList: senderToAdd !
hangeSet methodsFor: 'testing' stamp: 'RAA 10/19/2000 13:17'!
tToCurrentVersion:refStream:']]
			ifFalse: [structures removeKey: rec priorName ifAbsent: nil]]].
	list isEmpty ifTrue: [^ msgSet].
	msgSet messageList ifNil: [msgSet initializeMessageList: list]
		ifNotNil: [list do: [:item | msgSet addMethodReference: item]].
	^ msgSet!
ChunkPut: 'Smalltalk renameClassNamed: #', (self oldNameFor: class), ' as: #', class name; newLine].

	(self atClass: class includes: #change) ifTrue: [ "fat definition only needed for changes"
		stream
			nextPut: $!!; nextChunkPut: class definitionPreambleWithoutStamp; newLine;
			nextChunkPut: (self fatDefForClass: class); newLine.
	] ifFalse: [
		(self atClass: class includes: #add) ifTrue: [ "use current definition for add"
			stream
				nextPut: $!!; nextChunkPut: class definitionPreambleWithoutStamp; newLine;
				nextChunkPut: class definition; newLine.
		].
	].

	(self atClass: class includes: #comment) ifTrue: [
		class theNonMetaClass organization putCommentOnFile: stream numbered: 0 moveSource: false forClass: class theNonMetaClass.
		stream newLine].

!
gorized: selector from: oldCategory to: newCategory inClass: aClass.

	oldPackageOrNil := CodePackage packageOfMethodCategory: oldCategory ofClass: aClass ifNone: nil.
	oldPackageOrNil
		ifNotNil: [ oldPackageOrNil hasUnsavedChanges: true ]
		ifNil: [
			"If destination is a package, but source isn't, then record the change in the base system changeset"
			newPackageOrNil ifNotNil: [
				self changeSetForBaseSystem noteMethodMoveToOtherPackage: selector forClass: aClass ]]!
r!
eStop := characterIndex		"scanning for index"
				ifNil: [ line last ].			"scanning for point"
			(runStopIndex := lastIndex + (runLength - 1)) > lineStop
				ifTrue: [ runStopIndex := lineStop ].
			self setFont.
			self setStopConditions.
			self placeEmbeddedObject.
			^ false].

	lastChar := text at: lastIndex.
	characterPoint := destX @ destY.
	(( lastChar = Character space and: [ alignment = CharacterScanner justifiedCode ])
		or: [ lastChar = Character tab and: [ lastSpaceOrTabWidth notNil ]])
		ifTrue: [
			lastCharacterWidth := lastSpaceOrTabWidth ].
	characterIndex
		ifNotNil: [
			"If scanning for an index and we've stopped on that index,
			then we back destX off by the width of the character stopped on
			(it will be pointing at the right side of the character) and return"
			runStopIndex = characterIndex
				ifTrue: [
					characterPoint := destX - lastCharacterWidth @ characterPoint y.
					^ true ].
			"Otherwise the requested index was greater than the length of the
			string.  Return string size + 1 as index, indicate further that off the
			string by setting character to nil and the extent to 0."
			lastIndex :=  lastIndex + 1.
			lastCharacterWidth := 0.
			^ true ].

	"Scanning for a point and either off the end of the line or off the end of the string."
	runStopIndex = text size
		ifTrue: [
			"off end of string"
			lastIndex :=  lastIndex + 1.
			lastCharacterWidth := 0.
			^ true ].
	"just off end of line without crossing x"
	lastIndex := lastIndex + 1.
	^true!
paddedSpace
	"When the line is justified, the spaces will not be the same as the font's 
	space character. A padding of extra space must be considered in trying 
	to find which character the cursor is pointing at. Answer whether the 
	scanning has crossed the cursor."

	| pad |
	spaceCount := spaceCount + 1.
	pad := line justifiedPadFor: spaceCount.
	lastSpaceOrTabWidth := spaceWidth + pad.
	(destX + lastSpaceOrTabWidth) >= characterPoint x
		ifTrue: [
			lastCharacterWidth := lastSpaceOrTabWidth.
			^ self crossedX ].
	lastIndex := lastIndex + 1.
	destX := destX + lastSpaceOrTabWidth.
	^ false!
mv 12/7/2022 09:29:09'!
^self].
	article := self first isVowel ifTrue: ['an'] ifFalse: ['a'].
	first := self first asLowercase.
	letter := self size = 1.
	second := letter ifFalse: [self second asLowercase].
	(first = $f and: [letter orNot: ['aeiloru' includes: second]])
		ifTrue: [^'an'].
	first = $u ifTrue: [
		(letter or: ['cks' includes: second]) ifTrue: [^'a'].
		second = $n
			ifTrue: [(self size = 2 or: [self third isVowel]) ifTrue: [^'a']]].
	(first = $e and: [second = $u]) ifTrue: [^'a'].
	^article!
tream.
				aFileStream nextPutAll: ')' ].
		aFileStream nextPutAll: '!!'; newLine ].
	aFileStream newLine!
newFormat = oldClass format ifFalse:[^true]. "yes, it's a format change"
	instVars = oldClass instVarNames ifFalse:[^true]. "yes, it's an iVar change"

	^false
!
(isPointers not and:[instSize > 0]) ifTrue:[
		self error:'A non-pointer class cannot have instance variables'.
		^nil].
	^(self format: instSize 
		variable: isVar 
		words: isWords 
		pointers: isPointers 
		weak: isWeak) + (ccIndex bitShift: 11)!
!
ariable name strings and
	 their integer offsets.  The order is important. Names evaluated later will override the
	 same names occurring earlier."

	| superInstSize |
	(superInstSize := superclass ifNotNil: [superclass instSize] ifNil: [0]) > 0 ifTrue: [
		superclass instVarNamesAndOffsetsDo: aBinaryBlock].
	1 to: self instSize - superInstSize do: [ :i | 
		aBinaryBlock value: (instanceVariables at: i) value: i + superInstSize]!
egory |
	"Useful when modifying an existing class"
	code := class sourceCodeAt: sel.
	code ifNotNil: [
			category := cat
				ifNil: [ class organization categoryOfElement: sel].
			(self methodDict includesKey: sel)
				ifTrue: [code = (self sourceCodeAt: sel) 
							ifFalse: [self error: self name 
										, ' ' 
										, sel 
										, ' will be redefined if you proceed.']].
			self compile: code classified: category]!
onOn: aFileStream excludingExtensions: false!
any clients
	 that expected the old behaviour of answering the array of old instances."
	"ar 7/15/1999: The updating below is possibly dangerous. If there are any
	contexts having an old instance as receiver it might crash the system if
	the new receiver in which the context is executed has a different layout.
	See bottom below for a simple example:
	jmv 1/29/2019: Detect the problem and prevent mutation if that is the case."
	| allInstances newMethod oldMethod selector |
	allInstances := oldClass allInstances.
	allInstances notEmpty ifTrue: [
		Processor 
			processesDo: [ :p | ]
			withStackFramestDo: [ :process :context |
				(context receiver isKindOf: oldClass) ifTrue: [
					selector := context method selector.
					oldMethod := oldClass lookupSelector: selector.
					newMethod := self lookupSelector: selector.
					oldMethod = newMethod ifFalse: [
						MethodInCallStackToBecomeInvalid
							signal: context receiver class name, ' has some instance running #', selector, '. This CompiledMethod would become invalid. Class reshaping aborted.' ]]]
			runningProcessSearchStart: nil.
		self updateInstances: allInstances asArray from: oldClass isMeta: self isMeta ].
	^nil

"This attempts to crash the VM by stepping off the end of an instance.
 As the doctor says, do not do this."
"	| crashingBlock class |
	class := Object subclass: #CrashTestDummy
		instanceVariableNames: 'instVar'
		classVariableNames: ''
		poolDictionaries: ''
		category: 'Crash-Test'.
	class compile:'instVar: value instVar := value'.
	class compile:'crashingBlock ^[instVar]'.
	crashingBlock := (class new) instVar: 42; crashingBlock.
	Object subclass: #CrashTestDummy
		instanceVariableNames: ''
		classVariableNames: ''
		poolDictionaries: ''
		category: 'Crash-Test'.
	crashingBlock value"!
elf inform: 'There are no\instance variables.' withNewLines ].

	allVars := OrderedCollection new.
	lines := OrderedCollection new.
	labelStream := String writeStream.

	(offerAlpha := count > 5)
		ifTrue: [
			lines add: 1.
			allVars add: 'show alphabetically'.
			labelStream nextPutAll: allVars first].
	self withAllSuperclasses reverseDo: [ :class | | vars |
		vars := class instVarNames.
		vars do: [ :var |
			labelStream position = 0 ifFalse: [labelStream newLine].
			labelStream nextPutAll: var.
			allVars add: var].
		vars isEmpty ifFalse: [lines add: allVars size]].
	(lines notEmpty and: [ lines last = allVars size ]) ifTrue: [
		lines removeLast ].  "dispense with inelegant line beneath last item"
	index := (PopUpMenu labels: labelStream contents lines: lines)
startUpWithCaption: 'Instance variables in
', self name.
	index = 0 ifTrue: [^ self].
	(index = 1 and: [offerAlpha]) ifTrue: [
		^ self chooseInstVarAlphabeticallyThenDo: aBlock].
	aBlock value: (allVars at: index)!
!
9/6/2021 12:17:27'!
fileInAnnouncing: 'Installing ', localName, '...' ].
		methodsToRemove do: [ :methodReference | methodReference actualClass removeSelector: methodReference selector ].
		classesToRemove do: [ :className | (Smalltalk at: className) removeFromSystem ].
		currentCS ifNotNil: [ ChangeSet removeChangeSet: currentCS ]].

	newCodePackage hasUnsavedChanges: false; triggerEvent: #dirtyFlagChanged.
	DataStream initialize. "Just in case"
	"If we are installing an already installed package, zap the change set with possible changes done, 
	as they are irrelevant now: we have the package from disk"
	ChangeSet removeChangeSet: (ChangeSet existingOrNewChangeSetForPackage: newCodePackage).
	(Preferences at: #transcriptLogVerbose) ifTrue: [
		Transcript newLine; show: 'Package ', packageName, ' successfully installed'; newLine.
		Smalltalk cleanOutUndeclared.
		Undeclared notEmpty ifTrue: [
			('Undeclared: ', Undeclared printString) print ]].
	^newCodePackage!
ass."

	| aStamp nonMeta |
	aStamp :=  (nonMeta := aClass theNonMetaClass) organization commentStamp.
	^ aStamp
		ifNil:
			[nonMeta name, ' has no class comment']
		ifNotNil:
			['class comment for ', nonMeta name,
				(aStamp = '<historical>'
					ifFalse:
						[' - ', aStamp]
					ifTrue:
						[''])]!
-- -- -- -- -- -- "!
: #showingLineDiffs
		action: #toggleLineDiffing)
			label: 'lineDiffs';
			setBalloonText: self lineDiffButtonHelp!
ser assureSelectionsShow.
		newBrowserWindow
			morphPositionInWorld: self morphPositionInWorld;
			morphExtentInWorld: self morphExtentInWorld.
		self dismissMorph ]!
lf morphExtentInWorld.
		self dismissMorph ]
	!
ltiple-word Bitmap containing a pattern. The inverse is the class message colorFromPixelValue:depth:"
	"Details: For depths of 8 or less, the result is a colorMap index. For depths of 16 and 32, it is a direct color value with 5 or 8 bits per color component."
	"Transparency: The pixel value zero is reserved for transparent. For depths greater than 8 and less than 32 (no Indexed colors, no real alpha), black maps to the darkest possible blue.
	Note that 
		Color transparent class = TranslucentColor
	this special case is handled in TranslucentColor >> #pixelValueForDepth:
	"

	| bitBltFakeBlack val |
	"Most common case"
	"eight bits per component; top 8 bits set to all ones (opaque alpha)"
	d = 32 ifTrue: [
		^ 16rFF000000 bitOr:
			((((self float32SlotAt: 1) * 255.999) truncated bitShift: 16) bitOr:
			((((self float32SlotAt: 2) * 255.999) truncated bitShift: 8) bitOr: 
			(((self float32SlotAt: 3) * 255.999) truncated))) ].

"Faster in 32 bit systems, but slower in 64 bits"
"	d = 32 ifTrue: [
		val := LargePositiveInteger new: 4.
		val at: 3 put: ((self at: 1) * 255.999) truncated.
		val at: 2 put: ((self at: 2)  * 255.999) truncated.
		val at: 1 put: ((self at: 3)  * 255.999) truncated.
		val at: 4 put: 16rFF.
		^ val normalize]."

	d = 8 ifTrue: [^ self closestPixelValue8].  "common case"
	d < 8 ifTrue: [
		d = 4 ifTrue: [^ self closestPixelValue4].
		d = 2 ifTrue: [^ self closestPixelValue2].
		d = 1 ifTrue: [^ self closestPixelValue1]].

	"For the depth 16, pixelValue = 0 means transparent, black is represented as 16r8000 (rgb=0, pixelvalue !!= 0)."
	(d = 16) | (d = 15) ifTrue: [
		"five bits per component; top bits ignored"
		val := ((self red * 31) rounded bitShift: 10) bitOr:
			(((self green * 31) rounded bitShift: 5) bitOr: 
			((self blue * 31) rounded)).
		^ val = 0
			ifTrue: [d = 16 ifTrue: [16r8000] ifFalse: [1]]
			ifFalse: [val]].

	"For the rest of the depths, pixelValue = 0 means transparent, and darkest blue is considered to be black."
	bitBltFakeBlack := 1.  "closest black that is not transparent in RGB - Not for depths <=8 (Indexed) or = 32 (RGBA)"
	d = 12 ifTrue: [  "for indexing a color map with 4 bits per color component"
		val := ((self red * 15) rounded bitShift: 8) bitOr:
			(((self green * 15) rounded bitShift: 4) bitOr: 
			((self blue * 15) rounded)).
		^ val = 0 ifTrue: [bitBltFakeBlack] ifFalse: [val]].

	d = 9 ifTrue: [  "for indexing a color map with 3 bits per color component"
		val := ((self red * 7) rounded bitShift: 6) bitOr:
			(((self green * 7) rounded bitShift: 3) bitOr: 
			((self blue * 7) rounded)).
		^ val = 0 ifTrue: [bitBltFakeBlack] ifFalse: [val]].

	self error: 'unknown pixel depth: ', d printString!
!
ndex dstIndex map |
	CachedColormaps
		ifNil: [CachedColormaps := (1 to: 5) collect: [:i | Array new: 6]].

	srcIndex := sourceDepth highBit min: 5.
	dstIndex := destDepth highBit.

	((CachedColormaps at: srcIndex) at: dstIndex) ifNotNil: [ :m | ^ m ].

	map := self computeColormapFrom: sourceDepth to: destDepth.
	(CachedColormaps at: srcIndex) at: dstIndex put: map.
	^ map!
closure compiler all methods have (or better have) the new
	 format where the penultimate literal is either the method's selector
	 or its properties and the ultimate literal is the class association."
	^true!
isInstalled
	self methodClass ifNotNil:
		[ :class |
		self selector ifNotNil:
			[ :selector |
			^self == (class compiledMethodAt: selector ifAbsent: nil)]].
	^false!
e; newLine;
			nextPutAll: ' numArgs: '; print: self numArgs; newLine;
			nextPutAll: ' numTemps: '; print: self numTemps; newLine;
			nextPutAll: ' numLiterals: '; print: self numLiterals; newLine;
			nextPutAll: ' frameSize: '; print: self frameSize; newLine;
			nextPutAll: ' bytecodeSet: '; nextPutAll: self bytecodeSetName;
			nextPut: $"; newLine
	]!
thodsFor: 'source code management' stamp: 'jmv 3/5/2013 11:03'!
ource code transformations that mean #methodNodeFor: could fail.
	To avoid incopatibility with other parsers, we only send the message methodNodeFor:noPattern:optimizeSpecialSends: 
	when it is false that is the special case needed for the refactorings - Hernan"
	^ (doOptimizeSpecialSends
		ifTrue: [ 	(aClass methodNodeFor: source) ]
		ifFalse: [ 	(aClass methodNodeFor: source noPattern: false optimizeSpecialSends: false) ]) 
			ifNil: [ self decompile ].!
encodeContentFrom: aDictionary

	| encodedTree |
	
	encodedTree := Dictionary new.
	
	aDictionary associations
		do: [ :assoc |
			assoc value class == Dictionary
				ifTrue: [ 
					encodedTree 
						at: assoc key 
						put: (self encodeContentFrom: assoc value) 
				]
				ifFalse: [ 
					encodedTree 
						at: assoc key
						put: count.
					count := count + 1.
					payload add: assoc value storeString asByteArray base64Encoded
				]
		].

	^ encodedTree associations collect: [ :assoc | 
		{ assoc key . assoc value }
	]!
tamp: 'sqr 5/21/2020 18:54:07'!
tion
	 whatIsAPrimitive.  Override the default primitive to give latitude to
	 the VM in context management."

	<primitive: 211>
	index isInteger ifTrue:
		[self errorSubscriptBounds: index].
	index isNumber
		ifTrue: [^self at: index asInteger put: value]
		ifFalse: [self errorNonIntegerIndex]!
methodClass 
	"Answer the class in which the receiver's method was found."
	
	^self method methodClass ifNil: [self objectClass: self receiver].!
trm nextPutAll: 
				((self tempAt: index) printStringLimitedTo: (sizeLimit -3 -title size max: 1)).
			strm newLine ]].!
2009 14:21'!
r: 'mirror primitives' stamp: 'eem 4/8/2009 19:30'!
et: `-7@ -7`) withMask`.!
copy: (p extent: ext) from: `0@0` in: aForm rule: Form under].
	cursor setMaskForm: mask.
	cursor offset: ((aForm offset - (1@1)) max: ext negated).
	^ cursor!
nObject].
	internalObject := anObject comeFullyUpOnReload: self.
	^ self maybeBeginReference: internalObject.!
cantRef	"relative"
		ifTrue:  [nil]
		ifFalse: [self objectAt: referencePosition]		"relative pos"!
commentStamp: '<historical>' prior: 0!
dle)]].
			element = 3
				ifTrue: [(formatArray at: 6)
							= 1
						ifTrue: [gregorian last printOn: aStream]
						ifFalse: [aStream
								nextPutAll: ((gregorian last \\ 100) printString
										padded: #left
										to: 2
										with: $0)]].
			i < 3
				ifTrue: [(formatArray at: 4)
							~= 0
						ifTrue: [aStream nextPut: (formatArray at: 4) asCharacter]]]
!
protocol' stamp: 'jmv 8/9/2010 11:50'!
daysInYear
	"Answer the number of days in the month represented by the receiver."

	^ start daysInYear!
class methodsFor: 'smalltalk-80' stamp: 'brp 7/1/2003 13:37'!
ak1.2 6/29/1997 10:40:55'!
ondCount
!
scheduled, e.g., being waited on"
	beingWaitedOn := aBool!
e before the associated semaphore was signaled?"
	^expired!
many large collections of the same length will want to refine this behavior."

	| hash |
	hash := self emptyCollectionHash.
	self size <= 10 ifTrue: [
		self associationsDo: [ :association | hash := hash bitXor: association hash ]].
	^ hash bitXor: self size hash!
j: j.
	mij = self class d ifTrue: [
		cij := self lcsAt: i - 1 at: j - 1.
		pair := Array with: i with: j.
		^cij collect: [:s | s copyWith: pair]].
	mij = self class u ifTrue: [^self lcsAt: i - 1 at: j].
	mij = self class l ifTrue: [^self lcsAt: i at: j - 1].
	mij = self class ul ifTrue: [
		left := self lcsAt: i at: j - 1.
		up := self lcsAt: i - 1 at: j.
		^left copy addAll: up; yourself].
	self assert: false!
Directory: self pathName.
	self invalidateChildren!
the VM didn't support defer updates, even when it does"
	"true ifTrue: [ ^nil ]."

	"Note: If we disable VM defer updates (with this &false), but answer notNil, the the Morphic workaround is not used,
	and you get a lot of flicking."
	^self primitiveDeferUpdates: aBoolean "& false"!
int x asInteger y: aPoint y asInteger!
nd for ', selectedFileEntry name ].
	menu := self createMenuFor: options.
		
	selectionIndex := menu startUpWithCaption: 'Select action for ', selectedFileEntry name.
	
	selectionIndex = 0 ifTrue: [ ^self ].
	(options isInBounds: selectionIndex) ifTrue: [ ^self performService: (options at: selectionIndex) ].
	"The only available option is 'stop here'. This could change if #createMenuFor: changes - Hernan"
	stopHereBlock value
	
!
Editor methodsFor: 'nonediting/nontyping keys' stamp: 'AY 3/14/2019 16:26:36'!
r: 'source mapping' stamp: 'HAW 7/25/2023 19:25:22'!
le, Temporary Location, Illegal, Literal Variable) [jj] #kkkkkk
	 130 		10000010 jjkkkkkk 	Pop and Store (Receiver Variable, Temporary Location, Illegal, Literal Variable) [jj] #kkkkkk"

	| byte |
	byte := method at: pc.
	^byte >= 104
	  and: [byte <= 111
			or: [byte <= 130 and: [byte >= 129 and: [(method at: pc + 1) >> 6 = 1]]]]!
lf initializeRenamedNewMessageArguments!
sourceClass

	^ methodToExtractFrom methodClass!
' ]]
		ifFalse: [ 'date' ].
	^  (SimpleServiceEntry 
			provider: self 
			label: 'by date' 
			selector: #sortByDate 
			description: 'sort entries by date'
			icon: #sendReceiveIcon)
		extraSelector: #sortingByDate;
		buttonLabel: buttonLabel!
always precede files"
				xx isDirectory ] ]!
dWindowRadius ]
		ifFalse: [ super drawOn: aCanvas ]!
ifTrue: ["BEWARE: do not convert a NaN to infinity due to truncatedBits"
					mantissa := 1]]
			ifFalse: [mantissa := 0]].
		
	"Encode the word"
	destWord := (sign bitOr: ((exponent max: 0) bitShift: 23)) bitOr: mantissa.
	^ destWord!
| size index0 index1 weight0 weight1 |

	size := self size.
	index0 := floatIndex truncated. 		"Could be #floor. But as we only care for values >=1, it is the same. But faster."

	weight1 := floatIndex - index0.
	weight0 := 1.0 - weight1.

	index1 := (index0 = size and: [ weight1 = 0.0 ]) 			"Avoid the invalid access if this was true, but don't make it slower the most common, general case."
		ifFalse: [ index0 + 1 ]
		ifTrue: [ index0 ].

	"/* perform interpolation */"
	^ (weight0 * (self at: index0)) + (weight1 * (self at: index1))!
s now."

	aStringOrNil ifNotNil: [DefaultFamilyName := aStringOrNil].
	aNumberOrNil ifNotNil: [DefaultPointSize := aNumberOrNil].!
:37'!
is form.
	pixelValueAt: x@y				The encoded color.  The encoding depends on the depth.
!
17/2001 15:50'!
'!
dispatch"

	^destForm colormapIfNeededFrom: self!
MouseButton1Pressed] whileTrue:
			[i := i + 1.
			(Array with: 0@1 with: 0@ -1 with: 1@0 with: -1@0) do:
				[:d | form copyBits: bb from: form at: d
					clippingBox: bb rule: Form reverse ].
			form displayAt: rect topLeft.
			i+2\\size < 4 ifTrue: [(Delay forMilliseconds: 300) wait]].
		(form magnify: form boundingBox by: 2@2) displayAt: rect topRight + (2@0).
		Sensor waitButton].!
."
	d abs = depth abs ifTrue: [
		answer := self copy.
		answer swapEndianness.
		BitBlt swapBytesIn32BitWords: answer bits.
		^ answer ].
	^ super asFormOfDepth: d!
mv 1/5/2022 12:22:20'!
sFor: 'initialization' stamp: 'jmv 12/22/2020 16:57:41'!
lick:, or drag: methods." 

	mouseClickState :=
		MouseClickState new
			client: aMorph
			drag: nil
			click: clkSel
			clickAndHalf: nil 
			dblClick: dblClkSel
			dblClickAndHalf: nil
			tripleClick: nil
			event: evt
			sendMouseButton2Activity: false!
ickState new
			client: aMorph
			drag: nil
			click: clkSel
			clickAndHalf: nil
			dblClick: nil
			dblClickAndHalf: nil
			tripleClick: nil
			event: evt
			sendMouseButton2Activity: (Preferences at: #tapAndHoldEmulatesButton2).

	"It seems the Mac VM may occasionally lose button up events triggering bogus activations.
	Hence Preferences tapAndHoldEmulatesButton2"!
lBounds answer |
	fullBounds := self displayFullBoundsForPatch intersect: (`0@0` extent: aCanvas extent).
	savedPatch := aCanvas savePatch: savedPatch bounds: fullBounds.
	answer := fullBounds.
	prevFullBounds ifNotNil: [ answer := answer quickMerge: prevFullBounds ].
	prevFullBounds := fullBounds.
	^answer!
startEventDispatch: aMorphicEvent

	owner ifNil: [ ^ self ].
	aMorphicEvent startDispatchFrom: self!
ToBack: false.
		self newKeyboardFocus: m ]!
ndow) and: [ m isReallyVisible ]]!
w)
		setCollection: aCollection asArray copy tally: aCollection size;
		reSort;
		yourself!
.
	aKeyboardEvent isPageUp ifTrue: [ ^ self navigateOnePageUp ].
	aKeyboardEvent isPageDown ifTrue: [ ^ self navigateOnePageDown ].
	^ nil!
vate' stamp: 'jmv 7/6/2023 11:38:56'!
d a rename, it will still be added to the collection.
	This method also adds the new name to the map that tracks temporaries
	names in scope for the requested method or block node across the whole refactoring - Fernando"

	| alreadyDeclaredTemporaries newTemporaries |

	newTemporaries := OrderedCollection new: temporariesToDeclare size.
	alreadyDeclaredTemporaries := self declaredTemporariesFor: aMethodOrBlockNode ofSender: aSenderMethod.
	temporariesToDeclare do: [:temporary |
		| finalTemporaryName index |
		finalTemporaryName := temporary name.
		index := 1.
		[alreadyDeclaredTemporaries includes: finalTemporaryName] whileTrue: [
			finalTemporaryName := temporary name, index asString.
			index := index + 1.
		].
		alreadyDeclaredTemporaries add: finalTemporaryName.
		newTemporaries add: (temporary -> finalTemporaryName).
	].

	^newTemporaries.!
lse: [expression].

	^(aMessageNodeReference compiledMethod sourceCode copyFrom: enclosingNodeSourceRange first to: enclosingNodeSourceRange last)
		copyReplacing: (Array with: ((normalizedMessageSendRange -> expression)))!
createAndApplyRefactoringWhenNoSendersAndOneImplementor: anImplementor

	implementors := Array with: anImplementor.
	messageSends := #().
	shouldShowChanges := false.

	self createAndApplyRefactoring !
parentNode isUnaryMessageSend ifTrue: [self replaceRange: range withParenthesisedExpression: anExpression ].
				((parentNode isInfix) or: parentNode isKeywordMessageSend) ifTrue: [(self tempNodeIsReceiverOrArgumentOfReceiverWhenUsedIn: range)
					ifTrue: [self replaceRange: range withParenthesisedExpression: anExpression]
					ifFalse: [self replaceRange: range withExpression: anExpression ]]
			]
			ifFalse: [self replaceRange: range withExpression: anExpression.]
	].	!
stamp: 'FB 12/28/2021 20:02:39'!
ary variable is not related to the selected interval"
		tempToInline := anEditor wordAt: aSelectionInterval first.
		usageInterval := aSelectionInterval.
	].

	anEditor
		withNodeUnderCursorDo: [:aNode | | methodNode sourceRanges |
			methodNode := aMethodToRefactor notOptimizedMethodNode.
			sourceRanges := methodNode completeSourceRanges.
			(aNode isVariableNode and: [methodNode argumentNames noneSatisfy: [:argument | argument = aNode name]])
				ifTrue: [
					tempToInline := aNode name.
					usageInterval := self findSourceRangeOfNode: aNode containingIndex: anEditor startIndex using: sourceRanges.
				]
				ifFalse: [ | assignmentNodeAndRange |
					assignmentNodeAndRange := self searchAssignmentInStatementContaining: aSelectionInterval first
						in: methodNode.
					assignmentNodeAndRange 	ifNil: [noTempFoundBlock value].
					tempToInline ifNil: [
						tempToInline := assignmentNodeAndRange key variable name.
						usageInterval := self findLeftmostSourceRangeOfNode: assignmentNodeAndRange key variable
							inside: assignmentNodeAndRange value using: sourceRanges.
					]
				]
		]
		ifAbsent: [
			noTempFoundBlock value.
		].

	^self new initializeOn: anEditor codeProvider forTemporary: tempToInline
		at: usageInterval of: aMethodToRefactor !
embeddedMorphs do: [ :each|
		each owner == self ifFalse: [
			self addMorphFront: each.
			each hide "Show it only when properly located"]].
	(owner is: #ScrollPane) ifTrue: [
		owner possiblyChanged ]!
joystick with the given index in the range [1..16]. Returns zero if the index does not correspond to a currently installed joystick."

	<primitive: 'primitiveReadJoystick' module: 'JoystickTabletPlugin'>
	^ 0

	!

$a isLowercase!

$a isLetter!

$A isLetter!

$4 isLetter!

$' isLetter!
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 16:32:31' prior: 16826084!
asRot13
	(self isLetter)not ifTrue:[^self].
	($a = self) ifTrue:[^$n].
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m].
	^$z! !

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 16:32:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:32:37'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:32:37'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:32:37'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:32:37'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 16:32:37'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:32:37'!
test06CharOnTheUpperRangeDoesntChange
	
	self assert: ${ equals: ${ asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 16:32:37'!
PASSED!

!methodRemoval: TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 16:32:37'!
test06CharOnTheUpperRangeDoesntChange
	
	self assert: ${ equals: ${ asRot13
	!
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 16:33:24' prior: 50593439!
asRot13
	(self = $`) ifTrue:[^$`].
	($a = self) ifTrue:[^$n].
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m].
	^$z! !

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 16:33:27'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:33:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:33:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:33:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:33:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 16:33:29'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:33:29'!
test06CharOnTheUpperRangeDoesntChange
	
	self assert: ${ equals: ${ asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 16:33:29'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 16:33:29'!
test06CharOnTheUpperRangeDoesntChange
	
	self assert: ${ equals: ${ asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:33:29'!
test06CharOnTheUpperRangeDoesntChange
	
	self assert: ${ equals: ${ asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 16:33:29'!
FAILURE!
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 16:36:49' prior: 50593485!
asRot13
	(self = ${) ifTrue:[^${].
	(self = $`) ifTrue:[^$`].
	($a = self) ifTrue:[^$n].
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m].
	^$z! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:36:51'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:36:51'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:36:51'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:36:51'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 16:36:51'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 16:36:51'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:36:51'!
test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $N equals: $A asRot13.
	self assert: $Z equals: $M asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:36:51'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:36:51'!
test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $N equals: $A asRot13.
	self assert: $Z equals: $M asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:36:51'!
test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $N equals: $A asRot13.
	self assert: $Z equals: $M asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:36:51'!
FAILURE!
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 16:37:32' prior: 50593540!
asRot13
	(self = $A) ifTrue:[^$N].
	(self = $M) ifTrue:[^$Z].
	(self = ${) ifTrue:[^${].
	(self = $`) ifTrue:[^$`].
	($a = self) ifTrue:[^$n].
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m].
	^$z! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:37:35'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:37:35'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:37:35'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:37:35'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 16:37:35'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 16:37:35'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:37:35'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:37:35'!
test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $A equals: $N asRot13.
	self assert: $M equals: $Z asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:37:35'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:37:35'!
test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $A equals: $N asRot13.
	self assert: $M equals: $Z asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:37:35'!
test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $A equals: $N asRot13.
	self assert: $M equals: $Z asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:37:35'!
FAILURE!
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 16:38:02' prior: 50593605!
asRot13
	(self = $A) ifTrue:[^$N].
	(self = $M) ifTrue:[^$Z].
	(self = $N) ifTrue:[^$A].
	(self = $Z) ifTrue:[^$M].
	(self = ${) ifTrue:[^${].
	(self = $`) ifTrue:[^$`].
	($a = self) ifTrue:[^$n].
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m].
	^$z! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:38:04'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:38:04'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:38:04'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:38:04'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 16:38:04'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 16:38:04'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:38:04'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:38:04'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:38:04'!
test09TheEmptyStringDoesntChange
	
	self assert: '' equals: '' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 16:38:04'!
ERROR!

!methodRemoval: TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 16:38:04'!
test09TheEmptyStringDoesntChange
	
	self assert: '' equals: '' asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:38:04'!
test09TheEmptyStringDoesntChange
	
	self assert: '' equals: '' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 16:38:04'!
ERROR!
!String methodsFor: 'converting' stamp: 'I 5/5/2024 16:45:11'!
asRot
	^''! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:45:14'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:45:14'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:45:14'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:45:14'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 16:45:14'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 16:45:14'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:45:14'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:45:14'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 16:45:14'!
ERROR!
!String methodsFor: 'converting' stamp: 'I 5/5/2024 16:45:36'!
asRot13
	^''! !

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 16:45:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:45:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:45:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:45:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:45:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 16:45:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 16:45:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:45:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:45:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 16:45:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:45:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:45:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:45:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:45:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 16:45:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 16:45:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:45:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:45:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 16:45:41'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:45:41'!
test10CorrectlyEncodesAOneCharString
	
	self assert: 'n' equals: 'a' asRot13.
	self assert: 'Z' equals: 'M' asRot13.
	self assert: 'a' equals: 'n' asRot13.
	self assert: '{' equals: '{' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 16:45:41'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 16:45:41'!
test10CorrectlyEncodesAOneCharString
	
	self assert: 'n' equals: 'a' asRot13.
	self assert: 'Z' equals: 'M' asRot13.
	self assert: 'a' equals: 'n' asRot13.
	self assert: '{' equals: '{' asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:45:41'!
test10CorrectlyEncodesAOneCharString
	
	self assert: 'n' equals: 'a' asRot13.
	self assert: 'Z' equals: 'M' asRot13.
	self assert: 'a' equals: 'n' asRot13.
	self assert: '{' equals: '{' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 16:45:41'!
FAILURE!
!String methodsFor: 'converting' stamp: 'I 5/5/2024 16:47:13' prior: 50593781!
asRot13
	(self = 'a') ifTrue:[^'n'].
	(self = 'M') ifTrue:[^'Z'].
	(self = 'n') ifTrue:[^'a'].
	(self = '{') ifTrue:[^'{'].
	^''! !

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 16:47:17'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:47:19'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:47:19'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:47:19'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:47:19'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 16:47:19'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 16:47:19'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:47:19'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:47:19'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 16:47:19'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 16:47:19'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:47:19'!
test11CorrectlyEncodesATwoCharString
	
	self assert: 'nm' equals: 'az' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 16:47:19'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 16:47:19'!
test11CorrectlyEncodesATwoCharString
	
	self assert: 'nm' equals: 'az' asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:47:19'!
test11CorrectlyEncodesATwoCharString
	
	self assert: 'nm' equals: 'az' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 16:47:19'!
FAILURE!
!String methodsFor: 'converting' stamp: 'I 5/5/2024 16:47:35' prior: 50593896!
asRot13
	(self = 'a') ifTrue:[^'n'].
	(self = 'M') ifTrue:[^'Z'].
	(self = 'n') ifTrue:[^'a'].
	(self = '{') ifTrue:[^'{'].
	(self = 'az') ifTrue:[^'nm'].
	^''! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:47:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:47:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:47:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:47:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 16:47:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 16:47:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:47:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:47:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 16:47:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 16:47:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 16:47:38'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:47:38'!
test12CorrectlyEncodesMoreThanTwoCharString
	
	self assert: 'uByN!!' equals: 'hOlA!!' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 16:47:38'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 16:47:38'!
test12CorrectlyEncodesMoreThanTwoCharString
	
	self assert: 'uByN!!' equals: 'hOlA!!' asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:47:38'!
test12CorrectlyEncodesMoreThanTwoCharString
	
	self assert: 'uByN!!' equals: 'hOlA!!' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 16:47:38'!
FAILURE!
!String methodsFor: 'converting' stamp: 'I 5/5/2024 16:48:06' prior: 50593970!
asRot13
	(self = 'a') ifTrue:[^'n'].
	(self = 'M') ifTrue:[^'Z'].
	(self = 'n') ifTrue:[^'a'].
	(self = '{') ifTrue:[^'{'].
	(self = 'az') ifTrue:[^'nm'].
	(self = 'hOlA') ifTrue:[^'uByN'].
	^''! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:48:08'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:48:08'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:48:08'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:48:08'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 16:48:08'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 16:48:08'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:48:08'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:48:08'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 16:48:08'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 16:48:08'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 16:48:08'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 16:48:08'!
FAILURE!
!String methodsFor: 'converting' stamp: 'I 5/5/2024 16:49:07' prior: 50594047!
asRot13
	(self = 'a') ifTrue:[^'n'].
	(self = 'M') ifTrue:[^'Z'].
	(self = 'n') ifTrue:[^'a'].
	(self = '{') ifTrue:[^'{'].
	(self = 'az') ifTrue:[^'nm'].
	(self = 'hOlA!!') ifTrue:[^'uByN!!'].
	^''! !

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 16:49:09'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:49:09'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:49:09'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:49:09'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:49:09'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 16:49:09'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 16:49:09'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:49:09'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:49:09'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 16:49:09'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 16:49:09'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 16:49:09'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 16:49:09'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:49:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:49:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:49:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:49:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 16:49:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 16:49:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 16:49:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 16:49:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 16:49:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 16:49:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 16:49:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 16:49:11'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:49:11'!
testExtraToCheckGeneralizationOnKata
		
	self assert: 'Ju3er j3 4e3 t01at j3 q0ag a3rq e04q$...' equals: 'Wh3re w3 4r3 g01ng w3 d0nt n3ed r04d$...' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'I 5/5/2024 16:49:11'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'I 5/5/2024 16:49:49'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'I 5/5/2024 16:53:51'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'I 5/5/2024 16:53:51'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'I 5/5/2024 16:54:10'!
FAILURE!

$a asciiValue!

$a asciiValue + 1!

97 asCharacter!

98 asCharacter !

129 asCharacter !

$z asciiValue !

$A asciiValue !

$Z asciiValue  !

$Z asciiValue  !

$M asciiValue!

$A asciiValue !

$a asciiValue  !

$z asciiValue   !

$m asciiValue!
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 17:08:16' prior: 50593676!
asRot13
	(self isUppercase) ifTrue:[
		^((self asciiValue + 13 % 90)+64) asCharacter].
	(self isLowercase) ifTrue:[
		^((self asciiValue + 13 % 122)+96) asCharacter].
	(self isLetter) not ifTrue:[^self].
	(self = $A) ifTrue:[^$N].
	(self = $M) ifTrue:[^$Z].
	(self = $N) ifTrue:[^$A].
	(self = $Z) ifTrue:[^$M].
	(self = ${) ifTrue:[^${].
	(self = $`) ifTrue:[^$`].
	($a = self) ifTrue:[^$n].
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m].
	^$z! !

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:08:19'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:08:21'!
ERROR!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:08:21'!
ERROR!

----STARTUP---- (5 May 2024 17:10:01) as /home/ivan/Documents/Facu/Inge 1/linux64/linux64/CuisUniversity-6169.image!

!Character methodsFor: 'converting' stamp: 'I 5/5/2024 16:22:25'!
asRot13
	($a = self) ifTrue:[^$n].! !
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:23:02'!
test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $z equals: $m asRot13
	! !

!methodRemoval: TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:10:08'!
test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $z equals: $m asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:23:02'!
test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $z equals: $m asRot13
	! !
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 16:23:51' prior: 50594276!
asRot13
	($a = self) ifTrue:[^$n].
	^$z! !
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:23:56'!
test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $a equals: $n asRot13
	! !

!methodRemoval: TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:10:08'!
test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $a equals: $n asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:23:56'!
test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $a equals: $n asRot13
	! !
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 16:25:25' prior: 50594300!
asRot13
	($a = self) ifTrue:[^$n].
	($n = self) ifTrue:[^$a].
	^$z! !
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:25:32'!
test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $m equals: $z asRot13
	! !

!methodRemoval: TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:10:08'!
test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $m equals: $z asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:25:32'!
test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $m equals: $z asRot13
	! !
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 16:25:48' prior: 50594324!
asRot13
	($a = self) ifTrue:[^$n].
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m].
	^$z! !
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:25:52'!
test05CharOnTheBelowRangeDoesntChange
	
	self assert: $` equals: $` asRot13
	! !

!methodRemoval: TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:10:08'!
test05CharOnTheBelowRangeDoesntChange
	
	self assert: $` equals: $` asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:25:52'!
test05CharOnTheBelowRangeDoesntChange
	
	self assert: $` equals: $` asRot13
	! !
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 16:28:55' prior: 50594349!
asRot13
	(((self between: $a and: $z) or: [self between: $A and: $Z])not) ifTrue:[^self].
	($a = self) ifTrue:[^$n].
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m].
	^$z! !
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 16:32:31' prior: 50594372!
asRot13
	(self isLetter)not ifTrue:[^self].
	($a = self) ifTrue:[^$n].
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m].
	^$z! !
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:32:37'!
test06CharOnTheUpperRangeDoesntChange
	
	self assert: ${ equals: ${ asRot13
	! !

!methodRemoval: TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:10:08'!
test06CharOnTheUpperRangeDoesntChange
	
	self assert: ${ equals: ${ asRot13
	!
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 16:33:24' prior: 50594381!
asRot13
	(self = $`) ifTrue:[^$`].
	($a = self) ifTrue:[^$n].
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m].
	^$z! !
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:33:29'!
test06CharOnTheUpperRangeDoesntChange
	
	self assert: ${ equals: ${ asRot13
	! !

!methodRemoval: TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:10:08'!
test06CharOnTheUpperRangeDoesntChange
	
	self assert: ${ equals: ${ asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:33:29'!
test06CharOnTheUpperRangeDoesntChange
	
	self assert: ${ equals: ${ asRot13
	! !
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 16:36:49' prior: 50594399!
asRot13
	(self = ${) ifTrue:[^${].
	(self = $`) ifTrue:[^$`].
	($a = self) ifTrue:[^$n].
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m].
	^$z! !
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:36:51'!
test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $N equals: $A asRot13.
	self assert: $Z equals: $M asRot13
	! !

!methodRemoval: TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:10:08'!
test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $N equals: $A asRot13.
	self assert: $Z equals: $M asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:36:51'!
test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $N equals: $A asRot13.
	self assert: $Z equals: $M asRot13
	! !
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 16:37:32' prior: 50594423!
asRot13
	(self = $A) ifTrue:[^$N].
	(self = $M) ifTrue:[^$Z].
	(self = ${) ifTrue:[^${].
	(self = $`) ifTrue:[^$`].
	($a = self) ifTrue:[^$n].
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m].
	^$z! !
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:37:35'!
test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $A equals: $N asRot13.
	self assert: $M equals: $Z asRot13
	! !

!methodRemoval: TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:10:08'!
test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $A equals: $N asRot13.
	self assert: $M equals: $Z asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:37:35'!
test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $A equals: $N asRot13.
	self assert: $M equals: $Z asRot13
	! !
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 16:38:02' prior: 50594454!
asRot13
	(self = $A) ifTrue:[^$N].
	(self = $M) ifTrue:[^$Z].
	(self = $N) ifTrue:[^$A].
	(self = $Z) ifTrue:[^$M].
	(self = ${) ifTrue:[^${].
	(self = $`) ifTrue:[^$`].
	($a = self) ifTrue:[^$n].
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m].
	^$z! !
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:38:04'!
test09TheEmptyStringDoesntChange
	
	self assert: '' equals: '' asRot13
	! !

!methodRemoval: TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 17:10:08'!
test09TheEmptyStringDoesntChange
	
	self assert: '' equals: '' asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:38:04'!
test09TheEmptyStringDoesntChange
	
	self assert: '' equals: '' asRot13
	! !
!String methodsFor: 'converting' stamp: 'I 5/5/2024 16:45:11'!
asRot
	^''! !
!String methodsFor: 'converting' stamp: 'I 5/5/2024 16:45:36'!
asRot13
	^''! !
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:45:41'!
test10CorrectlyEncodesAOneCharString
	
	self assert: 'n' equals: 'a' asRot13.
	self assert: 'Z' equals: 'M' asRot13.
	self assert: 'a' equals: 'n' asRot13.
	self assert: '{' equals: '{' asRot13
	! !

!methodRemoval: TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 17:10:08'!
test10CorrectlyEncodesAOneCharString
	
	self assert: 'n' equals: 'a' asRot13.
	self assert: 'Z' equals: 'M' asRot13.
	self assert: 'a' equals: 'n' asRot13.
	self assert: '{' equals: '{' asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:45:41'!
test10CorrectlyEncodesAOneCharString
	
	self assert: 'n' equals: 'a' asRot13.
	self assert: 'Z' equals: 'M' asRot13.
	self assert: 'a' equals: 'n' asRot13.
	self assert: '{' equals: '{' asRot13
	! !
!String methodsFor: 'converting' stamp: 'I 5/5/2024 16:47:13' prior: 50594517!
asRot13
	(self = 'a') ifTrue:[^'n'].
	(self = 'M') ifTrue:[^'Z'].
	(self = 'n') ifTrue:[^'a'].
	(self = '{') ifTrue:[^'{'].
	^''! !
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:47:19'!
test11CorrectlyEncodesATwoCharString
	
	self assert: 'nm' equals: 'az' asRot13
	! !

!methodRemoval: TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 17:10:08'!
test11CorrectlyEncodesATwoCharString
	
	self assert: 'nm' equals: 'az' asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:47:19'!
test11CorrectlyEncodesATwoCharString
	
	self assert: 'nm' equals: 'az' asRot13
	! !
!String methodsFor: 'converting' stamp: 'I 5/5/2024 16:47:35' prior: 50594547!
asRot13
	(self = 'a') ifTrue:[^'n'].
	(self = 'M') ifTrue:[^'Z'].
	(self = 'n') ifTrue:[^'a'].
	(self = '{') ifTrue:[^'{'].
	(self = 'az') ifTrue:[^'nm'].
	^''! !
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:47:38'!
test12CorrectlyEncodesMoreThanTwoCharString
	
	self assert: 'uByN!!' equals: 'hOlA!!' asRot13
	! !

!methodRemoval: TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 17:10:08'!
test12CorrectlyEncodesMoreThanTwoCharString
	
	self assert: 'uByN!!' equals: 'hOlA!!' asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:47:38'!
test12CorrectlyEncodesMoreThanTwoCharString
	
	self assert: 'uByN!!' equals: 'hOlA!!' asRot13
	! !
!String methodsFor: 'converting' stamp: 'I 5/5/2024 16:48:06' prior: 50594571!
asRot13
	(self = 'a') ifTrue:[^'n'].
	(self = 'M') ifTrue:[^'Z'].
	(self = 'n') ifTrue:[^'a'].
	(self = '{') ifTrue:[^'{'].
	(self = 'az') ifTrue:[^'nm'].
	(self = 'hOlA') ifTrue:[^'uByN'].
	^''! !
!String methodsFor: 'converting' stamp: 'I 5/5/2024 16:49:07' prior: 50594597!
asRot13
	(self = 'a') ifTrue:[^'n'].
	(self = 'M') ifTrue:[^'Z'].
	(self = 'n') ifTrue:[^'a'].
	(self = '{') ifTrue:[^'{'].
	(self = 'az') ifTrue:[^'nm'].
	(self = 'hOlA!!') ifTrue:[^'uByN!!'].
	^''! !
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 16:49:11'!
testExtraToCheckGeneralizationOnKata
		
	self assert: 'Ju3er j3 4e3 t01at j3 q0ag a3rq e04q$...' equals: 'Wh3re w3 4r3 g01ng w3 d0nt n3ed r04d$...' asRot13
	! !
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 17:08:16' prior: 50594487!
asRot13
	(self isUppercase) ifTrue:[
		^((self asciiValue + 13 % 90)+64) asCharacter].
	(self isLowercase) ifTrue:[
		^((self asciiValue + 13 % 122)+96) asCharacter].
	(self isLetter) not ifTrue:[^self].
	(self = $A) ifTrue:[^$N].
	(self = $M) ifTrue:[^$Z].
	(self = $N) ifTrue:[^$A].
	(self = $Z) ifTrue:[^$M].
	(self = ${) ifTrue:[^${].
	(self = $`) ifTrue:[^$`].
	($a = self) ifTrue:[^$n].
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m].
	^$z! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:10:19'!
ERROR!

95 asCharacter!

97 asCharacter!

170 % 120!

170 / 120 !

170\\120!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:12:00'!
ERROR!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:12:00'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:12:00'!
ERROR!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:12:00'!
ERROR!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:12:00'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:12:00'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:12:00'!
ERROR!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:12:00'!
ERROR!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 17:12:00'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 17:12:00'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 17:12:00'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 17:12:00'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'I 5/5/2024 17:12:00'!
FAILURE!
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 17:12:55' prior: 50594623!
asRot13
	(self isUppercase) ifTrue:[
		^((self asciiValue + 13 \\ 90)+64) asCharacter].
	(self isLowercase) ifTrue:[
		^((self asciiValue + 13 \\ 122)+96) asCharacter].
	(self isLetter) not ifTrue:[^self].
	(self = $A) ifTrue:[^$N].
	(self = $M) ifTrue:[^$Z].
	(self = $N) ifTrue:[^$A].
	(self = $Z) ifTrue:[^$M].
	(self = ${) ifTrue:[^${].
	(self = $`) ifTrue:[^$`].
	($a = self) ifTrue:[^$n].
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m].
	^$z! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:12:58'!
FAILURE!
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 17:13:34' prior: 50594697!
asRot13
	(self isUppercase) ifTrue:[
		^((self asciiValue + 13 \\ 90)+64) asCharacter].
	(self isLowercase) ifTrue:[
		^(((self asciiValue + 13) \\ 122)+96) asCharacter].
	(self isLetter) not ifTrue:[^self].
	(self = $A) ifTrue:[^$N].
	(self = $M) ifTrue:[^$Z].
	(self = $N) ifTrue:[^$A].
	(self = $Z) ifTrue:[^$M].
	(self = ${) ifTrue:[^${].
	(self = $`) ifTrue:[^$`].
	($a = self) ifTrue:[^$n].
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m].
	^$z! !
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 17:13:41' prior: 50594719!
asRot13
	(self isUppercase) ifTrue:[
		^(((self asciiValue + 13) \\ 90)+64) asCharacter].
	(self isLowercase) ifTrue:[
		^(((self asciiValue + 13) \\ 122)+96) asCharacter].
	(self isLetter) not ifTrue:[^self].
	(self = $A) ifTrue:[^$N].
	(self = $M) ifTrue:[^$Z].
	(self = $N) ifTrue:[^$A].
	(self = $Z) ifTrue:[^$M].
	(self = ${) ifTrue:[^${].
	(self = $`) ifTrue:[^$`].
	($a = self) ifTrue:[^$n].
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m].
	^$z! !
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 17:15:08' prior: 50594736!
asRot13
	(self isUppercase) ifTrue:[|valorAscii|
		valorAscii := self asciiValue.
		^(((valorAscii+ 13) \\ 90)+64) asCharacter].
	(self isLowercase) ifTrue:[
		|valorAscii|
		valorAscii := self asciiValue.
		^(((valorAscii + 13) \\ 122)+96) asCharacter].
	(self isLetter) not ifTrue:[^self].
	(self = $A) ifTrue:[^$N].
	(self = $M) ifTrue:[^$Z].
	(self = $N) ifTrue:[^$A].
	(self = $Z) ifTrue:[^$M].
	(self = ${) ifTrue:[^${].
	(self = $`) ifTrue:[^$`].
	($a = self) ifTrue:[^$n].
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m].
	^$z! !

$a asciiValue!

$A asciiValue !
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 17:21:29' prior: 50594753!
asRot13
	(self isUppercase) ifTrue:[|valorAscii|
		valorAscii := self asciiValue.
		^(((valorAscii - 65 + 13) \\ 90)+65) asCharacter].
	(self isLowercase) ifTrue:[
		|valorAscii|
		valorAscii := self asciiValue.
		^(((valorAscii - 97 + 13) \\ 26)+97) asCharacter].
	(self isLetter) not ifTrue:[^self].
	(self = $A) ifTrue:[^$N].
	(self = $M) ifTrue:[^$Z].
	(self = $N) ifTrue:[^$A].
	(self = $Z) ifTrue:[^$M].
	(self = ${) ifTrue:[^${].
	(self = $`) ifTrue:[^$`].
	($a = self) ifTrue:[^$n].
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m].
	^$z! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:22:00'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:22:02'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:22:03'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:22:03'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:22:03'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:22:03'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:22:03'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:22:03'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:22:03'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:22:03'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 17:22:03'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 17:22:03'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 17:22:03'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 17:22:03'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'I 5/5/2024 17:22:03'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:22:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:22:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:22:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:22:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:22:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:22:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:22:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:22:13'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 17:22:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 17:22:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 17:22:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 17:22:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'I 5/5/2024 17:22:13'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 17:22:20'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 17:22:22'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 17:22:25'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:22:27'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:22:27'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:22:27'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:22:27'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:22:27'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:22:27'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:22:27'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:22:27'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 17:22:27'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 17:22:27'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 17:22:27'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 17:22:27'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'I 5/5/2024 17:22:27'!
FAILURE!
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 17:22:48' prior: 50594774!
asRot13
	(self isUppercase) ifTrue:[|valorAscii|
		valorAscii := self asciiValue.
		^(((valorAscii - 65 + 13) \\ 26)+65) asCharacter].
	(self isLowercase) ifTrue:[
		|valorAscii|
		valorAscii := self asciiValue.
		^(((valorAscii - 97 + 13) \\ 26)+97) asCharacter].
	(self isLetter) not ifTrue:[^self].
	(self = $A) ifTrue:[^$N].
	(self = $M) ifTrue:[^$Z].
	(self = $N) ifTrue:[^$A].
	(self = $Z) ifTrue:[^$M].
	(self = ${) ifTrue:[^${].
	(self = $`) ifTrue:[^$`].
	($a = self) ifTrue:[^$n].
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m].
	^$z! !

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:31:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:31:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:31:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:31:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:31:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:31:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:31:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:31:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:31:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 17:31:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 17:31:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 17:31:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 17:31:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'I 5/5/2024 17:31:12'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'I 5/5/2024 17:31:12'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:32:02'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:32:04'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:32:04'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:32:04'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:32:04'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:32:04'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:32:04'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:32:04'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:32:04'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 17:32:04'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 17:32:04'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 17:32:04'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 17:32:04'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'I 5/5/2024 17:32:04'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'I 5/5/2024 17:32:04'!
FAILURE!
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 17:33:06' prior: 50594965!
asRot13
	"(self isUppercase) ifTrue:[|valorAscii|
		valorAscii := self asciiValue.
		^(((valorAscii - 65 + 13) \\ 26)+65) asCharacter].
	(self isLowercase) ifTrue:[
		|valorAscii|
		valorAscii := self asciiValue.
		^(((valorAscii - 97 + 13) \\ 26)+97) asCharacter]."
	(self isLetter) not ifTrue:[^self].
	(self = $A) ifTrue:[^$N].
	(self = $M) ifTrue:[^$Z].
	(self = $N) ifTrue:[^$A].
	(self = $Z) ifTrue:[^$M].
	(self = ${) ifTrue:[^${].
	(self = $`) ifTrue:[^$`].
	($a = self) ifTrue:[^$n].
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m].
	^$z! !
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 17:33:22' prior: 50595102!
asRot13
	"(self isUppercase) ifTrue:[|valorAscii|
		valorAscii := self asciiValue.
		^(((valorAscii - 65 + 13) \\ 26)+65) asCharacter].
	(self isLowercase) ifTrue:[
		|valorAscii|
		valorAscii := self asciiValue.
		^(((valorAscii - 97 + 13) \\ 26)+97) asCharacter].
	(self isLetter) not ifTrue:[^self]."
	(self = $A) ifTrue:[^$N].
	(self = $M) ifTrue:[^$Z].
	(self = $N) ifTrue:[^$A].
	(self = $Z) ifTrue:[^$M].
	(self = ${) ifTrue:[^${].
	(self = $`) ifTrue:[^$`].
	($a = self) ifTrue:[^$n].
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m].
	^$z! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:33:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:33:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 17:33:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 17:33:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 17:33:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 17:33:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'I 5/5/2024 17:33:29'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:33:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:33:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 17:33:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 17:33:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 17:33:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 17:33:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'I 5/5/2024 17:33:30'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:33:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:33:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 17:33:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 17:33:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 17:33:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 17:33:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'I 5/5/2024 17:33:32'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:33:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:33:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 17:33:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 17:33:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 17:33:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 17:33:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'I 5/5/2024 17:33:32'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'I 5/5/2024 17:33:33'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'I 5/5/2024 17:33:33'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'I 5/5/2024 17:33:33'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'I 5/5/2024 17:33:33'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 17:33:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'I 5/5/2024 17:33:33'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:33:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:33:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 17:33:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 17:33:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 17:33:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 17:33:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'I 5/5/2024 17:33:34'!
FAILURE!

!methodRemoval: Character #asRot13 stamp: 'I 5/5/2024 17:33:35'!
asRot13
	"(self isUppercase) ifTrue:[|valorAscii|
		valorAscii := self asciiValue.
		^(((valorAscii - 65 + 13) \\ 26)+65) asCharacter].
	(self isLowercase) ifTrue:[
		|valorAscii|
		valorAscii := self asciiValue.
		^(((valorAscii - 97 + 13) \\ 26)+97) asCharacter].
	(self isLetter) not ifTrue:[^self]."
	(self = $A) ifTrue:[^$N].
	(self = $M) ifTrue:[^$Z].
	(self = $N) ifTrue:[^$A].
	(self = $Z) ifTrue:[^$M].
	(self = ${) ifTrue:[^${].
	(self = $`) ifTrue:[^$`].
	($a = self) ifTrue:[^$n].
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m].
	^$z!

!methodRemoval: String #asRot13 stamp: 'I 5/5/2024 17:33:35'!
asRot13
	(self = 'a') ifTrue:[^'n'].
	(self = 'M') ifTrue:[^'Z'].
	(self = 'n') ifTrue:[^'a'].
	(self = '{') ifTrue:[^'{'].
	(self = 'az') ifTrue:[^'nm'].
	(self = 'hOlA!!') ifTrue:[^'uByN!!'].
	^''!

!methodRemoval: TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:35'!
test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $z equals: $m asRot13
	!

!methodRemoval: TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:35'!
test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $A equals: $N asRot13.
	self assert: $M equals: $Z asRot13
	!

!methodRemoval: TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:35'!
test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $m equals: $z asRot13
	!

!methodRemoval: TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:33:35'!
test05CharOnTheBelowRangeDoesntChange
	
	self assert: $` equals: $` asRot13
	!

!methodRemoval: TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 17:33:35'!
test09TheEmptyStringDoesntChange
	
	self assert: '' equals: '' asRot13
	!

!methodRemoval: TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 17:33:35'!
test11CorrectlyEncodesATwoCharString
	
	self assert: 'nm' equals: 'az' asRot13
	!

!methodRemoval: TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:35'!
test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $n equals: $a asRot13
	!

!methodRemoval: TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:35'!
test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $a equals: $n asRot13
	!

!methodRemoval: TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:33:35'!
test06CharOnTheUpperRangeDoesntChange
	
	self assert: ${ equals: ${ asRot13
	!

!methodRemoval: TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:35'!
test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $N equals: $A asRot13.
	self assert: $Z equals: $M asRot13
	!

!methodRemoval: TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 17:33:35'!
test10CorrectlyEncodesAOneCharString
	
	self assert: 'n' equals: 'a' asRot13.
	self assert: 'Z' equals: 'M' asRot13.
	self assert: 'a' equals: 'n' asRot13.
	self assert: '{' equals: '{' asRot13
	!

!methodRemoval: TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 17:33:35'!
test12CorrectlyEncodesMoreThanTwoCharString
	
	self assert: 'uByN!!' equals: 'hOlA!!' asRot13
	!

!methodRemoval: TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'I 5/5/2024 17:33:35'!
testExtraToCheckGeneralizationOnKata
		
	self assert: 'Ju3er j3 4e3 t01at j3 q0ag a3rq e04q$...' equals: 'Wh3re w3 4r3 g01ng w3 d0nt n3ed r04d$...' asRot13
	!

!classRemoval: #TDDBabyStepsRot13Test stamp: 'I 5/5/2024 17:33:36'!
TestCase subclass: #TDDBabyStepsRot13Test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TDDBabyStepsGameRot13'!

!classDefinition: #TDDBabyStepsRot13Test category: #TDDBabyStepsGameRot13 stamp: 'I 5/5/2024 17:33:36'!
TestCase subclass: #TDDBabyStepsRot13Test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TDDBabyStepsGameRot13'!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 17:33:37'!
test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $n equals: $a asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:33:49'!
ERROR!
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 17:34:33'!
asRot13
	"(self isUppercase) ifTrue:[|valorAscii|
		valorAscii := self asciiValue.
		^(((valorAscii - 65 + 13) \\ 26)+65) asCharacter].
	(self isLowercase) ifTrue:[
		|valorAscii|
		valorAscii := self asciiValue.
		^(((valorAscii - 97 + 13) \\ 26)+97) asCharacter].
	(self isLetter) not ifTrue:[^self]."
	(self = $A) ifTrue:[^$N].
	(self = $M) ifTrue:[^$Z].
	(self = $N) ifTrue:[^$A].
	(self = $Z) ifTrue:[^$M].
	(self = ${) ifTrue:[^${].
	(self = $`) ifTrue:[^$`].
	($a = self) ifTrue:[^$n].
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m].
	^$z! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:34:37'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 17:34:37'!
test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $z equals: $m asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:34:37'!
PASSED!

!methodRemoval: TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:34:37'!
test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $z equals: $m asRot13
	!
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 17:35:14' prior: 50595795!
asRot13
	"(self isUppercase) ifTrue:[|valorAscii|
		valorAscii := self asciiValue.
		^(((valorAscii - 65 + 13) \\ 26)+65) asCharacter].
	(self isLowercase) ifTrue:[
		|valorAscii|
		valorAscii := self asciiValue.
		^(((valorAscii - 97 + 13) \\ 26)+97) asCharacter].
	(self isLetter) not ifTrue:[^self]."
	"(self = $A) ifTrue:[^$N].
	(self = $M) ifTrue:[^$Z].
	(self = $N) ifTrue:[^$A].
	(self = $Z) ifTrue:[^$M].
	(self = ${) ifTrue:[^${].
	(self = $`) ifTrue:[^$`]."
	($a = self) ifTrue:[^$n]."
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m].
	^$z"! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:35:16'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 17:35:16'!
test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $z equals: $m asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:35:16'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:35:16'!
test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $z equals: $m asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 17:35:16'!
test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $z equals: $m asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:35:16'!
FAILURE!
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 17:35:54' prior: 50595837!
asRot13
	"(self isUppercase) ifTrue:[|valorAscii|
		valorAscii := self asciiValue.
		^(((valorAscii - 65 + 13) \\ 26)+65) asCharacter].
	(self isLowercase) ifTrue:[
		|valorAscii|
		valorAscii := self asciiValue.
		^(((valorAscii - 97 + 13) \\ 26)+97) asCharacter].
	(self isLetter) not ifTrue:[^self]."
	"(self = $A) ifTrue:[^$N].
	(self = $M) ifTrue:[^$Z].
	(self = $N) ifTrue:[^$A].
	(self = $Z) ifTrue:[^$M].
	(self = ${) ifTrue:[^${].
	(self = $`) ifTrue:[^$`]."
	($a = self) ifTrue:[^$n].
	($m = self) ifTrue:[^$z]."
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m].
	^$z"! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:36:01'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:36:01'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 17:36:01'!
test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $a equals: $n asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:36:01'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:36:01'!
test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $a equals: $n asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 17:36:01'!
test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $a equals: $n asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:36:01'!
FAILURE!
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 17:36:40' prior: 50595891!
asRot13
	"(self isUppercase) ifTrue:[|valorAscii|
		valorAscii := self asciiValue.
		^(((valorAscii - 65 + 13) \\ 26)+65) asCharacter].
	(self isLowercase) ifTrue:[
		|valorAscii|
		valorAscii := self asciiValue.
		^(((valorAscii - 97 + 13) \\ 26)+97) asCharacter].
	(self isLetter) not ifTrue:[^self]."
	"(self = $A) ifTrue:[^$N].
	(self = $M) ifTrue:[^$Z].
	(self = $N) ifTrue:[^$A].
	(self = $Z) ifTrue:[^$M].
	(self = ${) ifTrue:[^${].
	(self = $`) ifTrue:[^$`]."
	($a = self) ifTrue:[^$n].
	($m = self) ifTrue:[^$z].
	($n = self) ifTrue:[^$a]."
	($z = self) ifTrue:[^$m].
	^$z"! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:36:44'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:36:44'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:36:44'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 17:36:44'!
test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $m equals: $z asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:36:44'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:36:44'!
test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $m equals: $z asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 17:36:44'!
test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $m equals: $z asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:36:44'!
FAILURE!
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 17:36:56' prior: 50595950!
asRot13
	"(self isUppercase) ifTrue:[|valorAscii|
		valorAscii := self asciiValue.
		^(((valorAscii - 65 + 13) \\ 26)+65) asCharacter].
	(self isLowercase) ifTrue:[
		|valorAscii|
		valorAscii := self asciiValue.
		^(((valorAscii - 97 + 13) \\ 26)+97) asCharacter].
	(self isLetter) not ifTrue:[^self]."
	"(self = $A) ifTrue:[^$N].
	(self = $M) ifTrue:[^$Z].
	(self = $N) ifTrue:[^$A].
	(self = $Z) ifTrue:[^$M].
	(self = ${) ifTrue:[^${].
	(self = $`) ifTrue:[^$`]."
	($a = self) ifTrue:[^$n].
	($m = self) ifTrue:[^$z].
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m]."
	^$z"! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:36:59'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:36:59'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:36:59'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:36:59'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 17:36:59'!
test05CharOnTheBelowRangeDoesntChange
	
	self assert: $` equals: $` asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:36:59'!
PASSED!

!methodRemoval: TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:36:59'!
test05CharOnTheBelowRangeDoesntChange
	
	self assert: $` equals: $` asRot13
	!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:05'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:08'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:08'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:08'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:08'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 17:37:08'!
test05CharOnTheBelowRangeDoesntChange
	
	self assert: $` equals: $` asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:37:08'!
PASSED!

!methodRemoval: TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:37:08'!
test05CharOnTheBelowRangeDoesntChange
	
	self assert: $` equals: $` asRot13
	!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:19'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:19'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:19'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:19'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 17:37:19'!
test05CharOnTheBelowRangeDoesntChange
	
	self assert: $` equals: $` asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:37:19'!
PASSED!

!methodRemoval: TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:37:19'!
test05CharOnTheBelowRangeDoesntChange
	
	self assert: $` equals: $` asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 17:37:19'!
test05CharOnTheBelowRangeDoesntChange
	
	self assert: $` equals: $` asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:37:19'!
PASSED!
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 17:37:28' prior: 50596013!
asRot13
	"(self isUppercase) ifTrue:[|valorAscii|
		valorAscii := self asciiValue.
		^(((valorAscii - 65 + 13) \\ 26)+65) asCharacter].
	(self isLowercase) ifTrue:[
		|valorAscii|
		valorAscii := self asciiValue.
		^(((valorAscii - 97 + 13) \\ 26)+97) asCharacter].
	(self isLetter) not ifTrue:[^self]."
	"(self = $A) ifTrue:[^$N].
	(self = $M) ifTrue:[^$Z].
	(self = $N) ifTrue:[^$A].
	(self = $Z) ifTrue:[^$M].
	(self = ${) ifTrue:[^${]."
	(self = $`) ifTrue:[^$`].
	($a = self) ifTrue:[^$n].
	($m = self) ifTrue:[^$z].
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m]."
	^$z"! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:37:32'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 17:37:32'!
test06CharOnTheUpperRangeDoesntChange
	
	self assert: ${ equals: ${ asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:37:32'!
PASSED!

!methodRemoval: TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:37:32'!
test06CharOnTheUpperRangeDoesntChange
	
	self assert: ${ equals: ${ asRot13
	!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:35'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:35'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:35'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:35'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:37:35'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 17:37:35'!
test06CharOnTheUpperRangeDoesntChange
	
	self assert: ${ equals: ${ asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:37:35'!
PASSED!

!methodRemoval: TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:37:35'!
test06CharOnTheUpperRangeDoesntChange
	
	self assert: ${ equals: ${ asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 17:37:35'!
test06CharOnTheUpperRangeDoesntChange
	
	self assert: ${ equals: ${ asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:37:35'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:37:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:37:39'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 17:37:39'!
test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $N equals: $A asRot13.
	self assert: $Z equals: $M asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:39'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:39'!
test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $N equals: $A asRot13.
	self assert: $Z equals: $M asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 17:37:39'!
test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $N equals: $A asRot13.
	self assert: $Z equals: $M asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:39'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:39'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:39'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:39'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:39'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:37:39'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:37:39'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:39'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:37:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:37:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:40'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:37:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:37:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:37:41'!
FAILURE!
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 17:38:01' prior: 50596144!
asRot13
	"(self isUppercase) ifTrue:[|valorAscii|
		valorAscii := self asciiValue.
		^(((valorAscii - 65 + 13) \\ 26)+65) asCharacter].
	(self isLowercase) ifTrue:[
		|valorAscii|
		valorAscii := self asciiValue.
		^(((valorAscii - 97 + 13) \\ 26)+97) asCharacter].
	(self isLetter) not ifTrue:[^self]."
	(self = $A) ifTrue:[^$N].
	(self = $M) ifTrue:[^$Z].
	(self = $N) ifTrue:[^$A].
	(self = $Z) ifTrue:[^$M].
	"(self = ${) ifTrue:[^${]."
	(self = $`) ifTrue:[^$`].
	($a = self) ifTrue:[^$n].
	($m = self) ifTrue:[^$z].
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m]."
	^$z"! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:38:03'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:38:03'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:38:03'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:38:03'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:38:03'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:38:03'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:38:03'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 17:38:03'!
test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $A equals: $N asRot13.
	self assert: $M equals: $Z asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:38:03'!
PASSED!

!methodRemoval: TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:38:03'!
test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $A equals: $N asRot13.
	self assert: $M equals: $Z asRot13
	!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:38:05'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:38:05'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:38:05'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:38:05'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:38:05'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:38:05'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:38:05'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 17:38:05'!
test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $A equals: $N asRot13.
	self assert: $M equals: $Z asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:38:05'!
PASSED!

!methodRemoval: TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:38:05'!
test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $A equals: $N asRot13.
	self assert: $M equals: $Z asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 17:38:05'!
test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $A equals: $N asRot13.
	self assert: $M equals: $Z asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:38:05'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:38:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:38:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:38:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:38:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:38:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:38:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:38:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:38:11'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 17:38:11'!
test09TheEmptyStringDoesntChange
	
	self assert: '' equals: '' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 17:38:11'!
ERROR!

!methodRemoval: TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 17:38:11'!
test09TheEmptyStringDoesntChange
	
	self assert: '' equals: '' asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 17:38:11'!
test09TheEmptyStringDoesntChange
	
	self assert: '' equals: '' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 17:38:11'!
ERROR!
!String methodsFor: 'converting' stamp: 'I 5/5/2024 17:38:36'!
asRot13
	^''! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:38:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:38:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:38:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:38:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:38:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:38:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:38:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:38:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 17:38:41'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 17:38:41'!
test10CorrectlyEncodesAOneCharString
	
	self assert: 'n' equals: 'a' asRot13.
	self assert: 'Z' equals: 'M' asRot13.
	self assert: 'a' equals: 'n' asRot13.
	self assert: '{' equals: '{' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 17:38:41'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 17:38:41'!
test10CorrectlyEncodesAOneCharString
	
	self assert: 'n' equals: 'a' asRot13.
	self assert: 'Z' equals: 'M' asRot13.
	self assert: 'a' equals: 'n' asRot13.
	self assert: '{' equals: '{' asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 17:38:41'!
test10CorrectlyEncodesAOneCharString
	
	self assert: 'n' equals: 'a' asRot13.
	self assert: 'Z' equals: 'M' asRot13.
	self assert: 'a' equals: 'n' asRot13.
	self assert: '{' equals: '{' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 17:38:41'!
FAILURE!
!String methodsFor: 'converting' stamp: 'I 5/5/2024 17:39:35' prior: 50596576!
asRot13
	(self = 'a') ifTrue:[^'n'].
	(self = 'M') ifTrue:[^'Z'].
	(self = 'n') ifTrue:[^'a'].
	(self = '{') ifTrue:[^'{'].
	^''
	! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:39:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:39:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:39:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:39:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:39:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:39:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:39:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:39:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 17:39:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 17:39:38'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 17:39:38'!
test11CorrectlyEncodesATwoCharString
	
	self assert: 'nm' equals: 'az' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 17:39:38'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 17:39:38'!
test11CorrectlyEncodesATwoCharString
	
	self assert: 'nm' equals: 'az' asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 17:39:38'!
test11CorrectlyEncodesATwoCharString
	
	self assert: 'nm' equals: 'az' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 17:39:38'!
FAILURE!
!String methodsFor: 'converting' stamp: 'I 5/5/2024 17:39:57' prior: 50596651!
asRot13
	(self = 'a') ifTrue:[^'n'].
	(self = 'M') ifTrue:[^'Z'].
	(self = 'n') ifTrue:[^'a'].
	(self = '{') ifTrue:[^'{'].
	(self = 'az') ifTrue:[^'nm'].
	^''
! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:39:59'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:39:59'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:39:59'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:39:59'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:39:59'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:39:59'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:39:59'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:39:59'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 17:39:59'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 17:39:59'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 17:39:59'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 17:39:59'!
test12CorrectlyEncodesMoreThanTwoCharString
	
	self assert: 'uByN!!' equals: 'hOlA!!' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 17:39:59'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 17:39:59'!
test12CorrectlyEncodesMoreThanTwoCharString
	
	self assert: 'uByN!!' equals: 'hOlA!!' asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 17:39:59'!
test12CorrectlyEncodesMoreThanTwoCharString
	
	self assert: 'uByN!!' equals: 'hOlA!!' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 17:39:59'!
FAILURE!
!String methodsFor: 'converting' stamp: 'I 5/5/2024 17:40:16' prior: 50596722!
asRot13
	(self = 'a') ifTrue:[^'n'].
	(self = 'M') ifTrue:[^'Z'].
	(self = 'n') ifTrue:[^'a'].
	(self = '{') ifTrue:[^'{'].
	(self = 'az') ifTrue:[^'nm'].
	(self = 'hOlA!!') ifTrue:[^'uByN!!'].
	^''
! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:40:17'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:40:17'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:40:17'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:40:17'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:40:17'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:40:17'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:40:17'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:40:17'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 17:40:17'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 17:40:17'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 17:40:17'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 17:40:17'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'I 5/5/2024 17:40:17'!
testExtraToCheckGeneralizationOnKata
		
	self assert: 'Ju3er j3 4e3 t01at j3 q0ag a3rq e04q$...' equals: 'Wh3re w3 4r3 g01ng w3 d0nt n3ed r04d$...' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'I 5/5/2024 17:40:17'!
FAILURE!
!Character methodsFor: 'converting' stamp: 'I 5/5/2024 17:41:19' prior: 50596389!
asRot13
	(self isUppercase) ifTrue:[|valorAscii|
		valorAscii := self asciiValue.
		^(((valorAscii - 65 + 13) \\ 26)+65) asCharacter].
	(self isLowercase) ifTrue:[
		|valorAscii|
		valorAscii := self asciiValue.
		^(((valorAscii - 97 + 13) \\ 26)+97) asCharacter].
	(self isLetter) not ifTrue:[^self]."
	(self = $A) ifTrue:[^$N].
	(self = $M) ifTrue:[^$Z].
	(self = $N) ifTrue:[^$A].
	(self = $Z) ifTrue:[^$M].
	(self = ${) ifTrue:[^${].
	(self = $`) ifTrue:[^$`].
	($a = self) ifTrue:[^$n].
	($m = self) ifTrue:[^$z].
	($n = self) ifTrue:[^$a].
	($z = self) ifTrue:[^$m].
	^$z"! !

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:41:22'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:41:23'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:41:25'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:41:26'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 17:41:27'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 17:41:31'!
PASSED!

'a' asCharacter!

'a' asArray!

'a' asSymbol!

'Hola' asArray !

'Hola' at: 1!

'Hola' at: 0!
!String methodsFor: 'converting' stamp: 'I 5/5/2024 17:51:27' prior: 50596799!
asRot13
	|stringCifrado string|
	stringCifrado := ''.
	string := self asArray.
	self do:[:a | stringCifrado , (a asRot13)asCharacter].
	^stringCifrado."
	(self = 'a') ifTrue:[^'n'].
	(self = 'M') ifTrue:[^'Z'].
	(self = 'n') ifTrue:[^'a'].
	(self = '{') ifTrue:[^'{'].
	(self = 'az') ifTrue:[^'nm'].
	(self = 'hOlA!!') ifTrue:[^'uByN!!'].
	^''"
! !
!String methodsFor: 'converting' stamp: 'I 5/5/2024 17:51:36' prior: 50596915!
asRot13
	|stringCifrado string|
	stringCifrado := ''.
	string := self asArray.
	string do:[:a | stringCifrado , (a asRot13)asCharacter].
	^stringCifrado."
	(self = 'a') ifTrue:[^'n'].
	(self = 'M') ifTrue:[^'Z'].
	(self = 'n') ifTrue:[^'a'].
	(self = '{') ifTrue:[^'{'].
	(self = 'az') ifTrue:[^'nm'].
	(self = 'hOlA!!') ifTrue:[^'uByN!!'].
	^''"
! !

$a asString!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 17:52:47'!
ERROR!
!String methodsFor: 'converting' stamp: 'I 5/5/2024 17:53:03' prior: 50596929!
asRot13
	|stringCifrado string|
	stringCifrado := ''.
	string := self asArray.
	string do:[:a | stringCifrado , (a asRot13)asString].
	^stringCifrado."
	(self = 'a') ifTrue:[^'n'].
	(self = 'M') ifTrue:[^'Z'].
	(self = 'n') ifTrue:[^'a'].
	(self = '{') ifTrue:[^'{'].
	(self = 'az') ifTrue:[^'nm'].
	(self = 'hOlA!!') ifTrue:[^'uByN!!'].
	^''"
! !

'Hola' , 'a'!
!String methodsFor: 'converting' stamp: 'I 5/5/2024 17:55:48' prior: 50596947!
asRot13
	|stringCifrado string|
	stringCifrado := String new.
	string := self asArray.
	string do:[:a | stringCifrado , (a asRot13)asString].
	^stringCifrado."
	(self = 'a') ifTrue:[^'n'].
	(self = 'M') ifTrue:[^'Z'].
	(self = 'n') ifTrue:[^'a'].
	(self = '{') ifTrue:[^'{'].
	(self = 'az') ifTrue:[^'nm'].
	(self = 'hOlA!!') ifTrue:[^'uByN!!'].
	^''"
! !
!String methodsFor: 'converting' stamp: 'I 5/5/2024 17:56:58' prior: 50596961!
asRot13
	|stringCifrado string|
	stringCifrado := String new.
	string := self asArray.
	string do:[:caracter |
        | caracterCifrado |
        caracterCifrado := caracter asRot13 asString.
        stringCifrado := stringCifrado, caracterCifrado].
	^stringCifrado."
	(self = 'a') ifTrue:[^'n'].
	(self = 'M') ifTrue:[^'Z'].
	(self = 'n') ifTrue:[^'a'].
	(self = '{') ifTrue:[^'{'].
	(self = 'az') ifTrue:[^'nm'].
	(self = 'hOlA!!') ifTrue:[^'uByN!!'].
	^''"
! !

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 17:57:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:57:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:57:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:57:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:57:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'I 5/5/2024 17:57:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'I 5/5/2024 17:57:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'I 5/5/2024 17:57:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'I 5/5/2024 17:57:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'I 5/5/2024 17:57:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'I 5/5/2024 17:57:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'I 5/5/2024 17:57:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 17:57:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'I 5/5/2024 17:57:34'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'I 5/5/2024 17:57:36'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'I 5/5/2024 17:57:37'!
PASSED!

TDDBabyStepsGameAnagrams  start!

!classDefinition: #TDDBabyStepsAnagramsTest category: #TDDBabyStepsGameAnagrams stamp: 'I 5/5/2024 17:59:20'!
TestCase subclass: #TDDBabyStepsAnagramsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TDDBabyStepsGameAnagrams'!

!classRemoval: #TDDBabyStepsAnagramsTest stamp: 'I 5/5/2024 18:15:55'!
TestCase subclass: #TDDBabyStepsAnagramsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TDDBabyStepsGameAnagrams'!

!classDefinition: #TDDBabyStepsAnagramsTest category: #TDDBabyStepsGameAnagrams stamp: 'I 5/5/2024 18:15:55'!
TestCase subclass: #TDDBabyStepsAnagramsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TDDBabyStepsGameAnagrams'!

TDDBabyStepsGameAnagrams  start !

!classDefinition: #TDDBabyStepsAnagramsTest category: #TDDBabyStepsGameAnagrams stamp: 'I 5/5/2024 18:15:57'!
TestCase subclass: #TDDBabyStepsAnagramsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TDDBabyStepsGameAnagrams'!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'I 5/5/2024 18:16:07'!
test01EmptyStringAnagramIsJustACollectionWithTheEmptyString

	self assert: (Set with: '') equals: '' anagrams
	! !
!String methodsFor: 'nil' stamp: 'I 5/5/2024 18:17:40'!
anagrams
	^Set with: ''.! !

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'I 5/5/2024 18:17:42'!
PASSED!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'I 5/5/2024 18:17:42'!
test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString

	self assert: (Set with:'a') equals: 'a' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'I 5/5/2024 18:17:42'!
FAILURE!

!methodRemoval: TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'I 5/5/2024 18:17:42'!
test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString

	self assert: (Set with:'a') equals: 'a' anagrams
	!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'I 5/5/2024 18:17:43'!
test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString

	self assert: (Set with:'a') equals: 'a' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'I 5/5/2024 18:17:43'!
FAILURE!
!String methodsFor: 'as yet unclassified' stamp: 'I 5/5/2024 18:18:28' prior: 50597094!
anagrams
	(self = 'a') ifTrue:[^Set with: 'a'].
	^Set with: ''.! !

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'I 5/5/2024 18:18:31'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'I 5/5/2024 18:18:31'!
PASSED!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'I 5/5/2024 18:18:31'!
test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped

	self assert: (Set with:'ab' with: 'ba') equals: 'ab' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'I 5/5/2024 18:18:31'!
FAILURE!

!methodRemoval: TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'I 5/5/2024 18:18:31'!
test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped

	self assert: (Set with:'ab' with: 'ba') equals: 'ab' anagrams
	!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'I 5/5/2024 18:18:31'!
test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped

	self assert: (Set with:'ab' with: 'ba') equals: 'ab' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'I 5/5/2024 18:18:31'!
FAILURE!
!String methodsFor: 'as yet unclassified' stamp: 'I 5/5/2024 18:18:59' prior: 50597134!
anagrams
	(self = 'a') ifTrue:[^Set with: 'a'].
	(self = 'ab') ifTrue:[^Set with: 'ab' with: 'ba'].
	^Set with: ''.! !

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'I 5/5/2024 18:19:02'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'I 5/5/2024 18:19:02'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'I 5/5/2024 18:19:02'!
PASSED!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'I 5/5/2024 18:19:02'!
test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations

	| anagrams |
	
	anagrams := Set new.
	anagrams add: 'abc'.
	anagrams add: 'acb'.
	anagrams add: 'bac'.
	anagrams add: 'bca'.
	anagrams add: 'cab'.
	anagrams add: 'cba'.

	self assert: anagrams equals: 'abc' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'I 5/5/2024 18:19:02'!
FAILURE!

!methodRemoval: TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'I 5/5/2024 18:19:02'!
test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations

	| anagrams |
	
	anagrams := Set new.
	anagrams add: 'abc'.
	anagrams add: 'acb'.
	anagrams add: 'bac'.
	anagrams add: 'bca'.
	anagrams add: 'cab'.
	anagrams add: 'cba'.

	self assert: anagrams equals: 'abc' anagrams
	!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'I 5/5/2024 18:19:02'!
test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations

	| anagrams |
	
	anagrams := Set new.
	anagrams add: 'abc'.
	anagrams add: 'acb'.
	anagrams add: 'bac'.
	anagrams add: 'bca'.
	anagrams add: 'cab'.
	anagrams add: 'cba'.

	self assert: anagrams equals: 'abc' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'I 5/5/2024 18:19:02'!
FAILURE!
!String methodsFor: 'as yet unclassified' stamp: 'I 5/5/2024 18:20:27' prior: 50597181!
anagrams
	(self = 'a') ifTrue:[^Set with: 'a'].
	(self = 'ab') ifTrue:[^Set with: 'ab' with: 'ba'].
	(self = 'abc') ifTrue:[| anagrams |
	
	anagrams := Set new.
	anagrams add: 'abc'.
	anagrams add: 'acb'.
	anagrams add: 'bac'.
	anagrams add: 'bca'.
	anagrams add: 'cab'.
	anagrams add: 'cba'.
	^anagrams].
	^Set with: ''.! !

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'I 5/5/2024 18:20:29'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'I 5/5/2024 18:20:29'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'I 5/5/2024 18:20:29'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'I 5/5/2024 18:20:29'!
PASSED!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'I 5/5/2024 18:20:29'!
test05MoreThanThreeCharStringAnagramReturnsAllTheCorrectPossibleOrderCombinations

	| anagrams |
	
	anagrams := Set new.
	anagrams add: 'abcd'; add: 'abdc'; add: 'acbd'; add: 'acdb'; add: 'adbc'; add: 'adcb'; add: 'bacd'; add: 'badc'; add: 'bcad'; add: 'bcda'; add: 'bdac'; add: 'bdca'; add: 'cabd'; add: 'cadb'; add: 'cbad'; add: 'cbda'; add: 'cdab'; add: 'cdba'; add: 'dabc'; add: 'dacb'; add: 'dbac'; add: 'dbca'; add: 'dcab'; add: 'dcba'.

	self assert: anagrams equals: 'abcd' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test05MoreThanThreeCharStringAnagramReturnsAllTheCorrectPossibleOrderCombinations stamp: 'I 5/5/2024 18:20:29'!
FAILURE!

!methodRemoval: TDDBabyStepsAnagramsTest #test05MoreThanThreeCharStringAnagramReturnsAllTheCorrectPossibleOrderCombinations stamp: 'I 5/5/2024 18:20:29'!
test05MoreThanThreeCharStringAnagramReturnsAllTheCorrectPossibleOrderCombinations

	| anagrams |
	
	anagrams := Set new.
	anagrams add: 'abcd'; add: 'abdc'; add: 'acbd'; add: 'acdb'; add: 'adbc'; add: 'adcb'; add: 'bacd'; add: 'badc'; add: 'bcad'; add: 'bcda'; add: 'bdac'; add: 'bdca'; add: 'cabd'; add: 'cadb'; add: 'cbad'; add: 'cbda'; add: 'cdab'; add: 'cdba'; add: 'dabc'; add: 'dacb'; add: 'dbac'; add: 'dbca'; add: 'dcab'; add: 'dcba'.

	self assert: anagrams equals: 'abcd' anagrams
	!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'I 5/5/2024 18:20:29'!
test05MoreThanThreeCharStringAnagramReturnsAllTheCorrectPossibleOrderCombinations

	| anagrams |
	
	anagrams := Set new.
	anagrams add: 'abcd'; add: 'abdc'; add: 'acbd'; add: 'acdb'; add: 'adbc'; add: 'adcb'; add: 'bacd'; add: 'badc'; add: 'bcad'; add: 'bcda'; add: 'bdac'; add: 'bdca'; add: 'cabd'; add: 'cadb'; add: 'cbad'; add: 'cbda'; add: 'cdab'; add: 'cdba'; add: 'dabc'; add: 'dacb'; add: 'dbac'; add: 'dbca'; add: 'dcab'; add: 'dcba'.

	self assert: anagrams equals: 'abcd' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test05MoreThanThreeCharStringAnagramReturnsAllTheCorrectPossibleOrderCombinations stamp: 'I 5/5/2024 18:20:29'!
FAILURE!
!String methodsFor: 'as yet unclassified' stamp: 'I 5/5/2024 18:25:23' prior: 50597248!
anagrams
	|anagrams|
	anagrams := Set new.
	self permutationsDo: [:permutation | anagrams add: permutation].
	^anagrams."
	(self = 'a') ifTrue:[^Set with: 'a'].
	(self = 'ab') ifTrue:[^Set with: 'ab' with: 'ba'].
	(self = 'abc') ifTrue:[| anagrams |
	
	anagrams := Set new.
	anagrams add: 'abc'.
	anagrams add: 'acb'.
	anagrams add: 'bac'.
	anagrams add: 'bca'.
	anagrams add: 'cab'.
	anagrams add: 'cba'.
	^anagrams].
	^Set with: ''."! !

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'I 5/5/2024 18:25:27'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'I 5/5/2024 18:25:31'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'I 5/5/2024 18:25:31'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'I 5/5/2024 18:26:26'!
PASSED!
!String methodsFor: 'as yet unclassified' stamp: 'I 5/5/2024 18:25:23' prior: 50597347!
anagrams
	|anagrams|
	anagrams := Set new.
	self permutationsDo: [:permutation | anagrams add: permutation].
	^anagrams."
	(self = 'a') ifTrue:[^Set with: 'a'].
	(self = 'ab') ifTrue:[^Set with: 'ab' with: 'ba'].
	(self = 'abc') ifTrue:[| anagrams |
	
	anagrams := Set new.
	anagrams add: 'abc'.
	anagrams add: 'acb'.
	anagrams add: 'bac'.
	anagrams add: 'bca'.
	anagrams add: 'cab'.
	anagrams add: 'cba'.
	^anagrams].
	^Set with: ''."! !
!String methodsFor: 'as yet unclassified' stamp: 'I 5/5/2024 18:25:23' prior: 50597381!
anagrams
	|anagrams|
	anagrams := Set new.
	self permutationsDo: [:permutation | anagrams add: permutation].
	^anagrams."
	(self = 'a') ifTrue:[^Set with: 'a'].
	(self = 'ab') ifTrue:[^Set with: 'ab' with: 'ba'].
	(self = 'abc') ifTrue:[| anagrams |
	
	anagrams := Set new.
	anagrams add: 'abc'.
	anagrams add: 'acb'.
	anagrams add: 'bac'.
	anagrams add: 'bca'.
	anagrams add: 'cab'.
	anagrams add: 'cba'.
	^anagrams].
	^Set with: ''."! !
!String methodsFor: 'as yet unclassified' stamp: 'I 5/5/2024 18:33:30' prior: 50597398!
anagrams
	|anagrams|
	anagrams := Set new.
	self permutationsDo: [:permutation | anagrams add: permutation].
	^anagrams.
    "
	(self = 'a') ifTrue:[^Set with: 'a'].
	(self = 'ab') ifTrue:[^Set with: 'ab' with: 'ba'].
	(self = 'abc') ifTrue:[| anagrams |
	
	anagrams := Set new.
	anagrams add: 'abc'.
	anagrams add: 'acb'.
	anagrams add: 'bac'.
	anagrams add: 'bca'.
	anagrams add: 'cab'.
	anagrams add: 'cba'.
	^anagrams].
	^Set with: ''."! !

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'I 5/5/2024 18:33:36'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'I 5/5/2024 18:33:36'!
FAILURE!
!String methodsFor: 'as yet unclassified' stamp: 'I 5/5/2024 21:49:41' prior: 50597415!
anagrams
	|anagrams|
	anagrams := Set new.
	self permutationsDo: [:permutation | |permu|
		permu:= permutation.
		anagrams add:permu].
	^anagrams.
    "
	(self = 'a') ifTrue:[^Set with: 'a'].
	(self = 'ab') ifTrue:[^Set with: 'ab' with: 'ba'].
	(self = 'abc') ifTrue:[| anagrams |
	
	anagrams := Set new.
	anagrams add: 'abc'.
	anagrams add: 'acb'.
	anagrams add: 'bac'.
	anagrams add: 'bca'.
	anagrams add: 'cab'.
	anagrams add: 'cba'.
	^anagrams].
	^Set with: ''."! !

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'I 5/5/2024 23:08:25'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'I 5/5/2024 23:08:27'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'I 5/5/2024 23:08:27'!
FAILURE!
!String methodsFor: 'as yet unclassified' stamp: 'I 5/5/2024 23:34:13' prior: 50597441!
anagrams
	|anagrams|
	anagrams := Set new.
	self doPermutationsOnSet: anagrams indexStart:1.
	self permutationsDo: [:permutation | |permu|
		permu:= permutation.
		anagrams add:permu].
	^anagrams.
    "
	(self = 'a') ifTrue:[^Set with: 'a'].
	(self = 'ab') ifTrue:[^Set with: 'ab' with: 'ba'].
	(self = 'abc') ifTrue:[| anagrams |
	
	anagrams := Set new.
	anagrams add: 'abc'.
	anagrams add: 'acb'.
	anagrams add: 'bac'.
	anagrams add: 'bca'.
	anagrams add: 'cab'.
	anagrams add: 'cba'.
	^anagrams].
	^Set with: ''."! !
!String methodsFor: 'as yet unclassified' stamp: 'I 5/5/2024 23:37:30'!
doPermutationsOnSet: anagrams indexStart: index
	
	index > self size ifTrue: [^self].
	index = self size ifTrue: [^anagrams add: self].
	index to: self size do:
	[:i | self swap: index with: i.
		self doPermutationsOnSet: anagrams indexStart: index + 1.
		self swap: index with: i]! !

----QUIT----(6 May 2024 00:05:04) CuisUniversity-6169.image priorSource: 8369198!

----STARTUP---- (8 May 2024 18:15:09) as /home/ivan/Documents/Facu/Inge 1/linux64/linux64/CuisUniversity-6169.image!


----End fileIn of /home/ivan/Downloads/ABC Problem.st----!

!testRun: #ABCProblemTest #test01CanWriteOneLetterAsFirstCharInFirstBlock stamp: 'I 5/8/2024 18:17:21'!
PASSED!

!testRun: #ABCProblemTest #test01CanWriteOneLetterAsFirstCharInFirstBlock stamp: 'I 5/8/2024 18:17:21'!
PASSED!

!testRun: #ABCProblemTest #test02CannotWriteOneLetterNotIncludedInFirstBlock stamp: 'I 5/8/2024 18:17:21'!
PASSED!

!testRun: #ABCProblemTest #test03CanWriteOneLetterIncludedInFirstBlock stamp: 'I 5/8/2024 18:17:21'!
PASSED!

!testRun: #ABCProblemTest #test04CanWriteOneLetterIncludedInAnyBlock stamp: 'I 5/8/2024 18:17:21'!
PASSED!

!testRun: #ABCProblemTest #test05CannotWriteWhenOtherThanFirstLetterIsNotIncludedInBlocks stamp: 'I 5/8/2024 18:17:21'!
PASSED!

!testRun: #ABCProblemTest #test06RemovesUsedBlocks stamp: 'I 5/8/2024 18:17:21'!
PASSED!

!testRun: #ABCProblemTest #test07PassesExerciseWordsWithDefaultBlocks stamp: 'I 5/8/2024 18:17:21'!
PASSED!

!testRun: #ABCProblemTest #test07PassesExerciseWordsWithDefaultBlocks stamp: 'I 5/8/2024 18:23:35'!
PASSED!

----End fileIn of /home/ivan/Downloads/GameOfLife.pck.st----!

Object subclass: #NameOfSubclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '100 Doors Problem'!

!classDefinition: #NameOfSubclass category: #'100 Doors Problem' stamp: 'I 5/8/2024 18:52:02'!
Object subclass: #NameOfSubclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '100 Doors Problem'!

Object subclass: #Doors100
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '100 Doors Problem'!

!classDefinition: #Doors100 category: #'100 Doors Problem' stamp: 'I 5/8/2024 18:52:29'!
Object subclass: #Doors100
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '100 Doors Problem'!

Object subclass: #Doors100Test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '100 Doors Problem'!

!classDefinition: #Doors100Test category: #'100 Doors Problem' stamp: 'I 5/8/2024 18:52:40'!
Object subclass: #Doors100Test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '100 Doors Problem'!
!Doors100Test methodsFor: 'nil' stamp: 'I 5/8/2024 18:53:01'!
Test01AfterTheFirstPassAllDoorsAreOpen! !
!Doors100Test methodsFor: 'as yet unclassified' stamp: 'I 5/8/2024 18:54:36' prior: 50598280!
Test01AfterTheFirstPassAllDoorsAreOpen
	
	self assert: true! !
!Doors100Test methodsFor: 'as yet unclassified' stamp: 'I 5/8/2024 18:56:08' prior: 50598285!
Test01AfterTheFirstPassAllDoorsAreOpen
	
	|doors|
	doors = Doors100 new.
	self assert: true equal: doors pass: 1.! !
!Doors100 class methodsFor: 'nil' stamp: 'I 5/8/2024 18:57:01'!
intialize
	^self new initializeWith: 100.! !
!Doors100 methodsFor: 'nil' stamp: 'I 5/8/2024 18:57:22'!
initializeWith: numberOfDoors
	! !

Object subclass: #Doors100
	instanceVariableNames: 'doors'
	classVariableNames: ''
	poolDictionaries: ''
	category: '100 Doors Problem'!

!classDefinition: #Doors100 category: #'100 Doors Problem' stamp: 'I 5/8/2024 18:57:28'!
Object subclass: #Doors100
	instanceVariableNames: 'doors'
	classVariableNames: ''
	poolDictionaries: ''
	category: '100 Doors Problem'!
!Doors100 methodsFor: 'as yet unclassified' stamp: 'I 5/8/2024 18:57:45' prior: 50598300!
initializeWith: numberOfDoors
	doors := OrderedCollection new! !
!Doors100 methodsFor: 'as yet unclassified' stamp: 'I 5/8/2024 19:00:08' prior: 50598316!
initializeWith: numberOfDoors
	doors := OrderedCollection new: 100.
	
	1 to: 100 do: [:i | doors at: i put: false].! !
!Doors100Test methodsFor: 'as yet unclassified' stamp: 'I 5/8/2024 19:01:43' prior: 50598290!
Test01AfterTheFirstPassAllDoorsAreOpen
	
	|doors|
	doors = Doors100 new.
	doors pass:1.
	self assert: true equal: doors isOpenAt: 1.! !
!Doors100 methodsFor: 'nil' stamp: 'I 5/8/2024 19:03:30'!
pass
	1 to: 100 do: [:i| doors at: i put: true].
	! !
!Doors100 methodsFor: 'as yet unclassified' stamp: 'I 5/8/2024 19:03:58'!
isOpenAt: aDoorNumber
	^doors at: aDoorNumber.
	! !
!Doors100Test methodsFor: 'as yet unclassified' stamp: 'I 5/8/2024 19:04:26'!
test01AfterTheFirstPassAllDoorsAreOpen
	
	|doors|
	doors = Doors100 new.
	doors pass:1.
	self assert: true equal: doors isOpenAt: 1.! !

!methodRemoval: Doors100Test #Test01AfterTheFirstPassAllDoorsAreOpen stamp: 'I 5/8/2024 19:04:34'!
Test01AfterTheFirstPassAllDoorsAreOpen
	
	|doors|
	doors = Doors100 new.
	doors pass:1.
	self assert: true equal: doors isOpenAt: 1.!

!testRun: #GameOfLifeTest #test01AliveCellWithLessThanTwoAliveNeighDies stamp: 'I 5/8/2024 19:04:44'!
PASSED!

!testRun: #GameOfLifeTest #test02AliveCellWithTwoAliveNeighStaysAlive stamp: 'I 5/8/2024 19:04:44'!
PASSED!

!testRun: #GameOfLifeTest #test03AliveCellWithThreeAliveNeighStaysAlive stamp: 'I 5/8/2024 19:04:44'!
PASSED!

!testRun: #GameOfLifeTest #test04AliveCellWithMoreThanThreeAliveNeighDies stamp: 'I 5/8/2024 19:04:44'!
PASSED!

!testRun: #GameOfLifeTest #test05DeadCellWithThreeAliveNeighResurects stamp: 'I 5/8/2024 19:04:44'!
PASSED!

!testRun: #GameOfLifeTest #test06CreateCellOutsideBounds stamp: 'I 5/8/2024 19:04:44'!
PASSED!
!Doors100Test methodsFor: 'tests' stamp: 'I 5/8/2024 19:05:16' prior: 50598344!
test01AfterTheFirstPassAllDoorsAreOpen
	
	|doors|
	doors = Doors100 new.
	doors pass:1.
	self assert: true equal: (doors isOpenAt: 1).! !
!Doors100Test methodsFor: 'tests' stamp: 'I 5/8/2024 19:05:42' prior: 50598379!
test01AfterTheFirstPassAllDoorsAreOpen
	
	|doors|
	doors = Doors100 new.
	doors pass:1.
	self assert: true equals: (doors isOpenAt: 1).! !
!Doors100Test methodsFor: 'tests' stamp: 'I 5/8/2024 19:05:49' prior: 50598386!
test01AfterTheFirstPassAllDoorsAreOpen
	
	|doors|
	doors = Doors100 new.
	doors pass.
	self assert: true equals: (doors isOpenAt: 1).! !

!classRemoval: #NameOfSubclass stamp: 'I 5/8/2024 19:06:07'!
Object subclass: #NameOfSubclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '100 Doors Problem'!
!Doors100Test methodsFor: 'tests' stamp: 'I 5/8/2024 19:06:32'!
test02
	self assert: true equals: false! !
!Doors100Test methodsFor: 'tests' stamp: 'I 5/8/2024 19:09:09' prior: 50598393!
test01AfterTheFirstPassAllDoorsAreOpen
	
	|door|
	door = Doors100 new.
	door pass.
	self assert: true equals: (door isOpenAt: 1).! !
!Doors100Test methodsFor: 'tests' stamp: 'I 5/8/2024 19:09:16' prior: 50598410!
test01AfterTheFirstPassAllDoorsAreOpen
	
	|door|
	door := Doors100 new.
	door pass.
	self assert: true equals: (door isOpenAt: 1).! !

----STARTUP---- (9 May 2024 11:04:38) as /home/ivan/Documents/Facu/Inge 1/linux64/linux64/CuisUniversity-6169.image!


!classDefinition: #ABCProblemTest category: #'ABC Problem' stamp: 'I 5/9/2024 11:48:19'!
TestCase subclass: #ABCProblemTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ABC Problem'!

!classDefinition: #ABCProblemTest category: #'ABC Problem' stamp: 'I 5/9/2024 11:48:19'!
TestCase subclass: #ABCProblemTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ABC Problem'!
!ABCProblemTest methodsFor: 'tests' stamp: 'HAW 2/14/2023 12:17:51'!
test01CanWriteOneLetterAsFirstCharInFirstBlock

	self assert: (self canWrite: 'B' with: #(($B $O)))! !
!ABCProblemTest methodsFor: 'tests' stamp: 'HAW 2/14/2023 12:17:58'!
test02CannotWriteOneLetterNotIncludedInFirstBlock

	self deny: (self canWrite: 'W' with: #(($B $O)))! !
!ABCProblemTest methodsFor: 'tests' stamp: 'HAW 2/14/2023 12:18:04'!
test03CanWriteOneLetterIncludedInFirstBlock

	self assert: (self canWrite: 'O' with: #(($B $O)))! !
!ABCProblemTest methodsFor: 'tests' stamp: 'HAW 2/14/2023 12:18:34'!
test04CanWriteOneLetterIncludedInAnyBlock

	self assert: (self canWrite: 'X' with: #(($B $O) ($X $K)))! !
!ABCProblemTest methodsFor: 'tests' stamp: 'HAW 2/14/2023 12:19:15'!
test05CannotWriteWhenOtherThanFirstLetterIsNotIncludedInBlocks

	self deny: (self canWrite: 'BW' with: #(($B $O) ($X $K)))! !
!ABCProblemTest methodsFor: 'tests' stamp: 'HAW 2/14/2023 12:20:13'!
test06RemovesUsedBlocks

	self deny: (self canWrite: 'BB' with: #(($B $O) ($X $K)))! !
!ABCProblemTest methodsFor: 'tests' stamp: 'HAW 2/14/2023 12:20:52'!
test07PassesExerciseWordsWithDefaultBlocks

	self assert: (self canWrite: 'A').
	self assert: (self canWrite: 'BARK').
	self deny: (self canWrite: 'BOOK').
	self assert: (self canWrite: 'TREAT').
	self deny: (self canWrite: 'COMMON').
	self assert: (self canWrite: 'SQUAD').
	self assert: (self canWrite: 'CONFUSE').
! !
!ABCProblemTest methodsFor: 'can write' stamp: 'HAW 2/14/2023 12:10:45'!
canWrite: aWord 
	
	^ABCProblem canWrite: aWord! !
!ABCProblemTest methodsFor: 'can write' stamp: 'HAW 2/14/2023 12:05:08'!
canWrite: aWord with: originalBlocks

	^ABCProblem canWrite: aWord with: originalBlocks! !

!classDefinition: #ABCProblem category: #'ABC Problem' stamp: 'I 5/9/2024 11:48:19'!
Object subclass: #ABCProblem
	instanceVariableNames: 'word blocks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ABC Problem'!

!classDefinition: #ABCProblem category: #'ABC Problem' stamp: 'I 5/9/2024 11:48:19'!
Object subclass: #ABCProblem
	instanceVariableNames: 'word blocks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ABC Problem'!
!ABCProblem methodsFor: 'initialization' stamp: 'HAW 2/14/2023 12:06:57'!
initializeFor: aWord with: originalBlocks

	word := aWord.
	blocks := OrderedCollection withAll: originalBlocks.! !
!ABCProblem methodsFor: 'evaluating' stamp: 'HAW 2/14/2023 12:06:57' overrides: 16914075!
value 
	
	| index |
	
	^word allSatisfy: [ :aLetter |
		index := blocks findFirst: [ :aBlock | aBlock includes: aLetter ].
		index = 0 
			ifTrue: [ false ]
			ifFalse: [ blocks removeAt: index . true ]]! !

!classDefinition: 'ABCProblem class' category: #'ABC Problem' stamp: 'I 5/9/2024 11:48:19'!
ABCProblem class
	instanceVariableNames: ''!

!classDefinition: 'ABCProblem class' category: #'ABC Problem' stamp: 'I 5/9/2024 11:48:19'!
ABCProblem class
	instanceVariableNames: ''!
!ABCProblem class methodsFor: 'instance creation' stamp: 'HAW 2/14/2023 12:07:31'!
for: aWord with: anOriginalBlocks

	^self new initializeFor: aWord with: anOriginalBlocks! !
!ABCProblem class methodsFor: 'testing' stamp: 'HAW 2/14/2023 12:12:02'!
canWrite: aWord

	^self canWrite: aWord with: self defaultBlocks! !
!ABCProblem class methodsFor: 'testing' stamp: 'HAW 2/14/2023 12:05:32'!
canWrite: aWord with: originalBlocks 
	
	^(ABCProblem for: aWord with: originalBlocks) value! !
!ABCProblem class methodsFor: 'defaults' stamp: 'HAW 2/14/2023 12:14:53'!
defaultBlocks
	
	^#(
		#($B $O) 
		#($X $K) 
		#($D $Q) 
		#($C $P) 
		#($N $A) 
		#($G $T) 
		#($R $E) 
		#($T $G) 
		#($Q $D) 
		#($F $S) 
		#($J $W) 
		#($H $U) 
		#($V $I) 
		#($A $N) 
		#($O $B) 
		#($E $R) 
		#($F $S) 
		#($L $Y) 
		#($P $C) 
		#($Z $M))! !

!classDefinition: #GameOfLifeView category: #'GameOfLife-Smalltalks2022' stamp: 'I 5/9/2024 11:48:19'!
ImageMorph subclass: #GameOfLifeView
	instanceVariableNames: 'game'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife-Smalltalks2022'!

!classDefinition: #GameOfLifeView category: #'GameOfLife-Smalltalks2022' stamp: 'I 5/9/2024 11:48:19'!
ImageMorph subclass: #GameOfLifeView
	instanceVariableNames: 'game'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife-Smalltalks2022'!

!classDefinition: 'GameOfLifeView class' category: #'GameOfLife-Smalltalks2022' stamp: 'I 5/9/2024 11:48:19'!
GameOfLifeView class
	instanceVariableNames: ''!

!classDefinition: 'GameOfLifeView class' category: #'GameOfLife-Smalltalks2022' stamp: 'I 5/9/2024 11:48:19'!
GameOfLifeView class
	instanceVariableNames: ''!

!classDefinition: #GameOfLifeWindow category: #'GameOfLife-Smalltalks2022' stamp: 'I 5/9/2024 11:48:19'!
SystemWindow subclass: #GameOfLifeWindow
	instanceVariableNames: 'gameView editor range'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife-Smalltalks2022'!

!classDefinition: #GameOfLifeWindow category: #'GameOfLife-Smalltalks2022' stamp: 'I 5/9/2024 11:48:19'!
SystemWindow subclass: #GameOfLifeWindow
	instanceVariableNames: 'gameView editor range'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife-Smalltalks2022'!

!classDefinition: 'GameOfLifeWindow class' category: #'GameOfLife-Smalltalks2022' stamp: 'I 5/9/2024 11:48:19'!
GameOfLifeWindow class
	instanceVariableNames: ''!

!classDefinition: 'GameOfLifeWindow class' category: #'GameOfLife-Smalltalks2022' stamp: 'I 5/9/2024 11:48:19'!
GameOfLifeWindow class
	instanceVariableNames: ''!

!classDefinition: #GameOfLifeTest category: #'GameOfLife-Smalltalks2022' stamp: 'I 5/9/2024 11:48:19'!
TestCase subclass: #GameOfLifeTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife-Smalltalks2022'!

!classDefinition: #GameOfLifeTest category: #'GameOfLife-Smalltalks2022' stamp: 'I 5/9/2024 11:48:19'!
TestCase subclass: #GameOfLifeTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife-Smalltalks2022'!

!classDefinition: 'GameOfLifeTest class' category: #'GameOfLife-Smalltalks2022' stamp: 'I 5/9/2024 11:48:19'!
GameOfLifeTest class
	instanceVariableNames: ''!

!classDefinition: 'GameOfLifeTest class' category: #'GameOfLife-Smalltalks2022' stamp: 'I 5/9/2024 11:48:19'!
GameOfLifeTest class
	instanceVariableNames: ''!

!classDefinition: #GameOfLife category: #'GameOfLife-Smalltalks2022' stamp: 'I 5/9/2024 11:48:19'!
Object subclass: #GameOfLife
	instanceVariableNames: 'aliveCells size'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife-Smalltalks2022'!

!classDefinition: #GameOfLife category: #'GameOfLife-Smalltalks2022' stamp: 'I 5/9/2024 11:48:19'!
Object subclass: #GameOfLife
	instanceVariableNames: 'aliveCells size'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife-Smalltalks2022'!

!classDefinition: 'GameOfLife class' category: #'GameOfLife-Smalltalks2022' stamp: 'I 5/9/2024 11:48:19'!
GameOfLife class
	instanceVariableNames: ''!

!classDefinition: 'GameOfLife class' category: #'GameOfLife-Smalltalks2022' stamp: 'I 5/9/2024 11:48:19'!
GameOfLife class
	instanceVariableNames: ''!
!GameOfLifeView methodsFor: 'initialization' stamp: 'HAW 11/9/2022 16:06:07'!
initializeFor: aGameOfLife

	game := aGameOfLife.
	self image: (Form extent: game boardSize * self cellLength depth: 2).! !
!GameOfLifeView methodsFor: 'openinig' stamp: 'HAW 6/11/2018 15:26:19'!
open

	self showBoard.
	self openInWorld.
	self startSteppingStepTime: 500! !
!GameOfLifeView methodsFor: 'showing' stamp: 'HAW 11/9/2022 16:22:15'!
cellLength

	^ 50! !
!GameOfLifeView methodsFor: 'showing' stamp: 'HAW 11/10/2022 11:41:05'!
showBoard

	game cellsDo: [ :aPoint | | startingPoint extentLenght rectangleToFill|
		startingPoint := aPoint*self cellLength.
		extentLenght := self cellLength-2.
		rectangleToFill := (startingPoint + (`1@1`)) extent: extentLenght@extentLenght.
		
		self form border: (startingPoint extent: self cellLength@self cellLength) width: 1 fillColor: Color black.
		(game isAliveAt: aPoint)
				ifTrue: [ self form fillBlack: rectangleToFill ]
				ifFalse: [ self form fillWhite: rectangleToFill ]]
				! !
!GameOfLifeView methodsFor: 'showing' stamp: 'HAW 11/9/2022 16:30:18' overrides: 16906449!
step

	game nextGeneration.
	self showBoard.
	self redrawNeeded.

! !
!GameOfLifeView methodsFor: 'showing' stamp: 'HAW 11/9/2022 16:12:21'!
viewSize
	
	^game boardSize * self cellLength ! !
!GameOfLifeView class methodsFor: 'examples' stamp: 'HAW 6/11/2018 15:20:47'!
blinker

	^GameOfLife withLiveCells: { 4@2. 4@3. 4@4. 3@3. 4@3. 5@3 } withSize: 10@10! !
!GameOfLifeView class methodsFor: 'examples' stamp: 'HAW 6/11/2018 15:25:24'!
toad

	^GameOfLife withLiveCells: { 2@4. 3@4. 4@4. 3@3. 4@3. 5@3 } withSize: 10@10
	
	! !
!GameOfLifeView class methodsFor: 'open examples' stamp: 'HAW 6/11/2018 15:20:12'!
openBlinker

	^self openFor: self blinker! !
!GameOfLifeView class methodsFor: 'open examples' stamp: 'HAW 6/12/2018 06:40:45'!
openRandomOf: aSize

	"
	self openRandomOf: 100@100
	self openRandomOf: 50@50
	"
	
	^self openFor: (self randomOf: aSize)
	
	! !
!GameOfLifeView class methodsFor: 'open examples' stamp: 'HAW 6/12/2018 08:05:40'!
openToad

	^self openFor: self toad! !
!GameOfLifeView class methodsFor: 'instance creation' stamp: 'HAW 6/11/2018 15:10:57'!
for: aGameOfLife

	^self new initializeFor: aGameOfLife! !
!GameOfLifeView class methodsFor: 'instance creation' stamp: 'HAW 6/11/2018 15:19:13'!
openFor: aGameOfLife

	^(self for: aGameOfLife) open! !
!GameOfLifeView class methodsFor: 'instance creation' stamp: 'HAW 11/9/2022 16:48:34'!
randomOf15
	
	^GameOfLife withLiveCells: (GameOfLife randomAliveCellsOf: 15@15) withSize: 15@15
	
	
	
! !
!GameOfLifeView class methodsFor: 'instance creation' stamp: 'HAW 11/9/2022 16:49:18'!
randomOf: aSize
	
	^GameOfLife withLiveCells: (GameOfLife randomAliveCellsOf: aSize) withSize: aSize
	
	
	
! !
!GameOfLifeWindow methodsFor: 'testing' stamp: 'HAW 11/10/2022 09:46:11'!
isAtFirstColumn: localEventPosition 
	
	^ localEventPosition x between: 0 and: gameView cellLength! !
!GameOfLifeWindow methodsFor: 'testing' stamp: 'HAW 11/10/2022 09:49:24'!
isAtFirstLine: localEventPosition 
	
	^ localEventPosition y -50  between: 0 and: gameView cellLength! !
!GameOfLifeWindow methodsFor: 'testing' stamp: 'HAW 11/10/2022 09:44:25'!
isAtLastColumn: localEventPosition

	^ localEventPosition x + gameView cellLength >= gameView viewSize x! !
!GameOfLifeWindow methodsFor: 'testing' stamp: 'HAW 11/10/2022 09:44:38'!
isAtLastLine: localEventPosition

	^ localEventPosition y + gameView cellLength >= gameView viewSize y! !
!GameOfLifeWindow methodsFor: 'board' stamp: 'HAW 11/10/2022 11:01:20'!
addColumn
	
	self changeGameViewFor: [ model addColumn ].
! !
!GameOfLifeWindow methodsFor: 'board' stamp: 'HAW 11/10/2022 09:42:38'!
addLine
	
	self changeGameViewFor: [ model addLine ].
	! !
!GameOfLifeWindow methodsFor: 'board' stamp: 'HAW 12/1/2023 16:35:11'!
regenerateCode

	| newMessageSendCode originalCode  newSourceCode |
	
	originalCode := CodeProvider normalizeCodeForCodeFiles: editor actualContents.
	newMessageSendCode := String streamContents: [:stream |
		stream nextPutAll: 'GameOfLife withLiveCells: {'.
		model aliveCellsDo: [ :cell | stream print: cell; nextPutAll: '. ' ].
		stream nextPutAll: '} withSize: '.
		stream print: model boardSize.
		stream nextPut: $. ].
	
	newSourceCode := originalCode copyReplaceFrom: range first to: range last with: newMessageSendCode.
	range := range first to: range first + newMessageSendCode size - 1.
	editor actualContents: newSourceCode.
	editor hasUnacceptedEdits: true
	
		
							
							! !
!GameOfLifeWindow methodsFor: 'board' stamp: 'HAW 11/10/2022 09:47:14'!
removeColumn
	
	self changeGameViewFor: [ model removeColumn ]! !
!GameOfLifeWindow methodsFor: 'board' stamp: 'HAW 11/10/2022 09:49:40'!
removeLine
	
	self changeGameViewFor: [ model removeLine ]! !
!GameOfLifeWindow methodsFor: 'GUI building' stamp: 'HAW 11/9/2022 16:23:48'!
adjustExtentToGameView

	self morphExtent: gameView viewSize.
	! !
!GameOfLifeWindow methodsFor: 'GUI building' stamp: 'HAW 11/9/2022 16:31:54'!
buildMorphicWindow

	gameView := GameOfLifeView for: model.
	
	self layoutMorph 
		addMorph: gameView.
		
	gameView showBoard.
	! !
!GameOfLifeWindow methodsFor: 'GUI building' stamp: 'HAW 11/10/2022 09:43:06'!
changeGameViewFor: aBlock

	layoutMorph removeMorph: gameView.
	aBlock value.
	gameView := GameOfLifeView for: model.
	layoutMorph addMorph: gameView.
	gameView showBoard.
	self adjustExtentToGameView ! !
!GameOfLifeWindow methodsFor: 'GUI building' stamp: 'HAW 11/10/2022 11:00:49'!
editor: anEditor methodNode: aMethodNode messageSendNode: aMessageNodeToChange

	editor := anEditor.
	range := (aMethodNode completeSourceRangesOf: aMessageNodeToChange ifAbsent: [^self shouldNotHappen ]) anyOne.
	! !
!GameOfLifeWindow methodsFor: 'events' stamp: 'HAW 11/9/2022 16:37:27' overrides: 16904279!
handlesMouseDown: aMouseButtonEvent
	^ true! !
!GameOfLifeWindow methodsFor: 'events' stamp: 'HAW 12/1/2023 16:46:37' overrides: 16904072!
mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition

	aMouseButtonEvent shiftPressed ifTrue: [
		(self isAtLastColumn: localEventPosition) ifTrue: [ ^self addColumn; regenerateCode ].
		(self isAtFirstColumn: localEventPosition) ifTrue: [ ^self removeColumn; regenerateCode ].
		(self isAtLastLine: localEventPosition) ifTrue: [ ^self addLine; regenerateCode ].
		(self isAtFirstLine: localEventPosition) ifTrue: [ ^self removeLine; regenerateCode ]].
	
	gameView step.
	! !
!GameOfLifeWindow methodsFor: 'events' stamp: 'HAW 11/10/2022 10:59:19' overrides: 16904102!
mouseButton2Down: aMouseButtonEvent localPosition: localEventPosition

	| cellPoint |
	
	cellPoint := (localEventPosition / gameView cellLength) asIntegerPoint.
	cellPoint := cellPoint x + 1 @ cellPoint y - 1.
	
	model switchCellStatus: cellPoint .
	gameView showBoard; redrawNeeded.
	self regenerateCode
	! !
!GameOfLifeTest methodsFor: 'tests' stamp: 'HAW 5/11/2017 21:14:07'!
test01AliveCellWithLessThanTwoAliveNeighDies

	|gameOfLife |
	
	gameOfLife := GameOfLife withLiveCells: { 1@1 }  withSize: 3@3.
	gameOfLife nextGeneration.
	
	self assert: (gameOfLife isDeadAt: 1@1) ! !
!GameOfLifeTest methodsFor: 'tests' stamp: 'HAW 5/11/2017 21:14:14'!
test02AliveCellWithTwoAliveNeighStaysAlive

	|gameOfLife |
	
	gameOfLife := GameOfLife withLiveCells: { 1@1. 2@0. 1@0. }  withSize: 3@3.
	gameOfLife nextGeneration.
	
	self deny: (gameOfLife isDeadAt: 1@1) ! !
!GameOfLifeTest methodsFor: 'tests' stamp: 'HAW 5/11/2017 21:14:19'!
test03AliveCellWithThreeAliveNeighStaysAlive

	|gameOfLife |
	
	gameOfLife := GameOfLife withLiveCells: { 1@1. 2@0. 1@0. 1@2. }  withSize: 3@3.
	gameOfLife nextGeneration.
	
	self deny: (gameOfLife isDeadAt: 1@1) ! !
!GameOfLifeTest methodsFor: 'tests' stamp: 'HAW 5/11/2017 21:14:25'!
test04AliveCellWithMoreThanThreeAliveNeighDies

	|gameOfLife |
	
	gameOfLife := GameOfLife withLiveCells: { 1@1. 2@0. 1@0. 1@2. 0@1 } withSize: 3@3.
	gameOfLife nextGeneration.
	
	self assert: (gameOfLife isDeadAt: 1@1) ! !
!GameOfLifeTest methodsFor: 'tests' stamp: 'HAW 5/11/2017 21:01:13'!
test05DeadCellWithThreeAliveNeighResurects

	|gameOfLife |
	
	gameOfLife := GameOfLife withLiveCells: { 2@0. 1@0. 0@0 } withSize: 3@3.
	gameOfLife nextGeneration.
	
	self deny: (gameOfLife isDeadAt: 1@1) ! !
!GameOfLifeTest methodsFor: 'tests' stamp: 'HAW 6/5/2020 16:00:49'!
test06CreateCellOutsideBounds

	self 
		should: [ GameOfLife withLiveCells: { 2@0. 1@0. 1@4 } withSize: 3@3 ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Celda 1@4 fuera de rango' ]! !
!GameOfLife methodsFor: 'initialization' stamp: 'HAW 6/4/2020 20:23:18'!
initializeWith: aCollectionOfAliveCells withSize: aSize

	size := aSize.
	aliveCells := aCollectionOfAliveCells asSet.
! !
!GameOfLife methodsFor: 'next generation' stamp: 'HAW 9/8/2017 14:15:27'!
nextGeneration
	
	aliveCells := self cellsToSurviveOnNextGeneration union: self cellsToResurectOnNextGeneration! !
!GameOfLife methodsFor: 'cells' stamp: 'HAW 11/10/2022 10:39:09'!
aliveCellsDo: aBlock
	
	^aliveCells do: aBlock 
! !
!GameOfLife methodsFor: 'cells' stamp: 'HAW 6/11/2018 12:05:57'!
cellsDo: aBlock
	
	0 to: size x do: [ :x | 0 to: size y do: [ :y | aBlock value: x@y ]]! !
!GameOfLife methodsFor: 'cells' stamp: 'HAW 6/12/2018 14:06:46'!
cellsToResurectOnNextGeneration

	| cellsToResurect |
	
	cellsToResurect := Set new.
	self deadCellsDo: [ :aDeadCell | (self hasToResurrect: aDeadCell) ifTrue: [ cellsToResurect add: aDeadCell]].
	
	^cellsToResurect ! !
!GameOfLife methodsFor: 'cells' stamp: 'HAW 9/8/2017 14:14:50'!
cellsToSurviveOnNextGeneration
		
	^aliveCells select: [ :aCell | self hasToSurvive: aCell ]! !
!GameOfLife methodsFor: 'cells' stamp: 'HAW 6/5/2020 16:03:06'!
deadCellsDo: aBlock
	
	self cellsDo: [ :aPosition | (self isDeadAt: aPosition) ifTrue: [ aBlock value: aPosition ]].
! !
!GameOfLife methodsFor: 'cells' stamp: 'HAW 5/10/2017 10:29:35'!
numberOfAliveNeighboursOf: aCell

	^(aCell eightNeighbors intersection: aliveCells) size! !
!GameOfLife methodsFor: 'cells' stamp: 'HAW 11/10/2022 10:11:11'!
switchCellStatus: cell 
	
	(self isAliveAt: cell)
		ifTrue: [ aliveCells remove: cell ifAbsent: [] ]
		ifFalse: [ aliveCells add: cell ]! !
!GameOfLife methodsFor: 'testing' stamp: 'HAW 5/11/2017 21:11:17'!
hasToResurrect: aCell

	^(self numberOfAliveNeighboursOf: aCell) = 3! !
!GameOfLife methodsFor: 'testing' stamp: 'HAW 5/11/2017 19:57:05'!
hasToSurvive: aCell
	
	| numberOfAliveNeighbours|
	
	numberOfAliveNeighbours := self numberOfAliveNeighboursOf: aCell.
	
	^numberOfAliveNeighbours = 2 or:  [numberOfAliveNeighbours = 3]! !
!GameOfLife methodsFor: 'testing' stamp: 'HAW 6/11/2018 12:06:29'!
isAliveAt: aCell

	^aliveCells includes: aCell! !
!GameOfLife methodsFor: 'testing' stamp: 'HAW 6/4/2020 20:26:06'!
isDeadAt: aCell

	^(self isAliveAt: aCell) not! !
!GameOfLife methodsFor: 'board' stamp: 'HAW 11/10/2022 09:37:26'!
addColumn
	
	size := size x + 1 @ size y! !
!GameOfLife methodsFor: 'board' stamp: 'HAW 11/10/2022 09:43:31'!
addLine
	
	size := size x @ (size y + 1)! !
!GameOfLife methodsFor: 'board' stamp: 'HAW 6/11/2018 15:12:41'!
boardSize

	^size ! !
!GameOfLife methodsFor: 'board' stamp: 'HAW 11/10/2022 11:56:03'!
removeColumn
	
	size := size x - 1 @ size y.
	aliveCells := aliveCells reject: [ :aCell | aCell x = size x ].
	! !
!GameOfLife methodsFor: 'board' stamp: 'HAW 11/10/2022 11:56:44'!
removeLine
	
	size := size x @ (size y - 1).
	aliveCells := aliveCells reject: [ :aCell | aCell y = size y ].
! !
!GameOfLife class methodsFor: 'instance creation' stamp: 'HAW 11/9/2022 16:42:14'!
randomAliveCellsOf: aSize

	| aliveCells random |
	
	random := Random new.
	aliveCells := OrderedCollection new.
	1 to: aSize x do: [ :x | 
		1 to: aSize y do: [ :y | random next >= 0.5 ifTrue: [ aliveCells add: x@y ] ]].
	
	^aliveCells ! !
!GameOfLife class methodsFor: 'instance creation' stamp: 'HAW 11/9/2022 16:43:32'!
randomOf: aSize
	
	^self withLiveCells: (self randomAliveCellsOf: aSize) withSize: aSize! !
!GameOfLife class methodsFor: 'instance creation' stamp: 'HAW 6/5/2020 16:01:33'!
withLiveCells: aCollectionOfAliveCells withSize: aSize 
	
	self assertAll: aCollectionOfAliveCells areInside: aSize.

	^self new initializeWith: aCollectionOfAliveCells withSize: aSize ! !
!GameOfLife class methodsFor: 'assertions' stamp: 'HAW 6/5/2020 16:01:33'!
assertAll: aCollectionOfAliveCells areInside: aSize

	| origin |
	
	origin := 0@0.
	aCollectionOfAliveCells do: [:aCell |
		(aCell between: origin and: aSize) ifFalse: [ self error: 'Celda ', aCell printString,' fuera de rango' ]]! !
!BraceNode methodsFor: '*GameOfLife-Smalltalks2022' stamp: 'HAW 12/1/2023 16:27:00'!
eval
	^elements collect: [ :aNode | aNode eval ].! !
!MessageNode methodsFor: '*GameOfLife-Smalltalks2022' stamp: 'HAW 12/1/2023 16:32:06' prior: 16895661!
eval
	"When everything in me is a constant, I can produce a value.  This is only used by the Scripting system (TilePadMorph tilesFrom:in:)"

	| rec args |
	(receiver isVariableNode or: [ receiver isLiteralNode ]) ifFalse: [^ #illegal].
	rec := receiver key value.
	args := arguments collect: [:each | each eval].
	^ rec perform: selector key withArguments: args! !
!SmalltalkEditor methodsFor: '*GameOfLife-Smalltalks2022' stamp: 'HAW 12/1/2023 16:30:48' overrides: 16980716!
mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition

	^aMouseButtonEvent shiftPressed
		ifTrue: [ self showGameOfLifeBoardIfNecessaryIn: (morph positionInTextOf: localEventPosition ) ]
		ifFalse: [ super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition ]
! !
!SmalltalkEditor methodsFor: '*GameOfLife-Smalltalks2022' stamp: 'HAW 11/17/2022 16:39:49'!
showGameOfLifeBoardIfNecessaryIn: mousePositionInText

	| game |
	self 
		withMethodNodeAndClassDo: [ :methodNode :class | 
			methodNode 
				withParseNodeIncluding: mousePositionInText 
				do: [ :aNodeUnderCursor | 
					(aNodeUnderCursor isMessage 
						and: [ aNodeUnderCursor receiver isLiteralVariableNode
						and: [ aNodeUnderCursor receiver key value = GameOfLife 
						and: [ aNodeUnderCursor selectorSymbol = #withLiveCells:withSize: ]]]) ifTrue: [
							game := [ aNodeUnderCursor eval ] on: Error do: [ :e | ^self ].
							(GameOfLifeWindow open: game label: 'GameOfLife') 
								adjustExtentToGameView;
								editor: self methodNode: methodNode messageSendNode: aNodeUnderCursor ]
					 ]
				ifAbsent: []]
		ifErrorsParsing: [ :anError |  ]


! !

!classDefinition: #NameOfSubclass category: #'100 Doors Problem' stamp: 'I 5/9/2024 11:48:20'!
Object subclass: #NameOfSubclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '100 Doors Problem'!

!classDefinition: #NameOfSubclass category: #'100 Doors Problem' stamp: 'I 5/9/2024 11:48:20'!
Object subclass: #NameOfSubclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '100 Doors Problem'!

!classDefinition: #Doors100 category: #'100 Doors Problem' stamp: 'I 5/9/2024 11:48:20'!
Object subclass: #Doors100
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '100 Doors Problem'!

!classDefinition: #Doors100 category: #'100 Doors Problem' stamp: 'I 5/9/2024 11:48:20'!
Object subclass: #Doors100
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '100 Doors Problem'!

!classDefinition: #Doors100Test category: #'100 Doors Problem' stamp: 'I 5/9/2024 11:48:20'!
Object subclass: #Doors100Test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '100 Doors Problem'!

!classDefinition: #Doors100Test category: #'100 Doors Problem' stamp: 'I 5/9/2024 11:48:20'!
Object subclass: #Doors100Test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '100 Doors Problem'!
!Doors100Test methodsFor: 'nil' stamp: 'I 5/8/2024 18:53:01'!
Test01AfterTheFirstPassAllDoorsAreOpen! !
!Doors100Test methodsFor: 'as yet unclassified' stamp: 'I 5/8/2024 18:54:36' prior: 50599195!
Test01AfterTheFirstPassAllDoorsAreOpen
	
	self assert: true! !
!Doors100Test methodsFor: 'as yet unclassified' stamp: 'I 5/8/2024 18:56:08' prior: 50599200!
Test01AfterTheFirstPassAllDoorsAreOpen
	
	|doors|
	doors = Doors100 new.
	self assert: true equal: doors pass: 1.! !
!Doors100 class methodsFor: 'nil' stamp: 'I 5/8/2024 18:57:01'!
intialize
	^self new initializeWith: 100.! !
!Doors100 methodsFor: 'nil' stamp: 'I 5/8/2024 18:57:22'!
initializeWith: numberOfDoors
	! !

!classDefinition: #Doors100 category: #'100 Doors Problem' stamp: 'I 5/9/2024 11:48:20'!
Object subclass: #Doors100
	instanceVariableNames: 'doors'
	classVariableNames: ''
	poolDictionaries: ''
	category: '100 Doors Problem'!

!classDefinition: #Doors100 category: #'100 Doors Problem' stamp: 'I 5/9/2024 11:48:20'!
Object subclass: #Doors100
	instanceVariableNames: 'doors'
	classVariableNames: ''
	poolDictionaries: ''
	category: '100 Doors Problem'!
!Doors100 methodsFor: 'as yet unclassified' stamp: 'I 5/8/2024 18:57:45' prior: 50599215!
initializeWith: numberOfDoors
	doors := OrderedCollection new! !
!Doors100 methodsFor: 'as yet unclassified' stamp: 'I 5/8/2024 19:00:08' prior: 50599234!
initializeWith: numberOfDoors
	doors := OrderedCollection new: 100.
	
	1 to: 100 do: [:i | doors at: i put: false].! !
!Doors100Test methodsFor: 'as yet unclassified' stamp: 'I 5/8/2024 19:01:43' prior: 50599205!
Test01AfterTheFirstPassAllDoorsAreOpen
	
	|doors|
	doors = Doors100 new.
	doors pass:1.
	self assert: true equal: doors isOpenAt: 1.! !
!Doors100 methodsFor: 'nil' stamp: 'I 5/8/2024 19:03:30'!
pass
	1 to: 100 do: [:i| doors at: i put: true].
	! !
!Doors100 methodsFor: 'as yet unclassified' stamp: 'I 5/8/2024 19:03:58'!
isOpenAt: aDoorNumber
	^doors at: aDoorNumber.
	! !
!Doors100Test methodsFor: 'as yet unclassified' stamp: 'I 5/8/2024 19:04:26'!
test01AfterTheFirstPassAllDoorsAreOpen
	
	|doors|
	doors = Doors100 new.
	doors pass:1.
	self assert: true equal: doors isOpenAt: 1.! !

!methodRemoval: Doors100Test #Test01AfterTheFirstPassAllDoorsAreOpen stamp: 'I 5/9/2024 11:48:20'!
Test01AfterTheFirstPassAllDoorsAreOpen
	
	|doors|
	doors = Doors100 new.
	doors pass:1.
	self assert: true equal: doors isOpenAt: 1.!
!Doors100Test methodsFor: 'tests' stamp: 'I 5/8/2024 19:05:16' prior: 50599262!
test01AfterTheFirstPassAllDoorsAreOpen
	
	|doors|
	doors = Doors100 new.
	doors pass:1.
	self assert: true equal: (doors isOpenAt: 1).! !
!Doors100Test methodsFor: 'tests' stamp: 'I 5/8/2024 19:05:42' prior: 50599277!
test01AfterTheFirstPassAllDoorsAreOpen
	
	|doors|
	doors = Doors100 new.
	doors pass:1.
	self assert: true equals: (doors isOpenAt: 1).! !
!Doors100Test methodsFor: 'tests' stamp: 'I 5/8/2024 19:05:49' prior: 50599284!
test01AfterTheFirstPassAllDoorsAreOpen
	
	|doors|
	doors = Doors100 new.
	doors pass.
	self assert: true equals: (doors isOpenAt: 1).! !

!classRemoval: #NameOfSubclass stamp: 'I 5/9/2024 11:48:21'!
Object subclass: #NameOfSubclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '100 Doors Problem'!
!Doors100Test methodsFor: 'tests' stamp: 'I 5/8/2024 19:06:32'!
test02
	self assert: true equals: false! !
!Doors100Test methodsFor: 'tests' stamp: 'I 5/8/2024 19:09:09' prior: 50599291!
test01AfterTheFirstPassAllDoorsAreOpen
	
	|door|
	door = Doors100 new.
	door pass.
	self assert: true equals: (door isOpenAt: 1).! !
!Doors100Test methodsFor: 'tests' stamp: 'I 5/8/2024 19:09:16' prior: 50599308!
test01AfterTheFirstPassAllDoorsAreOpen
	
	|door|
	door := Doors100 new.
	door pass.
	self assert: true equals: (door isOpenAt: 1).! !

Object subclass: #Doors
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient'!

!classDefinition: #Doors category: #WebClient stamp: 'I 5/9/2024 11:48:46'!
Object subclass: #Doors
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient'!

!classRemoval: #Doors stamp: 'I 5/9/2024 11:48:57'!
Object subclass: #Doors
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient'!

Object subclass: #Doors
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DoorsGame'!

!classDefinition: #Doors category: #DoorsGame stamp: 'I 5/9/2024 11:49:14'!
Object subclass: #Doors
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DoorsGame'!

Object subclass: #DoorsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DoorsGame'!

!classDefinition: #DoorsTest category: #DoorsGame stamp: 'I 5/9/2024 11:49:19'!
Object subclass: #DoorsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DoorsGame'!
!DoorsTest methodsFor: 'nil' stamp: 'I 5/9/2024 11:49:32'!
test01AfterTheFirstPassAllDoorsAreOpen
	
	|door|
	door := Doors100 new.
	door pass.
	self assert: true equals: (door isOpenAt: 1).! !
!DoorsTest methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 11:49:38' prior: 50599357!
test01AfterTheFirstPassAllDoorsAreOpen
	
	|door|
	door := Doors new.
	door pass.
	self assert: true equals: (door isOpenAt: 1).! !

TestCase subclass: #Doors100Test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '100 Doors Problem'!

!classDefinition: #Doors100Test category: #'100 Doors Problem' stamp: 'I 5/9/2024 11:59:24'!
TestCase subclass: #Doors100Test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '100 Doors Problem'!

!methodRemoval: Doors100Test #test02 stamp: 'I 5/9/2024 12:00:11'!
test02
	self assert: true equals: false!

!testRun: #Doors100Test #test01AfterTheFirstPassAllDoorsAreOpen stamp: 'I 5/9/2024 12:00:13'!
ERROR!

!testRun: #Doors100Test #test01AfterTheFirstPassAllDoorsAreOpen stamp: 'I 5/9/2024 12:00:13'!
ERROR!
!Doors100 class methodsFor: 'nil' stamp: 'I 5/9/2024 12:01:22' overrides: 16916096!
initialize
	^self new initializeWith: 100.! !

!methodRemoval: Doors100 class #intialize stamp: 'I 5/9/2024 12:01:27'!
intialize
	^self new initializeWith: 100.!

!testRun: #Doors100Test #test01AfterTheFirstPassAllDoorsAreOpen stamp: 'I 5/9/2024 12:01:31'!
ERROR!

!testRun: #Doors100Test #test01AfterTheFirstPassAllDoorsAreOpen stamp: 'I 5/9/2024 12:01:31'!
ERROR!
!DoorsTest methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 12:04:44' prior: 50599365!
test01AfterTheFirstPassAllDoorsAreOpen
	
	|door|
	door := Doors initialize.
	door pass.
	self assert: true equals: (door isOpenAt: 1).! !
!Doors100 class methodsFor: 'nil' stamp: 'I 5/9/2024 12:05:23' prior: 50599394 overrides: 16916096!
initialize
	^self initializeWith: 100.! !
!Doors100Test methodsFor: 'tests' stamp: 'I 5/9/2024 12:07:08' prior: 50599315!
test01AfterTheFirstPassAllDoorsAreOpen
	
	|door|
	door := Doors100 initialize.
	door pass.
	self assert: true equals: (door isOpenAt: 1).! !
!Doors100 class methodsFor: 'nil' stamp: 'I 5/9/2024 12:07:22' prior: 50599417 overrides: 16916096!
initialize
	^self new initializeWith: 100.! !

!testRun: #Doors100Test #test01AfterTheFirstPassAllDoorsAreOpen stamp: 'I 5/9/2024 12:07:51'!
ERROR!

!testRun: #Doors100Test #test01AfterTheFirstPassAllDoorsAreOpen stamp: 'I 5/9/2024 12:08:02'!
ERROR!
!Doors100 methodsFor: 'nil' stamp: 'I 5/9/2024 12:16:03' prior: 50599239!
initializeWith: numberOfDoors
	doors := OrderedCollection new.
	
	1 to: 100 do: [:i | doors add: false].! !

!testRun: #Doors100Test #test01AfterTheFirstPassAllDoorsAreOpen stamp: 'I 5/9/2024 12:16:55'!
PASSED!
!Doors100Test methodsFor: 'tests' stamp: 'I 5/9/2024 12:20:11'!
test02After2PassesTheSecondDoorsIsntOpen
	
	|door|
	door := Doors100 initialize.
	door pass.
	self assert: true equals: (door isOpenAt: 1).! !
!Doors100Test methodsFor: 'tests' stamp: 'I 5/9/2024 12:20:24' prior: 50599449!
test02After2PassesTheSecondDoorsIsntOpen
	
	|door|
	door := Doors100 initialize.
	door pass.
	door pass
	self deny: (door isOpenAt: 1).! !

!testRun: #Doors100Test #test02After2PassesTheSecondDoorsIsntOpen stamp: 'I 5/9/2024 12:20:26'!
ERROR!

!testRun: #Doors100Test #test02After2PassesTheSecondDoorsIsntOpen stamp: 'I 5/9/2024 12:20:34'!
ERROR!
!Doors100Test methodsFor: 'tests' stamp: 'I 5/9/2024 12:20:42' prior: 50599456!
test02After2PassesTheSecondDoorsIsntOpen
	
	|door|
	door := Doors100 initialize.
	door pass.
	door pass.
	self deny: (door isOpenAt: 1).! !

!testRun: #Doors100Test #test02After2PassesTheSecondDoorsIsntOpen stamp: 'I 5/9/2024 12:20:43'!
FAILURE!
!Doors100Test methodsFor: 'tests' stamp: 'I 5/9/2024 12:21:57' prior: 50599470!
test02After2PassesTheSecondDoorsIsntOpen
	
	|door|
	door := Doors100 initialize.
	door pass:2.
	self deny: (door isOpenAt: 1).! !
!Doors100 methodsFor: 'nil' stamp: 'I 5/9/2024 12:22:09'!
pass: aNumberOfTimes
	1 to: 100 do: [:i| doors at: i put: true].
	! !
!Doors100 methodsFor: 'nil' stamp: 'I 5/9/2024 12:29:06' prior: 50599487!
pass: aNumberOfTimes
	|passing|
	passing := 1.
	(passing <= aNumberOfTimes)whileTrue:[
		|passingThroughDoors|
		passingThroughDoors := 1.
		(passingThroughDoors <= 100) whileTrue:[
			1 to: 100 do: [:i| doors at: i put: true].
		].
		passing := passing + 1.
	]
	! !
!Doors100 methodsFor: 'nil' stamp: 'I 5/9/2024 12:31:36' prior: 50599492!
pass: aNumberOfTimes
	|passing|
	passing := 1.
	(passing <= aNumberOfTimes)whileTrue:[
		|passingThroughDoors|
		passingThroughDoors := 1.
		(passingThroughDoors <= 100) whileTrue:[
			(doors at: passingThroughDoors ) ifTrue:[doors at: passingThroughDoors put: (doors at: passingThroughDoors) not]
		].
		passing := passing + 1.
	]
	! !
!Doors100 methodsFor: 'nil' stamp: 'I 5/9/2024 12:32:40' prior: 50599503!
pass: aNumberOfTimes
	|passing|
	passing := 1.
	(passing <= aNumberOfTimes)whileTrue:[
		|passingThroughDoors|
		passingThroughDoors := 1.
		(passingThroughDoors <= 100) whileTrue:[
			(doors at: passingThroughDoors ) ifTrue:[doors at: 			passingThroughDoors put: false] ifFalse:[doors at: 			passingThroughDoors put: true].
			passingThroughDoors := passingThroughDoors + passing.
		].
		passing := passing + 1.
	]
	! !
!Doors100Test methodsFor: 'tests' stamp: 'I 5/9/2024 12:32:44' prior: 50599421!
test01AfterTheFirstPassAllDoorsAreOpen
	
	|door|
	door := Doors100 initialize.
	door pass:1.
	self assert: true equals: (door isOpenAt: 1).! !

!testRun: #Doors100Test #test01AfterTheFirstPassAllDoorsAreOpen stamp: 'I 5/9/2024 12:32:44'!
ERROR!

!testRun: #Doors100Test #test01AfterTheFirstPassAllDoorsAreOpen stamp: 'I 5/9/2024 12:32:55'!
ERROR!
!Doors100 methodsFor: 'nil' stamp: 'I 5/9/2024 12:33:30' prior: 50599516!
pass: aNumberOfTimes
	|passing|
	passing := 1.
	[passing <= aNumberOfTimes]whileTrue:[
		|passingThroughDoors|
		passingThroughDoors := 1.
		[passingThroughDoors <= 100] whileTrue:[
			(doors at: passingThroughDoors ) ifTrue:[doors at: 			passingThroughDoors put: false] ifFalse:[doors at: 			passingThroughDoors put: true].
			passingThroughDoors := passingThroughDoors + passing.
		].
		passing := passing + 1.
	]
	! !

!testRun: #Doors100Test #test01AfterTheFirstPassAllDoorsAreOpen stamp: 'I 5/9/2024 12:33:35'!
PASSED!

!testRun: #Doors100Test #test02After2PassesTheSecondDoorsIsntOpen stamp: 'I 5/9/2024 12:33:35'!
PASSED!
!Doors100Test methodsFor: 'tests' stamp: 'I 5/9/2024 12:40:03'!
test02After50PassesTheFourDoorsIsOpen
	
	|door|
	door := Doors100 initialize.
	door pass:2.
	self assert: (door isOpenAt: 4).! !
!Doors100Test methodsFor: 'tests' stamp: 'I 5/9/2024 12:40:06' prior: 50599568!
test02After50PassesTheFourDoorsIsOpen
	
	|door|
	door := Doors100 initialize.
	door pass:50.
	self assert: (door isOpenAt: 4).! !

!testRun: #Doors100Test #test02After50PassesTheFourDoorsIsOpen stamp: 'I 5/9/2024 12:40:07'!
FAILURE!

Object subclass: #Tennis
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tennis Game'!

!classDefinition: #Tennis category: #'Tennis Game' stamp: 'I 5/9/2024 13:47:22'!
Object subclass: #Tennis
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tennis Game'!

TestCase subclass: #TennisTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tennis Game'!

!classDefinition: #TennisTest category: #'Tennis Game' stamp: 'I 5/9/2024 13:47:30'!
TestCase subclass: #TennisTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tennis Game'!
!TennisTest methodsFor: 'nil' stamp: 'I 5/9/2024 13:49:01'!
tes01GameStartsAndEachPlayerHave0Points
	|tennisMatch|
	tennisMatch := Tennis new.
	
	self assert: (tennisMatch playerOne score = (tennisMatch playerTwo score)).! !

!testRun: #Doors100Test #test01AfterTheFirstPassAllDoorsAreOpen stamp: 'I 5/9/2024 13:49:31'!
PASSED!

!testRun: #Doors100Test #test02After2PassesTheSecondDoorsIsntOpen stamp: 'I 5/9/2024 13:49:31'!
PASSED!

!testRun: #Doors100Test #test02After50PassesTheFourDoorsIsOpen stamp: 'I 5/9/2024 13:49:31'!
FAILURE!

!testRun: #Doors100Test #test02After50PassesTheFourDoorsIsOpen stamp: 'I 5/9/2024 13:49:31'!
FAILURE!

!testRun: #Doors100Test #test01AfterTheFirstPassAllDoorsAreOpen stamp: 'I 5/9/2024 13:56:23'!
PASSED!

!testRun: #Doors100Test #test02After2PassesTheSecondDoorsIsntOpen stamp: 'I 5/9/2024 13:56:23'!
PASSED!

!testRun: #Doors100Test #test02After50PassesTheFourDoorsIsOpen stamp: 'I 5/9/2024 13:56:23'!
FAILURE!

!testRun: #Doors100Test #test02After50PassesTheFourDoorsIsOpen stamp: 'I 5/9/2024 13:56:23'!
FAILURE!

TestCase subclass: #TennisTests
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tennis Game'!

!classDefinition: #TennisTests category: #'Tennis Game' stamp: 'I 5/9/2024 13:57:20'!
TestCase subclass: #TennisTests
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tennis Game'!
!TennisTests methodsFor: 'nil' stamp: 'I 5/9/2024 13:57:31'!
tes01GameStartsAndEachPlayerHave0Points
	|tennisMatch|
	tennisMatch := Tennis new.
	
	self assert: (tennisMatch playerOne score = (tennisMatch playerTwo score)).! !
!TennisTests methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 13:57:59'!
test01GameStartsAndEachPlayerHave0Points
	|tennisMatch|
	tennisMatch := Tennis new.
	
	self assert: (tennisMatch playerOne score = (tennisMatch playerTwo score)).! !

!testRun: #TennisTests #test01GameStartsAndEachPlayerHave0Points stamp: 'I 5/9/2024 13:58:05'!
ERROR!

!classRemoval: #TennisTest stamp: 'I 5/9/2024 13:59:28'!
TestCase subclass: #TennisTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tennis Game'!

Object subclass: #MarsRovers
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!classDefinition: #MarsRovers category: #'Mars Rovers' stamp: 'I 5/9/2024 17:09:14'!
Object subclass: #MarsRovers
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

TestCase subclass: #MarsRoversTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!classDefinition: #MarsRoversTest category: #'Mars Rovers' stamp: 'I 5/9/2024 17:09:21'!
TestCase subclass: #MarsRoversTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!
!MarsRoversTest methodsFor: 'nil' stamp: 'I 5/9/2024 17:35:32'!
test01
	|rover startingLocation|
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'N'.
	
	self assert: (Point x:1 y:2) equals: (rover location). ! !

!testRun: #MarsRoversTest #test01 stamp: 'I 5/9/2024 17:41:55'!
ERROR!

!testRun: #MarsRoversTest #test01 stamp: 'I 5/9/2024 17:42:13'!
ERROR!
!MarsRovers class methodsFor: 'instance creation' stamp: 'I 5/9/2024 17:42:29'!
locationAt: startingLocation pointingTo: aRenameMe1 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeLocationAt: startingLocation pointingTo: aRenameMe1 ! !
!MarsRovers class methodsFor: 'instance creation' stamp: 'I 5/9/2024 17:42:56' prior: 50599711!
locationAt: startingLocation pointingTo: cardinalLocation
	^self new initializeLocationAt: startingLocation pointingTo: cardinalLocation ! !

!classDefinition: #MarsRovers category: #'Mars Rovers' stamp: 'I 5/9/2024 17:43:25'!
Object subclass: #MarsRovers
	instanceVariableNames: 'startingLocation_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!classDefinition: #MarsRovers category: #'Mars Rovers' stamp: 'I 5/9/2024 17:43:25'!
Object subclass: #MarsRovers
	instanceVariableNames: 'startingLocation_CHANGE_ME cardinalLocation_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!
!MarsRovers methodsFor: 'initialization' stamp: 'I 5/9/2024 17:43:25'!
initializeLocationAt: startingLocation pointingTo: cardinalLocation 
	self shouldBeImplemented.
	startingLocation_CHANGE_ME := startingLocation.
	cardinalLocation_CHANGE_ME := cardinalLocation.! !
!MarsRovers methodsFor: 'initialization' stamp: 'I 5/9/2024 17:44:24' prior: 50599745!
initializeLocationAt: startingLocation pointingTo: cardinalLocation 
	
	| cardinalPoint locationPoint |
	locationPoint := startingLocation.
	cardinalPoint := cardinalLocation.! !

Object subclass: #MarsRovers
	instanceVariableNames: 'locationPoint cardinalPoint'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!
!MarsRovers methodsFor: 'initialization' stamp: 'I 5/9/2024 17:45:19' prior: 50599754!
initializeLocationAt: startingLocation pointingTo: cardinalLocation 
	
	
	| cardinalPointas locationPointsas |
	locationPointsas := startingLocation.
	cardinalPointas := cardinalLocation.! !

Object subclass: #MarsRovers
	instanceVariableNames: 'locationPoint cardinalPoint'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!classDefinition: #MarsRovers category: #'Mars Rovers' stamp: 'I 5/9/2024 17:45:29'!
Object subclass: #MarsRovers
	instanceVariableNames: 'locationPoint cardinalPoint'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!
!MarsRovers methodsFor: 'initialization' stamp: 'I 5/9/2024 17:45:38' prior: 50599768!
initializeLocationAt: startingLocation pointingTo: cardinalLocation 
	
	locationPoint := startingLocation.
	cardinalPoint := cardinalLocation.! !
!MarsRoversTest methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 17:57:09'!
test02
	|rover startingLocation areaOfWork|
	startingLocation := Point x: 4 y:2.
	areaOfWork := Point x: 3 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'N'.
	
	self assert: (Point x:1 y:2) equals: (rover location). ! !
!MarsRoversTest methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 18:02:22' prior: 50599798!
test02
	|rover startingLocation areaOfWork|
	startingLocation := Point x: 4 y:2.
	areaOfWork := Point x: 3 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'N' inWorkingArea: areaOfWork.
	
	self assert: (Point x:1 y:2) equals: (rover location). ! !

!testRun: #MarsRoversTest #test02 stamp: 'I 5/9/2024 18:02:26'!
ERROR!
!MarsRovers class methodsFor: 'instance creation' stamp: 'I 5/9/2024 18:03:07'!
locationAt: startingLocation pointingTo: cardinalLocation inWorkingArea: areaOfWork
	^self new initializeLocationAt: startingLocation pointingTo: cardinalLocation atAreaOfWork: areaOfWork ! !
!MarsRovers methodsFor: 'initialization' stamp: 'I 5/9/2024 18:03:24'!
initializeLocationAt: startingLocation pointingTo: cardinalLocation inWorkingArea: areaOfWork
	
	locationPoint := startingLocation.
	cardinalPoint := cardinalLocation.! !

Object subclass: #MarsRovers
	instanceVariableNames: 'locationPoint cardinalPoint workingArea'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!classDefinition: #MarsRovers category: #'Mars Rovers' stamp: 'I 5/9/2024 18:03:30'!
Object subclass: #MarsRovers
	instanceVariableNames: 'locationPoint cardinalPoint workingArea'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!
!MarsRovers methodsFor: 'initialization' stamp: 'I 5/9/2024 18:04:01' prior: 50599832!
initializeLocationAt: startingLocation pointingTo: cardinalLocation inWorkingArea: areaOfWork
	
	workingArea := areaOfWork.
	locationPoint := startingLocation.
	cardinalPoint := cardinalLocation.! !

!methodRemoval: MarsRovers #initializeLocationAt:pointingTo: stamp: 'I 5/9/2024 18:04:06'!
initializeLocationAt: startingLocation pointingTo: cardinalLocation 
	
	locationPoint := startingLocation.
	cardinalPoint := cardinalLocation.!
!MarsRoversTest methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 18:05:05' prior: 50599697!
test01
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'N' inWorkingArea: Point x:2 y:3 .
	
	self assert: (Point x:1 y:2) equals: (rover location). ! !

!testRun: #MarsRoversTest #test01 stamp: 'I 5/9/2024 18:05:38'!
ERROR!
!MarsRoversTest methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 18:06:22' prior: 50599871!
test01
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'N' inWorkingArea:(  Point x:2 y:3) .
	
	self assert: (Point x:1 y:2) equals: (rover location). ! !

!testRun: #MarsRoversTest #test02 stamp: 'I 5/9/2024 18:06:32'!
ERROR!

!testRun: #MarsRoversTest #test02 stamp: 'I 5/9/2024 18:06:32'!
ERROR!

!testRun: #MarsRoversTest #test02 stamp: 'I 5/9/2024 18:06:36'!
ERROR!

!testRun: #MarsRoversTest #test02 stamp: 'I 5/9/2024 18:06:36'!
ERROR!

!testRun: #MarsRoversTest #test01 stamp: 'I 5/9/2024 18:06:44'!
ERROR!
!MarsRovers class methodsFor: 'instance creation' stamp: 'I 5/9/2024 18:07:22' prior: 50599823!
locationAt: startingLocation pointingTo: cardinalLocation inWorkingArea: areaOfWork
	^self new initializeLocationAt: startingLocation pointingTo: cardinalLocation inWorkingArea: areaOfWork
	
 ! !

!testRun: #MarsRoversTest #test01 stamp: 'I 5/9/2024 18:07:32'!
ERROR!

!testRun: #MarsRoversTest #test02 stamp: 'I 5/9/2024 18:07:32'!
ERROR!

!testRun: #MarsRoversTest #test01 stamp: 'I 5/9/2024 18:07:37'!
ERROR!

!testRun: #MarsRoversTest #test01 stamp: 'I 5/9/2024 18:07:37'!
ERROR!
!MarsRovers methodsFor: 'initialization' stamp: 'I 5/9/2024 18:08:39'!
location
	^locationPoint ! !

!testRun: #MarsRoversTest #test01 stamp: 'I 5/9/2024 18:08:43'!
PASSED!

!testRun: #MarsRoversTest #test02 stamp: 'I 5/9/2024 18:08:46'!
FAILURE!

!testRun: #MarsRoversTest #test02 stamp: 'I 5/9/2024 18:08:46'!
FAILURE!
!MarsRoversTest methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 18:11:05' prior: 50599809!
test02
	|startingLocation areaOfWork|
	startingLocation := Point x: 4 y:2.
	areaOfWork := Point x: 3 y: 3.
	
	self 
		should: [MarsRovers locationAt: startingLocation pointingTo: 'N' inWorkingArea: areaOfWork. ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Rover fuera de rango' ]! !

!testRun: #MarsRoversTest #test02 stamp: 'I 5/9/2024 18:11:09'!
FAILURE!

!methodRemoval: MarsRovers class #locationAt:pointingTo: stamp: 'I 5/9/2024 18:11:16'!
locationAt: startingLocation pointingTo: cardinalLocation
	^self new initializeLocationAt: startingLocation pointingTo: cardinalLocation !
!MarsRovers class methodsFor: 'instance creation' stamp: 'I 5/9/2024 18:14:38' prior: 50599906!
locationAt: startingLocation pointingTo: cardinalLocation inWorkingArea: areaOfWork
	((startingLocation x ) negative or:[(startingLocation y ) negative] ) ifTrue:[self negativeCoordinatesNotAllowed].
	(startingLocation x<= (areaOfWork x) and:[startingLocation y<= (areaOfWork y)])
	^self new initializeLocationAt: startingLocation pointingTo: cardinalLocation inWorkingArea: areaOfWork
	
 ! !
!MarsRovers class methodsFor: 'instance creation' stamp: 'I 5/9/2024 18:15:29' prior: 50599959!
locationAt: startingLocation pointingTo: cardinalLocation inWorkingArea: areaOfWork
	((startingLocation x ) negative or:[(startingLocation y ) negative] ) ifTrue:[self negativeCoordinatesNotAllowed].
	(startingLocation x<= (areaOfWork x) and:[startingLocation y<= (areaOfWork y)]) ifFalse: [self outOfRangeOfWork].
	^self new initializeLocationAt: startingLocation pointingTo: cardinalLocation inWorkingArea: areaOfWork
	
 ! !
!MarsRovers class methodsFor: 'instance creation' stamp: 'I 5/9/2024 18:16:02'!
negativeCoordinatesNotAllowed
	^'Coordenadas negativas no son validas'! !
!MarsRovers class methodsFor: 'instance creation' stamp: 'I 5/9/2024 18:16:28'!
outOfRangeOfWork
	^'Rover fuera de rango' ! !

!testRun: #MarsRoversTest #test02 stamp: 'I 5/9/2024 18:16:30'!
FAILURE!

!testRun: #MarsRoversTest #test01 stamp: 'I 5/9/2024 18:16:34'!
PASSED!
!MarsRovers class methodsFor: 'instance creation' stamp: 'I 5/9/2024 18:19:44' prior: 50599975!
locationAt: startingLocation pointingTo: cardinalLocation inWorkingArea: areaOfWork
	((startingLocation x ) negative or:[(startingLocation y ) negative] ) ifTrue:[self negativeCoordinatesNotAllowed].
	(startingLocation x<= (areaOfWork x) and:[startingLocation y<= (areaOfWork y)]) ifFalse: [self error outOfRangeOfWork].
	^self new initializeLocationAt: startingLocation pointingTo: cardinalLocation inWorkingArea: areaOfWork
	
 ! !

!testRun: #MarsRoversTest #test02 stamp: 'I 5/9/2024 18:19:48'!
ERROR!
!MarsRovers class methodsFor: 'instance creation' stamp: 'I 5/9/2024 18:20:47' prior: 50600006!
locationAt: startingLocation pointingTo: cardinalLocation inWorkingArea: areaOfWork
	((startingLocation x ) negative or:[(startingLocation y ) negative] ) ifTrue:[self negativeCoordinatesNotAllowed].
	(startingLocation x<= (areaOfWork x) and:[startingLocation y<= (areaOfWork y)]) ifFalse: [self error: self outOfRangeOfWork].
	^self new initializeLocationAt: startingLocation pointingTo: cardinalLocation inWorkingArea: areaOfWork
	
 ! !

!testRun: #MarsRoversTest #test02 stamp: 'I 5/9/2024 18:20:49'!
PASSED!

!testRun: #MarsRoversTest #test01 stamp: 'I 5/9/2024 18:20:49'!
PASSED!

!testRun: #MarsRoversTest #test02 stamp: 'I 5/9/2024 18:20:49'!
PASSED!
!MarsRoversTest methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 18:23:17'!
test03
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'N' inWorkingArea:(  Point x:4 y:4).
	rover moveForward.
	
	
	self assert: (Point x:1 y:3) equals: (rover location). ! !

!testRun: #MarsRoversTest #test03 stamp: 'I 5/9/2024 18:23:21'!
ERROR!
!MarsRovers methodsFor: 'action' stamp: 'I 5/9/2024 18:23:37'!
moveForward
	self shouldBeImplemented.! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/9/2024 18:25:16' prior: 50600062!
moveForward
	locationPoint := locationPoint + (0@1).! !

!testRun: #MarsRoversTest #test03 stamp: 'I 5/9/2024 18:25:25'!
PASSED!

!testRun: #MarsRoversTest #test01 stamp: 'I 5/9/2024 18:25:25'!
PASSED!

!testRun: #MarsRoversTest #test02 stamp: 'I 5/9/2024 18:25:25'!
PASSED!

!testRun: #MarsRoversTest #test03 stamp: 'I 5/9/2024 18:25:25'!
PASSED!
!MarsRoversTest methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 18:26:01'!
test04
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'N' inWorkingArea:(  Point x:4 y:4).
	rover moveBackward.
	
	
	self assert: (Point x:1 y:1) equals: (rover location). ! !

!testRun: #MarsRoversTest #test04 stamp: 'I 5/9/2024 18:26:09'!
ERROR!
!MarsRovers methodsFor: 'action' stamp: 'I 5/9/2024 18:26:16'!
moveBackward
	self shouldBeImplemented.! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/9/2024 18:26:47' prior: 50600093!
moveBackward
	locationPoint := locationPoint - (0@1).! !

!testRun: #MarsRoversTest #test01 stamp: 'I 5/9/2024 18:26:49'!
PASSED!

!testRun: #MarsRoversTest #test04 stamp: 'I 5/9/2024 18:26:51'!
PASSED!

!testRun: #MarsRoversTest #test01 stamp: 'I 5/9/2024 18:26:59'!
PASSED!

!testRun: #MarsRoversTest #test02 stamp: 'I 5/9/2024 18:26:59'!
PASSED!

!testRun: #MarsRoversTest #test03 stamp: 'I 5/9/2024 18:26:59'!
PASSED!

!testRun: #MarsRoversTest #test04 stamp: 'I 5/9/2024 18:26:59'!
PASSED!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 18:27:20'!
test05
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'S' inWorkingArea:(  Point x:4 y:4).
	rover moveForward.
	
	
	self assert: (Point x:1 y:1) equals: (rover location). ! !

!testRun: #MarsRoversTest #test05 stamp: 'I 5/9/2024 18:27:22'!
FAILURE!

Number class!

Number class asString!

!testRun: #MarsRoversTest #test05 stamp: 'I 5/9/2024 18:35:32'!
FAILURE!
!MarsRovers methodsFor: 'action' stamp: 'I 5/9/2024 18:37:23' prior: 50600097!
moveBackward
	(cardinalPoint = 'N') ifTrue:[locationPoint := locationPoint - (0@1)]
	ifFalse:[locationPoint := locationPoint + (0@1)].
	! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/9/2024 18:37:45' prior: 50600066!
moveForward
	(cardinalPoint = 'N') ifTrue:[locationPoint := locationPoint + (0@1)]
	ifFalse:[locationPoint := locationPoint - (0@1)].
	! !

!testRun: #MarsRoversTest #test05 stamp: 'I 5/9/2024 18:37:47'!
PASSED!

!testRun: #MarsRoversTest #test01 stamp: 'I 5/9/2024 18:37:47'!
PASSED!

!testRun: #MarsRoversTest #test02 stamp: 'I 5/9/2024 18:37:47'!
PASSED!

!testRun: #MarsRoversTest #test03 stamp: 'I 5/9/2024 18:37:47'!
PASSED!

!testRun: #MarsRoversTest #test04 stamp: 'I 5/9/2024 18:37:47'!
PASSED!

!testRun: #MarsRoversTest #test05 stamp: 'I 5/9/2024 18:37:47'!
PASSED!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 18:38:03'!
test06
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'S' inWorkingArea:(  Point x:4 y:4).
	rover moveForward.
	rover moveForward.
	
	
	self assert: (Point x:1 y:1) equals: (rover location). ! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 18:38:07' prior: 50600160!
test06
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'S' inWorkingArea:(  Point x:4 y:4).
	rover moveForward.
	rover moveForward.
	
	
	self assert: (Point x:1 y:0) equals: (rover location). ! !

!testRun: #MarsRoversTest #test06 stamp: 'I 5/9/2024 18:38:08'!
PASSED!

!testRun: #MarsRoversTest #test01 stamp: 'I 5/9/2024 18:38:08'!
PASSED!

!testRun: #MarsRoversTest #test02 stamp: 'I 5/9/2024 18:38:08'!
PASSED!

!testRun: #MarsRoversTest #test03 stamp: 'I 5/9/2024 18:38:08'!
PASSED!

!testRun: #MarsRoversTest #test04 stamp: 'I 5/9/2024 18:38:08'!
PASSED!

!testRun: #MarsRoversTest #test05 stamp: 'I 5/9/2024 18:38:08'!
PASSED!

!testRun: #MarsRoversTest #test06 stamp: 'I 5/9/2024 18:38:08'!
PASSED!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 19:05:51'!
test07
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'O' inWorkingArea:(  Point x:4 y:4).
	rover moveForward.
	
	
	self assert: (Point x:0 y:2) equals: (rover location). ! !

!testRun: #MarsRoversTest #test07 stamp: 'I 5/9/2024 19:05:52'!
FAILURE!
!MarsRovers methodsFor: 'action' stamp: 'I 5/9/2024 19:06:35' prior: 50600139!
moveForward
	(cardinalPoint = 'N') ifTrue:[locationPoint := locationPoint + (0@1)].
	(cardinalPoint = 'O') ifTrue:[locationPoint := locationPoint - (1@0)]
	ifFalse:[locationPoint := locationPoint - (0@1)].
	! !

!testRun: #MarsRoversTest #test07 stamp: 'I 5/9/2024 19:06:38'!
PASSED!

!testRun: #MarsRoversTest #test01 stamp: 'I 5/9/2024 19:06:38'!
PASSED!

!testRun: #MarsRoversTest #test02 stamp: 'I 5/9/2024 19:06:38'!
PASSED!

!testRun: #MarsRoversTest #test03 stamp: 'I 5/9/2024 19:06:38'!
FAILURE!

!testRun: #MarsRoversTest #test04 stamp: 'I 5/9/2024 19:06:38'!
PASSED!

!testRun: #MarsRoversTest #test05 stamp: 'I 5/9/2024 19:06:38'!
PASSED!

!testRun: #MarsRoversTest #test06 stamp: 'I 5/9/2024 19:06:38'!
PASSED!

!testRun: #MarsRoversTest #test07 stamp: 'I 5/9/2024 19:06:38'!
PASSED!

!testRun: #MarsRoversTest #test03 stamp: 'I 5/9/2024 19:06:38'!
FAILURE!

!testRun: #MarsRoversTest #test07 stamp: 'I 5/9/2024 19:06:43'!
PASSED!

!testRun: #MarsRoversTest #test01 stamp: 'I 5/9/2024 19:06:46'!
PASSED!

!testRun: #MarsRoversTest #test02 stamp: 'I 5/9/2024 19:06:46'!
PASSED!

!testRun: #MarsRoversTest #test03 stamp: 'I 5/9/2024 19:06:46'!
FAILURE!

!testRun: #MarsRoversTest #test04 stamp: 'I 5/9/2024 19:06:46'!
PASSED!

!testRun: #MarsRoversTest #test05 stamp: 'I 5/9/2024 19:06:46'!
PASSED!

!testRun: #MarsRoversTest #test06 stamp: 'I 5/9/2024 19:06:46'!
PASSED!

!testRun: #MarsRoversTest #test07 stamp: 'I 5/9/2024 19:06:46'!
PASSED!

!testRun: #MarsRoversTest #test03 stamp: 'I 5/9/2024 19:06:46'!
FAILURE!

!testRun: #MarsRoversTest #test06 stamp: 'I 5/9/2024 19:06:51'!
PASSED!

!testRun: #MarsRoversTest #test05 stamp: 'I 5/9/2024 19:06:52'!
PASSED!

!testRun: #MarsRoversTest #test04 stamp: 'I 5/9/2024 19:06:54'!
PASSED!

!testRun: #MarsRoversTest #test03 stamp: 'I 5/9/2024 19:06:55'!
FAILURE!

!testRun: #MarsRoversTest #test03 stamp: 'I 5/9/2024 19:06:55'!
FAILURE!
!MarsRovers methodsFor: 'action' stamp: 'I 5/9/2024 19:07:40' prior: 50600212!
moveForward
	(cardinalPoint = 'N') ifTrue:[locationPoint := locationPoint + (0@1)].
	(cardinalPoint = 'O') ifTrue:[locationPoint := locationPoint - (1@0)].
	(cardinalPoint = 'S') ifTrue:[locationPoint := locationPoint - (0@1)].
	! !

!testRun: #MarsRoversTest #test03 stamp: 'I 5/9/2024 19:07:42'!
PASSED!

!testRun: #MarsRoversTest #test01 stamp: 'I 5/9/2024 19:07:42'!
PASSED!

!testRun: #MarsRoversTest #test02 stamp: 'I 5/9/2024 19:07:42'!
PASSED!

!testRun: #MarsRoversTest #test03 stamp: 'I 5/9/2024 19:07:42'!
PASSED!

!testRun: #MarsRoversTest #test04 stamp: 'I 5/9/2024 19:07:42'!
PASSED!

!testRun: #MarsRoversTest #test05 stamp: 'I 5/9/2024 19:07:42'!
PASSED!

!testRun: #MarsRoversTest #test06 stamp: 'I 5/9/2024 19:07:42'!
PASSED!

!testRun: #MarsRoversTest #test07 stamp: 'I 5/9/2024 19:07:42'!
PASSED!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 19:08:44'!
test08
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'O' inWorkingArea:(  Point x:4 y:4).
	rover moveBackward.
	
	
	self assert: (Point x:2 y:2) equals: (rover location). ! !

!testRun: #MarsRoversTest #test08 stamp: 'I 5/9/2024 19:08:48'!
FAILURE!
!MarsRovers methodsFor: 'action' stamp: 'I 5/9/2024 19:09:24' prior: 50600132!
moveBackward
	(cardinalPoint = 'N') ifTrue:[locationPoint := locationPoint - (0@1)].
	(cardinalPoint = 'S') ifTrue:[locationPoint := locationPoint + (0@1)].
	(cardinalPoint = 'O') ifTrue:[locationPoint := locationPoint + (1@0)]! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/9/2024 19:10:28' prior: 50600315!
moveBackward
	(cardinalPoint = 'N') ifTrue:[locationPoint := locationPoint - (0@1)].
	(cardinalPoint = 'S') ifTrue:[locationPoint := locationPoint + (0@1)].
	(cardinalPoint = 'O') ifTrue:[locationPoint := locationPoint + (1@0)].
	(cardinalPoint = 'E') ifTrue:[locationPoint := locationPoint - (1@0)].! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/9/2024 19:10:40' prior: 50600274!
moveForward
	(cardinalPoint = 'N') ifTrue:[locationPoint := locationPoint + (0@1)].
	(cardinalPoint = 'O') ifTrue:[locationPoint := locationPoint - (1@0)].
	(cardinalPoint = 'E') ifTrue:[locationPoint := locationPoint + (1@0)].
	(cardinalPoint = 'S') ifTrue:[locationPoint := locationPoint - (0@1)].
	! !

!testRun: #MarsRoversTest #test08 stamp: 'I 5/9/2024 19:10:43'!
PASSED!

Object subclass: #CardinalRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!classDefinition: #CardinalRule category: #'Mars Rovers' stamp: 'I 5/9/2024 19:14:38'!
Object subclass: #CardinalRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

CardinalRule subclass: #N
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!classDefinition: #N category: #'Mars Rovers' stamp: 'I 5/9/2024 19:14:48'!
CardinalRule subclass: #N
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

CardinalRule subclass: #S
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!classDefinition: #S category: #'Mars Rovers' stamp: 'I 5/9/2024 19:14:50'!
CardinalRule subclass: #S
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

CardinalRule subclass: #O
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!classDefinition: #O category: #'Mars Rovers' stamp: 'I 5/9/2024 19:14:51'!
CardinalRule subclass: #O
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

CardinalRule subclass: #E
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!classDefinition: #E category: #'Mars Rovers' stamp: 'I 5/9/2024 19:14:53'!
CardinalRule subclass: #E
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 19:16:39'!
test09
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'E' inWorkingArea:(  Point x:4 y:4).
	rover moveBackward.
	
	
	self assert: (Point x:2 y:2) equals: (rover location). ! !

!methodRemoval: MarsRoversTest #test09 stamp: 'I 5/9/2024 19:16:42'!
test09
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'E' inWorkingArea:(  Point x:4 y:4).
	rover moveBackward.
	
	
	self assert: (Point x:2 y:2) equals: (rover location). !
!MarsRovers methodsFor: 'initialization' stamp: 'I 5/9/2024 19:17:29' prior: 50599854!
initializeLocationAt: startingLocation pointingTo: cardinalLocation inWorkingArea: areaOfWork
	
	workingArea := areaOfWork.
	locationPoint := startingLocation.
	cardinalPoint := CardinalRule for: cardinalLocation.! !

Number asString!
!CardinalRule class methodsFor: 'nil' stamp: 'I 5/9/2024 19:21:10'!
stateFor: aCardinalLocation
	^(self subclasses detect:[:class | class asString = aCardinalLocation]) initialize.! !
!CardinalRule class methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 19:21:21' prior: 50600434!
stateFor: aCardinalLocation
	^(self subclasses detect:[:class | class asString = aCardinalLocation]) new.! !
!MarsRovers methodsFor: 'initialization' stamp: 'I 5/9/2024 19:21:32' prior: 50600424!
initializeLocationAt: startingLocation pointingTo: cardinalLocation inWorkingArea: areaOfWork
	
	workingArea := areaOfWork.
	locationPoint := startingLocation.
	cardinalPoint := CardinalRule stateFor: cardinalLocation.! !
!CardinalRule methodsFor: 'nil' stamp: 'I 5/9/2024 19:24:10'!
moveBackward
	^self subclassResponsibility.! !
!N methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 19:24:18' overrides: 50600457!
moveBackward
	^self subclassResponsibility.! !
!S methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 19:24:18' overrides: 50600457!
moveBackward
	^self subclassResponsibility.! !
!O methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 19:24:18' overrides: 50600457!
moveBackward
	^self subclassResponsibility.! !
!E methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 19:24:18' overrides: 50600457!
moveBackward
	^self subclassResponsibility.! !
!CardinalRule methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 19:24:18' prior: 50600457!
moveBackward

	self subclassResponsibility! !
!CardinalRule methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 19:24:28'!
moveForward

	^self subclassResponsibility! !
!CardinalRule methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 19:24:32' prior: 50600482!
moveBackward

	^self subclassResponsibility! !
!N methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 19:24:38' prior: 50600462 overrides: 50600491!
moveBackward

	^self subclassResponsibility! !
!S methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 19:24:38' prior: 50600467 overrides: 50600491!
moveBackward

	^self subclassResponsibility! !
!O methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 19:24:38' prior: 50600472 overrides: 50600491!
moveBackward

	^self subclassResponsibility! !
!E methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 19:24:38' prior: 50600477 overrides: 50600491!
moveBackward

	^self subclassResponsibility! !
!CardinalRule methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 19:24:38' prior: 50600491!
moveBackward

	self subclassResponsibility! !
!N methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 19:24:42' overrides: 50600486!
moveForward

	^self subclassResponsibility! !
!S methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 19:24:42' overrides: 50600486!
moveForward

	^self subclassResponsibility! !
!O methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 19:24:42' overrides: 50600486!
moveForward

	^self subclassResponsibility! !
!E methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 19:24:42' overrides: 50600486!
moveForward

	^self subclassResponsibility! !
!CardinalRule methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 19:24:42' prior: 50600486!
moveForward

	self subclassResponsibility! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/9/2024 19:25:22' prior: 50600325!
moveBackward
	locationPoint := locationPoint + (cardinalPoint moveBackward).
	(cardinalPoint = 'N') ifTrue:[locationPoint := locationPoint - (0@1)].
	(cardinalPoint = 'S') ifTrue:[locationPoint := locationPoint + (0@1)].
	(cardinalPoint = 'O') ifTrue:[locationPoint := locationPoint + (1@0)].
	(cardinalPoint = 'E') ifTrue:[locationPoint := locationPoint - (1@0)].! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/9/2024 19:25:27' prior: 50600545!
moveBackward
	locationPoint := locationPoint + (cardinalPoint moveBackward)."
	(cardinalPoint = 'N') ifTrue:[locationPoint := locationPoint - (0@1)].
	(cardinalPoint = 'S') ifTrue:[locationPoint := locationPoint + (0@1)].
	(cardinalPoint = 'O') ifTrue:[locationPoint := locationPoint + (1@0)].
	(cardinalPoint = 'E') ifTrue:[locationPoint := locationPoint - (1@0)]."! !
!E methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 19:25:59' prior: 50600511 overrides: 50600516!
moveBackward

	^(-1)@0! !
!N methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 19:26:20' prior: 50600496 overrides: 50600516!
moveBackward

	^0@(-1).! !
!O methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 19:26:33' prior: 50600506 overrides: 50600516!
moveBackward

	^1@0! !
!S methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 19:26:50' prior: 50600501 overrides: 50600516!
moveBackward

	^0@1.! !
!S methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 19:28:20' prior: 50600526 overrides: 50600541!
moveForward

	^0@(-1)! !
!O methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 19:28:32' prior: 50600531 overrides: 50600541!
moveForward

	^(-1)@0! !
!N methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 19:28:40' prior: 50600521 overrides: 50600541!
moveForward

	^0@1! !
!E methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 19:28:49' prior: 50600536 overrides: 50600541!
moveForward

	^1@0! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/9/2024 19:29:16' prior: 50600337!
moveForward
	locationPoint := locationPoint + (cardinalPoint moveForward)."
	(cardinalPoint = 'N') ifTrue:[locationPoint := locationPoint + (0@1)].
	(cardinalPoint = 'O') ifTrue:[locationPoint := locationPoint - (1@0)].
	(cardinalPoint = 'E') ifTrue:[locationPoint := locationPoint + (1@0)].
	(cardinalPoint = 'S') ifTrue:[locationPoint := locationPoint - (0@1)]."
	! !

!testRun: #MarsRoversTest #test01 stamp: 'I 5/9/2024 19:29:18'!
PASSED!

!testRun: #MarsRoversTest #test02 stamp: 'I 5/9/2024 19:29:18'!
PASSED!

!testRun: #MarsRoversTest #test03 stamp: 'I 5/9/2024 19:29:18'!
PASSED!

!testRun: #MarsRoversTest #test04 stamp: 'I 5/9/2024 19:29:18'!
PASSED!

!testRun: #MarsRoversTest #test05 stamp: 'I 5/9/2024 19:29:18'!
PASSED!

!testRun: #MarsRoversTest #test06 stamp: 'I 5/9/2024 19:29:18'!
PASSED!

!testRun: #MarsRoversTest #test07 stamp: 'I 5/9/2024 19:29:18'!
PASSED!

!testRun: #MarsRoversTest #test08 stamp: 'I 5/9/2024 19:29:18'!
PASSED!
!MarsRovers methodsFor: 'action' stamp: 'I 5/9/2024 19:29:27' prior: 50600608!
moveForward
	locationPoint := locationPoint + (cardinalPoint moveForward).! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/9/2024 19:29:32' prior: 50600559!
moveBackward
	locationPoint := locationPoint + (cardinalPoint moveBackward).! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 19:30:07'!
test01InitializeAndReturnsTheLocationOfTheRover
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'N' inWorkingArea:(  Point x:2 y:3) .
	
	self assert: (Point x:1 y:2) equals: (rover location). ! !

!methodRemoval: MarsRoversTest #test01 stamp: 'I 5/9/2024 19:30:11'!
test01
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'N' inWorkingArea:(  Point x:2 y:3) .
	
	self assert: (Point x:1 y:2) equals: (rover location). !

!testRun: #MarsRoversTest #test01InitializeAndReturnsTheLocationOfTheRover stamp: 'I 5/9/2024 19:30:13'!
PASSED!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 19:32:42'!
test02ARoverIsPlacedOutOfTheReachOfWork
	|startingLocation areaOfWork|
	startingLocation := Point x: 4 y:2.
	areaOfWork := Point x: 3 y: 3.
	
	self 
		should: [MarsRovers locationAt: startingLocation pointingTo: 'N' inWorkingArea: areaOfWork. ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Rover fuera de rango' ]! !

!methodRemoval: MarsRoversTest #test02 stamp: 'I 5/9/2024 19:32:43'!
test02
	|startingLocation areaOfWork|
	startingLocation := Point x: 4 y:2.
	areaOfWork := Point x: 3 y: 3.
	
	self 
		should: [MarsRovers locationAt: startingLocation pointingTo: 'N' inWorkingArea: areaOfWork. ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Rover fuera de rango' ]!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 19:33:44'!
test03ARoverPointingToNorthMoveForward
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'N' inWorkingArea:(  Point x:4 y:4).
	rover moveForward.
	
	
	self assert: (Point x:1 y:3) equals: (rover location). ! !

!methodRemoval: MarsRoversTest #test03 stamp: 'I 5/9/2024 19:33:44'!
test03
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'N' inWorkingArea:(  Point x:4 y:4).
	rover moveForward.
	
	
	self assert: (Point x:1 y:3) equals: (rover location). !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 19:34:04'!
test04RoverPointingToNorthMoveBackward
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'N' inWorkingArea:(  Point x:4 y:4).
	rover moveBackward.
	
	
	self assert: (Point x:1 y:1) equals: (rover location). ! !

!methodRemoval: MarsRoversTest #test04 stamp: 'I 5/9/2024 19:34:05'!
test04
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'N' inWorkingArea:(  Point x:4 y:4).
	rover moveBackward.
	
	
	self assert: (Point x:1 y:1) equals: (rover location). !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 19:34:25'!
test05RoverPointingSouthMoveForward
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'S' inWorkingArea:(  Point x:4 y:4).
	rover moveForward.
	
	
	self assert: (Point x:1 y:1) equals: (rover location). ! !

!methodRemoval: MarsRoversTest #test05 stamp: 'I 5/9/2024 19:34:25'!
test05
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'S' inWorkingArea:(  Point x:4 y:4).
	rover moveForward.
	
	
	self assert: (Point x:1 y:1) equals: (rover location). !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 19:38:59'!
test06RoverMoveForwardTwoTimes
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'S' inWorkingArea:(  Point x:4 y:4).
	rover moveForward.
	rover moveForward.
	
	
	self assert: (Point x:1 y:0) equals: (rover location). ! !

!methodRemoval: MarsRoversTest #test06 stamp: 'I 5/9/2024 19:38:59'!
test06
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'S' inWorkingArea:(  Point x:4 y:4).
	rover moveForward.
	rover moveForward.
	
	
	self assert: (Point x:1 y:0) equals: (rover location). !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 19:39:27'!
test07RoverPointingWestMoveForward
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'O' inWorkingArea:(  Point x:4 y:4).
	rover moveForward.
	
	
	self assert: (Point x:0 y:2) equals: (rover location). ! !

!methodRemoval: MarsRoversTest #test07 stamp: 'I 5/9/2024 19:39:27'!
test07
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'O' inWorkingArea:(  Point x:4 y:4).
	rover moveForward.
	
	
	self assert: (Point x:0 y:2) equals: (rover location). !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 19:39:49'!
test08RoverPointingWestMoveBackward
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'O' inWorkingArea:(  Point x:4 y:4).
	rover moveBackward.
	
	
	self assert: (Point x:2 y:2) equals: (rover location). ! !

!methodRemoval: MarsRoversTest #test08 stamp: 'I 5/9/2024 19:39:49'!
test08
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'O' inWorkingArea:(  Point x:4 y:4).
	rover moveBackward.
	
	
	self assert: (Point x:2 y:2) equals: (rover location). !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 19:42:18'!
test09
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'O' inWorkingArea:(  Point x:4 y:4).
	rover moveBackward.
	rover rotateToLeft.
	rover moveForward. 
	
	self assert: 'S' equals: (rover cardinalLocation).
	self assert: (Point x:2 y:2) equals: (rover location). ! !

!testRun: #MarsRoversTest #test09 stamp: 'I 5/9/2024 19:42:21'!
ERROR!
!MarsRovers methodsFor: 'action' stamp: 'I 5/9/2024 19:42:31'!
rotateToLeft
	self shouldBeImplemented.! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/9/2024 19:43:13' prior: 50600851!
rotateToLeft
	cardinalPoint := (cardinalPoint rotateToLeft).! !

!testRun: #MarsRoversTest #test09 stamp: 'I 5/9/2024 19:43:19'!
ERROR!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/9/2024 19:43:19'!
ERROR!
!O methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 19:43:34'!
rotateToLeft
	self shouldBeImplemented.! !
!O methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 19:43:52' prior: 50600864!
rotateToLeft
	^S new.! !

!testRun: #MarsRoversTest #test09 stamp: 'I 5/9/2024 19:44:01'!
ERROR!
!MarsRovers methodsFor: 'action' stamp: 'I 5/9/2024 19:44:07'!
cardinalLocation
	self shouldBeImplemented.! !

!methodRemoval: MarsRovers #cardinalLocation stamp: 'I 5/9/2024 19:44:17'!
cardinalLocation
	self shouldBeImplemented.!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/9/2024 19:44:25'!
ERROR!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/9/2024 19:44:25'!
ERROR!
!MarsRovers methodsFor: 'accesing' stamp: 'I 5/9/2024 19:45:47'!
cardinalLocation
	self shouldBeImplemented.! !
!MarsRovers methodsFor: 'accesing' stamp: 'I 5/9/2024 19:46:19' prior: 50600885!
cardinalLocation
	^cardinalPoint asString! !

!testRun: #MarsRoversTest #test09 stamp: 'I 5/9/2024 19:46:24'!
FAILURE!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/9/2024 19:46:25'!
FAILURE!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/9/2024 19:46:51'!
FAILURE!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/9/2024 19:46:51'!
FAILURE!
!MarsRovers methodsFor: 'accesing' stamp: 'I 5/9/2024 19:47:33' prior: 50600889!
cardinalLocation
	^(cardinalPoint class)asString! !

!testRun: #MarsRoversTest #test09 stamp: 'I 5/9/2024 19:47:42'!
FAILURE!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 19:48:30' prior: 50600835!
test09
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'O' inWorkingArea:(  Point x:4 y:4).
	rover moveBackward.
	rover rotateToLeft.
	rover moveForward. 
	
	self assert: 'S' equals: (rover cardinalLocation).
	self assert: (Point x:2 y:1) equals: (rover location). ! !

!testRun: #MarsRoversTest #test09 stamp: 'I 5/9/2024 19:48:31'!
PASSED!

!testRun: #MarsRoversTest #test01InitializeAndReturnsTheLocationOfTheRover stamp: 'I 5/9/2024 19:48:31'!
PASSED!

!testRun: #MarsRoversTest #test02ARoverIsPlacedOutOfTheReachOfWork stamp: 'I 5/9/2024 19:48:31'!
PASSED!

!testRun: #MarsRoversTest #test03ARoverPointingToNorthMoveForward stamp: 'I 5/9/2024 19:48:31'!
PASSED!

!testRun: #MarsRoversTest #test04RoverPointingToNorthMoveBackward stamp: 'I 5/9/2024 19:48:31'!
PASSED!

!testRun: #MarsRoversTest #test05RoverPointingSouthMoveForward stamp: 'I 5/9/2024 19:48:31'!
PASSED!

!testRun: #MarsRoversTest #test06RoverMoveForwardTwoTimes stamp: 'I 5/9/2024 19:48:31'!
PASSED!

!testRun: #MarsRoversTest #test07RoverPointingWestMoveForward stamp: 'I 5/9/2024 19:48:31'!
PASSED!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/9/2024 19:48:31'!
PASSED!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/9/2024 19:48:31'!
PASSED!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 20:01:29'!
test10
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'O' inWorkingArea:(  Point x:4 y:4).
	rover moveBackward.
	rover rotateToRight.
	rover moveForward. 
	
	self assert: 'S' equals: (rover cardinalLocation).
	self assert: (Point x:2 y:1) equals: (rover location). ! !

!testRun: #MarsRoversTest #test10 stamp: 'I 5/9/2024 20:01:32'!
ERROR!
!MarsRovers methodsFor: 'action' stamp: 'I 5/9/2024 20:01:40'!
rotateToRight
	self shouldBeImplemented.! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/9/2024 20:02:30' prior: 50600970!
rotateToRight
	locationPoint :=  locationPoint+ (cardinalPoint rotateRight)! !

!testRun: #MarsRoversTest #test10 stamp: 'I 5/9/2024 20:02:35'!
ERROR!
!O methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 20:02:42'!
rotateRight
	self shouldBeImplemented.! !
!O methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 20:03:14' prior: 50600981!
rotateRight
	^N new.! !

!testRun: #MarsRoversTest #test10 stamp: 'I 5/9/2024 20:03:23'!
ERROR!
!MarsRovers methodsFor: 'action' stamp: 'I 5/9/2024 20:03:41' prior: 50600974!
rotateToRight
	cardinalPoint  :=  cardinalPoint rotateRight! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 20:03:52' prior: 50600954!
test10
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'O' inWorkingArea:(  Point x:4 y:4).
	rover moveBackward.
	rover rotateToRight.
	rover moveForward. 
	
	self assert: 'S' equals: (rover cardinalLocation).
	self assert: (Point x:2 y:3) equals: (rover location). ! !

!testRun: #MarsRoversTest #test10 stamp: 'I 5/9/2024 20:03:54'!
FAILURE!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 20:04:36' prior: 50600996!
test10
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'O' inWorkingArea:(  Point x:4 y:4).
	rover moveBackward.
	rover rotateToRight.
	rover moveForward. 
	
	self assert: 'N' equals: (rover cardinalLocation).
	self assert: (Point x:2 y:3) equals: (rover location). ! !

!testRun: #MarsRoversTest #test10 stamp: 'I 5/9/2024 20:04:37'!
PASSED!

!testRun: #MarsRoversTest #test01InitializeAndReturnsTheLocationOfTheRover stamp: 'I 5/9/2024 20:04:37'!
PASSED!

!testRun: #MarsRoversTest #test02ARoverIsPlacedOutOfTheReachOfWork stamp: 'I 5/9/2024 20:04:37'!
PASSED!

!testRun: #MarsRoversTest #test03ARoverPointingToNorthMoveForward stamp: 'I 5/9/2024 20:04:37'!
PASSED!

!testRun: #MarsRoversTest #test04RoverPointingToNorthMoveBackward stamp: 'I 5/9/2024 20:04:37'!
PASSED!

!testRun: #MarsRoversTest #test05RoverPointingSouthMoveForward stamp: 'I 5/9/2024 20:04:37'!
PASSED!

!testRun: #MarsRoversTest #test06RoverMoveForwardTwoTimes stamp: 'I 5/9/2024 20:04:37'!
PASSED!

!testRun: #MarsRoversTest #test07RoverPointingWestMoveForward stamp: 'I 5/9/2024 20:04:37'!
PASSED!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/9/2024 20:04:37'!
PASSED!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/9/2024 20:04:37'!
PASSED!

!testRun: #MarsRoversTest #test10 stamp: 'I 5/9/2024 20:04:37'!
PASSED!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 20:05:06'!
test11
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'O' inWorkingArea:(  Point x:4 y:4).
	rover moveBackward.
	rover rotateToRight.
	rover rotateToRight.
	rover moveForward. 
	
	self assert: 'N' equals: (rover cardinalLocation).
	self assert: (Point x:2 y:3) equals: (rover location). ! !

!testRun: #MarsRoversTest #test11 stamp: 'I 5/9/2024 20:07:48'!
ERROR!
!N methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 20:07:57'!
rotateRight
	self shouldBeImplemented.! !
!N methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 20:08:06' prior: 50601074!
rotateRight
	^E new! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 20:08:25' prior: 50601058!
test11
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'O' inWorkingArea:(  Point x:4 y:4).
	rover moveBackward.
	rover rotateToRight.
	rover rotateToRight.
	rover moveForward. 
	
	self assert: 'E' equals: (rover cardinalLocation).
	self assert: (Point x:3 y:3) equals: (rover location). ! !

!testRun: #MarsRoversTest #test11 stamp: 'I 5/9/2024 20:08:27'!
FAILURE!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 20:08:49' prior: 50601082!
test11
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'O' inWorkingArea:(  Point x:4 y:4).
	rover moveBackward.
	rover rotateToRight.
	rover rotateToRight.
	rover moveForward. 
	
	self assert: 'E' equals: (rover cardinalLocation).
	self assert: (Point x:3 y:2) equals: (rover location). ! !

!testRun: #MarsRoversTest #test11 stamp: 'I 5/9/2024 20:08:50'!
PASSED!

!testRun: #MarsRoversTest #test01InitializeAndReturnsTheLocationOfTheRover stamp: 'I 5/9/2024 20:08:50'!
PASSED!

!testRun: #MarsRoversTest #test02ARoverIsPlacedOutOfTheReachOfWork stamp: 'I 5/9/2024 20:08:50'!
PASSED!

!testRun: #MarsRoversTest #test03ARoverPointingToNorthMoveForward stamp: 'I 5/9/2024 20:08:50'!
PASSED!

!testRun: #MarsRoversTest #test04RoverPointingToNorthMoveBackward stamp: 'I 5/9/2024 20:08:50'!
PASSED!

!testRun: #MarsRoversTest #test05RoverPointingSouthMoveForward stamp: 'I 5/9/2024 20:08:50'!
PASSED!

!testRun: #MarsRoversTest #test06RoverMoveForwardTwoTimes stamp: 'I 5/9/2024 20:08:50'!
PASSED!

!testRun: #MarsRoversTest #test07RoverPointingWestMoveForward stamp: 'I 5/9/2024 20:08:50'!
PASSED!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/9/2024 20:08:50'!
PASSED!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/9/2024 20:08:50'!
PASSED!

!testRun: #MarsRoversTest #test10 stamp: 'I 5/9/2024 20:08:50'!
PASSED!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/9/2024 20:08:50'!
PASSED!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 20:08:59' prior: 50601099!
test11
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'O' inWorkingArea:(  Point x:4 y:4).
	rover moveBackward.
	rover rotateToRight.
	rover rotateToLeft.
	rover moveForward. 
	
	self assert: 'E' equals: (rover cardinalLocation).
	self assert: (Point x:3 y:2) equals: (rover location). ! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 20:09:17' prior: 50601149!
test11
	|rover startingLocation|
	
	startingLocation := Point x: 1 y:2.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'O' inWorkingArea:(  Point x:4 y:4).
	rover moveBackward.
	rover rotateToRight.
	rover rotateToLeft.
	rover moveForward. 
	
	self assert: 'O' equals: (rover cardinalLocation).
	self assert: (Point x:1 y:2) equals: (rover location). ! !

!testRun: #MarsRoversTest #test11 stamp: 'I 5/9/2024 20:09:18'!
ERROR!
!N methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 20:09:23'!
rotateToLeft
	self shouldBeImplemented.! !
!N methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 20:09:33' prior: 50601180!
rotateToLeft
	^O new.! !

!testRun: #MarsRoversTest #test11 stamp: 'I 5/9/2024 20:09:37'!
PASSED!

!testRun: #MarsRoversTest #test01InitializeAndReturnsTheLocationOfTheRover stamp: 'I 5/9/2024 20:09:37'!
PASSED!

!testRun: #MarsRoversTest #test02ARoverIsPlacedOutOfTheReachOfWork stamp: 'I 5/9/2024 20:09:37'!
PASSED!

!testRun: #MarsRoversTest #test03ARoverPointingToNorthMoveForward stamp: 'I 5/9/2024 20:09:37'!
PASSED!

!testRun: #MarsRoversTest #test04RoverPointingToNorthMoveBackward stamp: 'I 5/9/2024 20:09:37'!
PASSED!

!testRun: #MarsRoversTest #test05RoverPointingSouthMoveForward stamp: 'I 5/9/2024 20:09:37'!
PASSED!

!testRun: #MarsRoversTest #test06RoverMoveForwardTwoTimes stamp: 'I 5/9/2024 20:09:37'!
PASSED!

!testRun: #MarsRoversTest #test07RoverPointingWestMoveForward stamp: 'I 5/9/2024 20:09:37'!
PASSED!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/9/2024 20:09:37'!
PASSED!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/9/2024 20:09:37'!
PASSED!

!testRun: #MarsRoversTest #test10 stamp: 'I 5/9/2024 20:09:37'!
PASSED!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/9/2024 20:09:37'!
PASSED!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/9/2024 20:11:04'!
PASSED!

!testRun: #MarsRoversTest #test01InitializeAndReturnsTheLocationOfTheRover stamp: 'I 5/9/2024 20:11:04'!
PASSED!

!testRun: #MarsRoversTest #test02ARoverIsPlacedOutOfTheReachOfWork stamp: 'I 5/9/2024 20:11:04'!
PASSED!

!testRun: #MarsRoversTest #test03ARoverPointingToNorthMoveForward stamp: 'I 5/9/2024 20:11:04'!
PASSED!

!testRun: #MarsRoversTest #test04RoverPointingToNorthMoveBackward stamp: 'I 5/9/2024 20:11:04'!
PASSED!

!testRun: #MarsRoversTest #test05RoverPointingSouthMoveForward stamp: 'I 5/9/2024 20:11:04'!
PASSED!

!testRun: #MarsRoversTest #test06RoverMoveForwardTwoTimes stamp: 'I 5/9/2024 20:11:04'!
PASSED!

!testRun: #MarsRoversTest #test07RoverPointingWestMoveForward stamp: 'I 5/9/2024 20:11:04'!
PASSED!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/9/2024 20:11:04'!
PASSED!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/9/2024 20:11:04'!
PASSED!

!testRun: #MarsRoversTest #test10 stamp: 'I 5/9/2024 20:11:04'!
PASSED!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/9/2024 20:11:04'!
PASSED!
!E methodsFor: 'nil' stamp: 'I 5/9/2024 20:11:27'!
rotateToLeft
	^N new.! !
!E methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 20:11:45'!
rotateToRight
	^S new.! !
!S methodsFor: 'nil' stamp: 'I 5/9/2024 20:12:09'!
rotateToRight
	^O new.! !
!S methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 20:12:16'!
rotateToLeft
	^E new.! !
!CardinalRule methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 20:12:38'!
rotateToLeft
	^self subclassResponsibility ! !
!CardinalRule methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 20:12:42'!
rotateToRight
	^self subclassResponsibility ! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 20:14:50'!
test12ARoverMoveOutOfRange
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 4 y:3.
	areaOfWork := Point x: 3 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'N' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveForward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Rover fuera de rango' ]! !

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRange stamp: 'I 5/9/2024 20:14:52'!
ERROR!
!MarsRovers methodsFor: 'action' stamp: 'I 5/9/2024 20:33:30' prior: 50600641!
moveForward
	locationPoint := locationPoint + (cardinalPoint canMoveForward:self inAreaOfWork:  workingArea).! !

!testRun: #MarsRoversTest #test05RoverPointingSouthMoveForward stamp: 'I 5/9/2024 20:33:34'!
ERROR!

!testRun: #MarsRoversTest #test05RoverPointingSouthMoveForward stamp: 'I 5/9/2024 20:33:34'!
ERROR!
!CardinalRule methodsFor: 'nil' stamp: 'I 5/9/2024 20:48:30'!
canMoveForward: aRover inAreaOfWork:  workingArea
	^self subclassResponsibility! !
!N methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 20:48:35' overrides: 50601309!
canMoveForward: aRover inAreaOfWork:  workingArea
	^self subclassResponsibility! !
!S methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 20:48:35' overrides: 50601309!
canMoveForward: aRover inAreaOfWork:  workingArea
	^self subclassResponsibility! !
!O methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 20:48:35' overrides: 50601309!
canMoveForward: aRover inAreaOfWork:  workingArea
	^self subclassResponsibility! !
!E methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 20:48:35' overrides: 50601309!
canMoveForward: aRover inAreaOfWork:  workingArea
	^self subclassResponsibility! !
!CardinalRule methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 20:48:35' prior: 50601309!
canMoveForward: aRover inAreaOfWork: workingArea

	self subclassResponsibility! !
!E methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 20:51:13' prior: 50601333 overrides: 50601339!
canMoveForward: aRover inAreaOfWork:  workingArea
	(aRover location x = (workingArea x) ) ifTrue:[aRover class outOfRangeOfWork ].! !
!E methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 20:51:32' prior: 50601345 overrides: 50601339!
canMoveForward: aRover inAreaOfWork:  workingArea
	(aRover location x = (workingArea x) ) ifTrue:[^aRover class outOfRangeOfWork ].
	^self moveForward! !
!N methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 20:52:29' prior: 50601315 overrides: 50601339!
canMoveForward: aRover inAreaOfWork:  workingArea
	(aRover location y = (workingArea y) ) ifTrue:[^aRover class outOfRangeOfWork ].
	^self moveForward! !

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRange stamp: 'I 5/9/2024 20:52:33'!
ERROR!

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRange stamp: 'I 5/9/2024 20:52:33'!
ERROR!

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRange stamp: 'I 5/9/2024 20:52:48'!
ERROR!
!MarsRovers class methodsFor: 'instance creation' stamp: 'I 5/9/2024 20:53:55' prior: 50600025!
locationAt: startingLocation pointingTo: cardinalLocation inWorkingArea: areaOfWork
	((startingLocation x ) negative or:[(startingLocation y ) negative] ) ifTrue:[self negativeCoordinatesNotAllowed].
	((startingLocation x<= (areaOfWork x)) and:[startingLocation y<= (areaOfWork y)]) ifFalse: [self error: self outOfRangeOfWork].
	^self new initializeLocationAt: startingLocation pointingTo: cardinalLocation inWorkingArea: areaOfWork
	
 ! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 20:54:12' prior: 50601278!
test12ARoverMoveOutOfRange
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 4 y:3.
	areaOfWork := Point x: 6 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'N' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveForward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Rover fuera de rango' ]! !

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRange stamp: 'I 5/9/2024 20:54:16'!
FAILURE!

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRange stamp: 'I 5/9/2024 20:54:16'!
FAILURE!

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRange stamp: 'I 5/9/2024 20:54:55'!
FAILURE!
!MarsRovers class methodsFor: 'instance creation' stamp: 'I 5/9/2024 20:57:02' prior: 50601379!
locationAt: startingLocation pointingTo: cardinalLocation inWorkingArea: areaOfWork
	((startingLocation x ) negative or:[(startingLocation y ) negative] ) ifTrue:[self error: self negativeCoordinatesNotAllowed].
	((startingLocation x<= (areaOfWork x)) and:[startingLocation y<= (areaOfWork y)]) ifFalse: [self error: self outOfRangeOfWork].
	^self new initializeLocationAt: startingLocation pointingTo: cardinalLocation inWorkingArea: areaOfWork
	
 ! !
!N methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 20:57:07' prior: 50601362 overrides: 50601339!
canMoveForward: aRover inAreaOfWork:  workingArea
	(aRover location y = (workingArea y) ) ifTrue:[^aRover class error: self class outOfRangeOfWork ].
	^self moveForward! !

!testRun: #MarsRoversTest #test01InitializeAndReturnsTheLocationOfTheRover stamp: 'I 5/9/2024 20:57:14'!
PASSED!

!testRun: #MarsRoversTest #test02ARoverIsPlacedOutOfTheReachOfWork stamp: 'I 5/9/2024 20:57:14'!
PASSED!

!testRun: #MarsRoversTest #test03ARoverPointingToNorthMoveForward stamp: 'I 5/9/2024 20:57:14'!
PASSED!

!testRun: #MarsRoversTest #test04RoverPointingToNorthMoveBackward stamp: 'I 5/9/2024 20:57:14'!
PASSED!

!testRun: #MarsRoversTest #test05RoverPointingSouthMoveForward stamp: 'I 5/9/2024 20:57:14'!
ERROR!

!testRun: #MarsRoversTest #test06RoverMoveForwardTwoTimes stamp: 'I 5/9/2024 20:57:14'!
ERROR!

!testRun: #MarsRoversTest #test07RoverPointingWestMoveForward stamp: 'I 5/9/2024 20:57:14'!
ERROR!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/9/2024 20:57:14'!
PASSED!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/9/2024 20:57:14'!
ERROR!

!testRun: #MarsRoversTest #test10 stamp: 'I 5/9/2024 20:57:14'!
PASSED!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/9/2024 20:57:14'!
ERROR!

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRange stamp: 'I 5/9/2024 20:57:14'!
ERROR!

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRange stamp: 'I 5/9/2024 20:57:21'!
ERROR!

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRange stamp: 'I 5/9/2024 20:57:21'!
ERROR!
!N methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 20:57:58' prior: 50601439 overrides: 50601339!
canMoveForward: aRover inAreaOfWork:  workingArea
	(aRover location y = (workingArea y) ) ifTrue:[^aRover class error: aRover class outOfRangeOfWork ].
	^self moveForward! !

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRange stamp: 'I 5/9/2024 20:58:03'!
PASSED!

!testRun: #MarsRoversTest #test01InitializeAndReturnsTheLocationOfTheRover stamp: 'I 5/9/2024 20:58:03'!
PASSED!

!testRun: #MarsRoversTest #test02ARoverIsPlacedOutOfTheReachOfWork stamp: 'I 5/9/2024 20:58:03'!
PASSED!

!testRun: #MarsRoversTest #test03ARoverPointingToNorthMoveForward stamp: 'I 5/9/2024 20:58:03'!
PASSED!

!testRun: #MarsRoversTest #test04RoverPointingToNorthMoveBackward stamp: 'I 5/9/2024 20:58:03'!
PASSED!

!testRun: #MarsRoversTest #test05RoverPointingSouthMoveForward stamp: 'I 5/9/2024 20:58:03'!
ERROR!

!testRun: #MarsRoversTest #test06RoverMoveForwardTwoTimes stamp: 'I 5/9/2024 20:58:03'!
ERROR!

!testRun: #MarsRoversTest #test07RoverPointingWestMoveForward stamp: 'I 5/9/2024 20:58:03'!
ERROR!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/9/2024 20:58:03'!
PASSED!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/9/2024 20:58:03'!
ERROR!

!testRun: #MarsRoversTest #test10 stamp: 'I 5/9/2024 20:58:03'!
PASSED!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/9/2024 20:58:03'!
ERROR!

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRange stamp: 'I 5/9/2024 20:58:03'!
PASSED!

!testRun: #MarsRoversTest #test10 stamp: 'I 5/9/2024 21:33:39'!
PASSED!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/9/2024 21:33:42'!
ERROR!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/9/2024 21:33:42'!
ERROR!
!S methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 21:34:24' prior: 50601321 overrides: 50601339!
canMoveForward: aRover inAreaOfWork:  workingArea
	^self moveForward.! !
!S methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 21:36:36' prior: 50601543 overrides: 50601339!
canMoveForward: aRover inAreaOfWork:  workingArea
	(aRover location y = 0 ) ifTrue:[^aRover class error: aRover class   negativeCoordinatesNotAllowed 		].
	(aRover location y = (workingArea y) ) ifTrue:[^aRover class error: aRover class   outOfRangeOfWork 		].
	^self moveForward.! !

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRange stamp: 'I 5/9/2024 21:37:49'!
PASSED!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/9/2024 21:37:51'!
ERROR!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/9/2024 21:37:51'!
ERROR!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/9/2024 21:37:54'!
ERROR!
!O methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 21:38:06' prior: 50601327 overrides: 50601339!
canMoveForward: aMarsRovers inAreaOfWork: aWorkingArea 
	self shouldBeImplemented.! !
!O methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 21:39:06' prior: 50601571 overrides: 50601339!
canMoveForward: aRover inAreaOfWork:  workingArea
	(aRover location x = 0 ) ifTrue:[^aRover class error: aRover class   negativeCoordinatesNotAllowed 		].
	(aRover location x = (workingArea x) ) ifTrue:[^aRover class error: aRover class   outOfRangeOfWork 		].
	^self moveForward.! !

!testRun: #MarsRoversTest #test11 stamp: 'I 5/9/2024 21:39:13'!
PASSED!

!testRun: #MarsRoversTest #test10 stamp: 'I 5/9/2024 21:39:15'!
PASSED!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/9/2024 21:39:17'!
PASSED!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/9/2024 21:39:18'!
PASSED!

!testRun: #MarsRoversTest #test07RoverPointingWestMoveForward stamp: 'I 5/9/2024 21:39:20'!
PASSED!

!testRun: #MarsRoversTest #test06RoverMoveForwardTwoTimes stamp: 'I 5/9/2024 21:39:21'!
PASSED!

!testRun: #MarsRoversTest #test05RoverPointingSouthMoveForward stamp: 'I 5/9/2024 21:39:23'!
PASSED!

!testRun: #MarsRoversTest #test04RoverPointingToNorthMoveBackward stamp: 'I 5/9/2024 21:39:24'!
PASSED!

!testRun: #MarsRoversTest #test02ARoverIsPlacedOutOfTheReachOfWork stamp: 'I 5/9/2024 21:39:26'!
PASSED!

!testRun: #MarsRoversTest #test03ARoverPointingToNorthMoveForward stamp: 'I 5/9/2024 21:39:27'!
PASSED!

!testRun: #MarsRoversTest #test01InitializeAndReturnsTheLocationOfTheRover stamp: 'I 5/9/2024 21:39:29'!
PASSED!

!testRun: #MarsRoversTest #test02ARoverIsPlacedOutOfTheReachOfWork stamp: 'I 5/9/2024 21:39:31'!
PASSED!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 21:51:41' prior: 50601396!
test12ARoverMoveOutOfRange
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 4 y:3.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'E' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveForward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Rover fuera de rango' ]! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 21:51:45' prior: 50601625!
test12ARoverMoveOutOfRange
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 4 y:3.
	areaOfWork := Point x: 6 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'N' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveForward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Rover fuera de rango' ]! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 21:51:49'!
test13
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 4 y:3.
	areaOfWork := Point x: 6 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'N' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveForward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Rover fuera de rango' ]! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 21:51:57' prior: 50601656!
test13
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 4 y:3.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'E' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveForward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Rover fuera de rango' ]! !

!testRun: #MarsRoversTest #test13 stamp: 'I 5/9/2024 21:51:58'!
FAILURE!
!E methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 21:52:39' prior: 50601353 overrides: 50601339!
canMoveForward: aRover inAreaOfWork:  workingArea
	(aRover location x = (workingArea x) ) ifTrue:[^aRover class error: aRover class outOfRangeOfWork ].
	^self moveForward! !

!testRun: #MarsRoversTest #test13 stamp: 'I 5/9/2024 21:52:41'!
PASSED!

!testRun: #MarsRoversTest #test01InitializeAndReturnsTheLocationOfTheRover stamp: 'I 5/9/2024 21:52:41'!
PASSED!

!testRun: #MarsRoversTest #test02ARoverIsPlacedOutOfTheReachOfWork stamp: 'I 5/9/2024 21:52:41'!
PASSED!

!testRun: #MarsRoversTest #test03ARoverPointingToNorthMoveForward stamp: 'I 5/9/2024 21:52:41'!
PASSED!

!testRun: #MarsRoversTest #test04RoverPointingToNorthMoveBackward stamp: 'I 5/9/2024 21:52:41'!
PASSED!

!testRun: #MarsRoversTest #test05RoverPointingSouthMoveForward stamp: 'I 5/9/2024 21:52:41'!
PASSED!

!testRun: #MarsRoversTest #test06RoverMoveForwardTwoTimes stamp: 'I 5/9/2024 21:52:41'!
PASSED!

!testRun: #MarsRoversTest #test07RoverPointingWestMoveForward stamp: 'I 5/9/2024 21:52:41'!
PASSED!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/9/2024 21:52:41'!
PASSED!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/9/2024 21:52:41'!
PASSED!

!testRun: #MarsRoversTest #test10 stamp: 'I 5/9/2024 21:52:41'!
PASSED!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/9/2024 21:52:41'!
PASSED!

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRange stamp: 'I 5/9/2024 21:52:41'!
PASSED!

!testRun: #MarsRoversTest #test13 stamp: 'I 5/9/2024 21:52:41'!
PASSED!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 21:53:13'!
test12ARoverMoveOutOfRangeMovingNorth
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 4 y:3.
	areaOfWork := Point x: 6 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'N' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveForward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Rover fuera de rango' ]! !

!methodRemoval: MarsRoversTest #test12ARoverMoveOutOfRange stamp: 'I 5/9/2024 21:53:13'!
test12ARoverMoveOutOfRange
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 4 y:3.
	areaOfWork := Point x: 6 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'N' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveForward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Rover fuera de rango' ]!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 21:54:06'!
test13RoverOutOfRangeMovingForwardEast
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 4 y:3.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'E' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveForward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Rover fuera de rango' ]! !

!methodRemoval: MarsRoversTest #test13 stamp: 'I 5/9/2024 21:54:06'!
test13
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 4 y:3.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'E' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveForward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Rover fuera de rango' ]!

----SNAPSHOT----(9 May 2024 21:54:12) CuisUniversity-6169.image priorSource: 8507292!

!testRun: #MarsRoversTest #test13RoverOutOfRangeMovingForwardEast stamp: 'I 5/9/2024 21:54:16'!
PASSED!

!testRun: #MarsRoversTest #test01InitializeAndReturnsTheLocationOfTheRover stamp: 'I 5/9/2024 21:54:16'!
PASSED!

!testRun: #MarsRoversTest #test02ARoverIsPlacedOutOfTheReachOfWork stamp: 'I 5/9/2024 21:54:17'!
PASSED!

!testRun: #MarsRoversTest #test03ARoverPointingToNorthMoveForward stamp: 'I 5/9/2024 21:54:17'!
PASSED!

!testRun: #MarsRoversTest #test04RoverPointingToNorthMoveBackward stamp: 'I 5/9/2024 21:54:17'!
PASSED!

!testRun: #MarsRoversTest #test05RoverPointingSouthMoveForward stamp: 'I 5/9/2024 21:54:17'!
PASSED!

!testRun: #MarsRoversTest #test06RoverMoveForwardTwoTimes stamp: 'I 5/9/2024 21:54:17'!
PASSED!

!testRun: #MarsRoversTest #test07RoverPointingWestMoveForward stamp: 'I 5/9/2024 21:54:17'!
PASSED!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/9/2024 21:54:17'!
PASSED!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/9/2024 21:54:17'!
PASSED!

!testRun: #MarsRoversTest #test10 stamp: 'I 5/9/2024 21:54:17'!
PASSED!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/9/2024 21:54:17'!
PASSED!

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRangeMovingNorth stamp: 'I 5/9/2024 21:54:17'!
PASSED!

!testRun: #MarsRoversTest #test13RoverOutOfRangeMovingForwardEast stamp: 'I 5/9/2024 21:54:17'!
PASSED!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 21:54:40' prior: 50601768!
test13RoverOutOfRangeMovingForwardEast
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 4 y:3.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'S' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveForward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Rover fuera de rango' ]! !

!testRun: #MarsRoversTest #test13RoverOutOfRangeMovingForwardEast stamp: 'I 5/9/2024 21:54:41'!
PASSED!

!testRun: #MarsRoversTest #test01InitializeAndReturnsTheLocationOfTheRover stamp: 'I 5/9/2024 21:54:41'!
PASSED!

!testRun: #MarsRoversTest #test02ARoverIsPlacedOutOfTheReachOfWork stamp: 'I 5/9/2024 21:54:41'!
PASSED!

!testRun: #MarsRoversTest #test03ARoverPointingToNorthMoveForward stamp: 'I 5/9/2024 21:54:41'!
PASSED!

!testRun: #MarsRoversTest #test04RoverPointingToNorthMoveBackward stamp: 'I 5/9/2024 21:54:41'!
PASSED!

!testRun: #MarsRoversTest #test05RoverPointingSouthMoveForward stamp: 'I 5/9/2024 21:54:41'!
PASSED!

!testRun: #MarsRoversTest #test06RoverMoveForwardTwoTimes stamp: 'I 5/9/2024 21:54:41'!
PASSED!

!testRun: #MarsRoversTest #test07RoverPointingWestMoveForward stamp: 'I 5/9/2024 21:54:41'!
PASSED!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/9/2024 21:54:41'!
PASSED!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/9/2024 21:54:41'!
PASSED!

!testRun: #MarsRoversTest #test10 stamp: 'I 5/9/2024 21:54:41'!
PASSED!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/9/2024 21:54:41'!
PASSED!

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRangeMovingNorth stamp: 'I 5/9/2024 21:54:41'!
PASSED!

!testRun: #MarsRoversTest #test13RoverOutOfRangeMovingForwardEast stamp: 'I 5/9/2024 21:54:41'!
PASSED!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 23:46:13'!
test14RoverOutOfRangeMovingForwardSouth
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 4 y:0.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'E' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveForward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Rover fuera de rango' ]! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 23:46:27' prior: 50598528!
test14RoverOutOfRangeMovingForwardSouth
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 4 y:0.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'E' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveForward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Coordenadas negativas no son validas' ]! !

!testRun: #MarsRoversTest #test14RoverOutOfRangeMovingForwardSouth stamp: 'I 5/9/2024 23:46:32'!
FAILURE!

!testRun: #MarsRoversTest #test14RoverOutOfRangeMovingForwardSouth stamp: 'I 5/9/2024 23:46:32'!
FAILURE!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 23:46:58' prior: 50598544!
test14RoverOutOfRangeMovingForwardSouth
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 4 y:0.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'S' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveForward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Coordenadas negativas no son validas' ]! !

!testRun: #MarsRoversTest #test14RoverOutOfRangeMovingForwardSouth stamp: 'I 5/9/2024 23:47:02'!
PASSED!

!testRun: #MarsRoversTest #test01InitializeAndReturnsTheLocationOfTheRover stamp: 'I 5/9/2024 23:47:02'!
PASSED!

!testRun: #MarsRoversTest #test02ARoverIsPlacedOutOfTheReachOfWork stamp: 'I 5/9/2024 23:47:03'!
PASSED!

!testRun: #MarsRoversTest #test03ARoverPointingToNorthMoveForward stamp: 'I 5/9/2024 23:47:03'!
PASSED!

!testRun: #MarsRoversTest #test04RoverPointingToNorthMoveBackward stamp: 'I 5/9/2024 23:47:03'!
PASSED!

!testRun: #MarsRoversTest #test05RoverPointingSouthMoveForward stamp: 'I 5/9/2024 23:47:03'!
PASSED!

!testRun: #MarsRoversTest #test06RoverMoveForwardTwoTimes stamp: 'I 5/9/2024 23:47:03'!
PASSED!

!testRun: #MarsRoversTest #test07RoverPointingWestMoveForward stamp: 'I 5/9/2024 23:47:03'!
PASSED!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/9/2024 23:47:03'!
PASSED!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/9/2024 23:47:03'!
PASSED!

!testRun: #MarsRoversTest #test10 stamp: 'I 5/9/2024 23:47:03'!
PASSED!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/9/2024 23:47:03'!
PASSED!

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRangeMovingNorth stamp: 'I 5/9/2024 23:47:03'!
PASSED!

!testRun: #MarsRoversTest #test13RoverOutOfRangeMovingForwardEast stamp: 'I 5/9/2024 23:47:03'!
PASSED!

!testRun: #MarsRoversTest #test14RoverOutOfRangeMovingForwardSouth stamp: 'I 5/9/2024 23:47:03'!
PASSED!
!S methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 23:47:50'!
canMoveBackward: aRover inAreaOfWork: arg2
	aRover location y = 0 ifTrue: [ ^ aRover class error: aRover class negativeCoordinatesNotAllowed ].
	aRover location y = arg2 y ifTrue: [ ^ aRover class error: aRover class outOfRangeOfWork ].
	^ self moveForward.! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 23:48:07' prior: 50600813!
test08RoverPointingWestMoveBackward
	| rover temp2 |
	temp2 := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: temp2
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover moveBackward.
	self
		assert:
			(Point
				x: 2
				y: 2)
		equals: rover location.! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 23:48:24' prior: 50598640!
test08RoverPointingWestMoveBackward
	| rover startingPoint |
	startingPoint := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: startingPoint
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover moveBackward.
	self
		assert:
			(Point
				x: 2
				y: 2)
		equals: rover location.! !
!S methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 23:48:41' prior: 50598629!
canMoveBackward: aRover inAreaOfWork: areaOfWork
	aRover location y = 0 ifTrue: [ ^ aRover class error: aRover class negativeCoordinatesNotAllowed ].
	aRover location y = areaOfWork y ifTrue: [ ^ aRover class error: aRover class outOfRangeOfWork ].
	^ self moveForward.! !
!S methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 23:49:11' prior: 50598665!
canMoveBackward: aRover inAreaOfWork: areaOfWork
	aRover location y = areaOfWork y ifTrue: [ ^ aRover class error: aRover class outOfRangeOfWork ].
	^ self moveBackward.! !
!O methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 23:49:57'!
canMoveBackward: aRover inAreaOfWork: areaOfWork
	aRover location x = (areaOfWork x) ifTrue: [ ^ aRover class error: aRover class outOfRangeOfWork ].
	^ self moveBackward.
! !

!testRun: #MarsRoversTest #test14RoverOutOfRangeMovingForwardSouth stamp: 'I 5/9/2024 23:56:09'!
PASSED!

!testRun: #MarsRoversTest #test01InitializeAndReturnsTheLocationOfTheRover stamp: 'I 5/9/2024 23:56:09'!
PASSED!

!testRun: #MarsRoversTest #test02ARoverIsPlacedOutOfTheReachOfWork stamp: 'I 5/9/2024 23:56:09'!
PASSED!

!testRun: #MarsRoversTest #test03ARoverPointingToNorthMoveForward stamp: 'I 5/9/2024 23:56:09'!
PASSED!

!testRun: #MarsRoversTest #test04RoverPointingToNorthMoveBackward stamp: 'I 5/9/2024 23:56:09'!
PASSED!

!testRun: #MarsRoversTest #test05RoverPointingSouthMoveForward stamp: 'I 5/9/2024 23:56:09'!
PASSED!

!testRun: #MarsRoversTest #test06RoverMoveForwardTwoTimes stamp: 'I 5/9/2024 23:56:09'!
PASSED!

!testRun: #MarsRoversTest #test07RoverPointingWestMoveForward stamp: 'I 5/9/2024 23:56:09'!
PASSED!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/9/2024 23:56:09'!
PASSED!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/9/2024 23:56:09'!
PASSED!

!testRun: #MarsRoversTest #test10 stamp: 'I 5/9/2024 23:56:09'!
PASSED!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/9/2024 23:56:09'!
PASSED!

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRangeMovingNorth stamp: 'I 5/9/2024 23:56:09'!
PASSED!

!testRun: #MarsRoversTest #test13RoverOutOfRangeMovingForwardEast stamp: 'I 5/9/2024 23:56:09'!
PASSED!

!testRun: #MarsRoversTest #test14RoverOutOfRangeMovingForwardSouth stamp: 'I 5/9/2024 23:56:09'!
PASSED!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 23:56:37'!
test15RoverOutOfRangeMovingForwardWest
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 4 y:0.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'S' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveForward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Coordenadas negativas no son validas' ]! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 23:57:12' prior: 50598739!
test15RoverOutOfRangeMovingForwardWest
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 0 y:3.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'O' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveForward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Coordenadas negativas no son validas' ]! !
!O methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 23:57:29' prior: 50601577 overrides: 50601339!
canMoveForward: arg1 inAreaOfWork: arg2
	arg1 location x = 0 ifTrue: [ ^ arg1 class error: arg1 class negativeCoordinatesNotAllowed ].
	^ self moveForward.! !
!S methodsFor: 'as yet unclassified' stamp: 'I 5/9/2024 23:57:57' prior: 50601549 overrides: 50601339!
canMoveForward: arg1 inAreaOfWork: arg2
	arg1 location y = 0 ifTrue: [ ^ arg1 class error: arg1 class negativeCoordinatesNotAllowed ].
	^ self moveForward.! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/9/2024 23:59:10' prior: 50598756!
test15RoverOutOfRangeMovingForwardWest
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 0 y:3.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'O' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveForward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Rover fuera de rango' ]! !

!testRun: #MarsRoversTest #test15RoverOutOfRangeMovingForwardWest stamp: 'I 5/9/2024 23:59:11'!
FAILURE!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/10/2024 00:00:04'!
test15RoverOutOfRangeMovingBackwardWest
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 0 y:3.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'O' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveBackward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Rover fuera de rango' ]! !

!testRun: #MarsRoversTest #test15RoverOutOfRangeMovingBackwardWest stamp: 'I 5/10/2024 00:00:05'!
FAILURE!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/10/2024 00:00:39' prior: 50598809!
test15RoverOutOfRangeMovingBackwardWest
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 4 y:3.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'O' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveBackward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Rover fuera de rango' ]! !

!testRun: #MarsRoversTest #test15RoverOutOfRangeMovingBackwardWest stamp: 'I 5/10/2024 00:00:41'!
FAILURE!
!MarsRovers methodsFor: 'action' stamp: 'I 5/10/2024 00:01:39' prior: 50600646!
moveBackward
	locationPoint := locationPoint + (cardinalPoint canMoveBackward: self inAreaOfWork: workingArea).! !

!methodRemoval: MarsRoversTest #test15RoverOutOfRangeMovingForwardWest stamp: 'I 5/10/2024 00:01:52'!
test15RoverOutOfRangeMovingForwardWest
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 0 y:3.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'O' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveForward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Rover fuera de rango' ]!

!testRun: #MarsRoversTest #test15RoverOutOfRangeMovingBackwardWest stamp: 'I 5/10/2024 00:01:53'!
PASSED!

!testRun: #MarsRoversTest #test01InitializeAndReturnsTheLocationOfTheRover stamp: 'I 5/10/2024 00:01:57'!
PASSED!

!testRun: #MarsRoversTest #test02ARoverIsPlacedOutOfTheReachOfWork stamp: 'I 5/10/2024 00:01:57'!
PASSED!

!testRun: #MarsRoversTest #test03ARoverPointingToNorthMoveForward stamp: 'I 5/10/2024 00:01:57'!
PASSED!

!testRun: #MarsRoversTest #test04RoverPointingToNorthMoveBackward stamp: 'I 5/10/2024 00:01:57'!
ERROR!

!testRun: #MarsRoversTest #test05RoverPointingSouthMoveForward stamp: 'I 5/10/2024 00:01:57'!
PASSED!

!testRun: #MarsRoversTest #test06RoverMoveForwardTwoTimes stamp: 'I 5/10/2024 00:01:57'!
PASSED!

!testRun: #MarsRoversTest #test07RoverPointingWestMoveForward stamp: 'I 5/10/2024 00:01:57'!
PASSED!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/10/2024 00:01:57'!
PASSED!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/10/2024 00:01:57'!
PASSED!

!testRun: #MarsRoversTest #test10 stamp: 'I 5/10/2024 00:01:57'!
PASSED!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/10/2024 00:01:57'!
PASSED!

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRangeMovingNorth stamp: 'I 5/10/2024 00:01:57'!
PASSED!

!testRun: #MarsRoversTest #test13RoverOutOfRangeMovingForwardEast stamp: 'I 5/10/2024 00:01:57'!
FAILURE!

!testRun: #MarsRoversTest #test14RoverOutOfRangeMovingForwardSouth stamp: 'I 5/10/2024 00:01:57'!
PASSED!

!testRun: #MarsRoversTest #test15RoverOutOfRangeMovingBackwardWest stamp: 'I 5/10/2024 00:01:57'!
PASSED!
!N methodsFor: 'as yet unclassified' stamp: 'I 5/10/2024 00:02:46'!
canMoveBackward: aRover inAreaOfWork: areaOfWork
	aRover location y = 0 ifTrue: [ ^ aRover class error: aRover class negativeCoordinatesNotAllowed ].
	^ self moveBackward.! !

!testRun: #MarsRoversTest #test15RoverOutOfRangeMovingBackwardWest stamp: 'I 5/10/2024 00:02:54'!
PASSED!

!testRun: #MarsRoversTest #test01InitializeAndReturnsTheLocationOfTheRover stamp: 'I 5/10/2024 00:02:56'!
PASSED!

!testRun: #MarsRoversTest #test02ARoverIsPlacedOutOfTheReachOfWork stamp: 'I 5/10/2024 00:02:56'!
PASSED!

!testRun: #MarsRoversTest #test03ARoverPointingToNorthMoveForward stamp: 'I 5/10/2024 00:02:56'!
PASSED!

!testRun: #MarsRoversTest #test04RoverPointingToNorthMoveBackward stamp: 'I 5/10/2024 00:02:56'!
PASSED!

!testRun: #MarsRoversTest #test05RoverPointingSouthMoveForward stamp: 'I 5/10/2024 00:02:56'!
PASSED!

!testRun: #MarsRoversTest #test06RoverMoveForwardTwoTimes stamp: 'I 5/10/2024 00:02:56'!
PASSED!

!testRun: #MarsRoversTest #test07RoverPointingWestMoveForward stamp: 'I 5/10/2024 00:02:56'!
PASSED!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/10/2024 00:02:56'!
PASSED!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/10/2024 00:02:56'!
PASSED!

!testRun: #MarsRoversTest #test10 stamp: 'I 5/10/2024 00:02:56'!
PASSED!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/10/2024 00:02:56'!
PASSED!

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRangeMovingNorth stamp: 'I 5/10/2024 00:02:56'!
PASSED!

!testRun: #MarsRoversTest #test13RoverOutOfRangeMovingForwardEast stamp: 'I 5/10/2024 00:02:56'!
FAILURE!

!testRun: #MarsRoversTest #test14RoverOutOfRangeMovingForwardSouth stamp: 'I 5/10/2024 00:02:56'!
PASSED!

!testRun: #MarsRoversTest #test15RoverOutOfRangeMovingBackwardWest stamp: 'I 5/10/2024 00:02:56'!
PASSED!

!testRun: #MarsRoversTest #test13RoverOutOfRangeMovingForwardEast stamp: 'I 5/10/2024 00:02:56'!
FAILURE!

!testRun: #MarsRoversTest #test13RoverOutOfRangeMovingForwardEast stamp: 'I 5/10/2024 00:03:03'!
FAILURE!

!testRun: #MarsRoversTest #test13RoverOutOfRangeMovingForwardEast stamp: 'I 5/10/2024 00:03:03'!
FAILURE!
!S methodsFor: 'as yet unclassified' stamp: 'I 5/10/2024 00:03:40' prior: 50598782 overrides: 50601339!
canMoveForward: arg1 inAreaOfWork: arg2
	(arg1 location y = 0) ifTrue: [ ^ arg1 class error: arg1 class negativeCoordinatesNotAllowed ].
	^ self moveForward.! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/10/2024 00:03:54' prior: 50598470!
test13RoverOutOfRangeMovingForwardEast
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 4 y:3.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'E' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveForward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Rover fuera de rango' ]! !

!testRun: #MarsRoversTest #test13RoverOutOfRangeMovingForwardEast stamp: 'I 5/10/2024 00:03:55'!
PASSED!

!testRun: #MarsRoversTest #test01InitializeAndReturnsTheLocationOfTheRover stamp: 'I 5/10/2024 00:03:55'!
PASSED!

!testRun: #MarsRoversTest #test02ARoverIsPlacedOutOfTheReachOfWork stamp: 'I 5/10/2024 00:03:55'!
PASSED!

!testRun: #MarsRoversTest #test03ARoverPointingToNorthMoveForward stamp: 'I 5/10/2024 00:03:55'!
PASSED!

!testRun: #MarsRoversTest #test04RoverPointingToNorthMoveBackward stamp: 'I 5/10/2024 00:03:55'!
PASSED!

!testRun: #MarsRoversTest #test05RoverPointingSouthMoveForward stamp: 'I 5/10/2024 00:03:55'!
PASSED!

!testRun: #MarsRoversTest #test06RoverMoveForwardTwoTimes stamp: 'I 5/10/2024 00:03:55'!
PASSED!

!testRun: #MarsRoversTest #test07RoverPointingWestMoveForward stamp: 'I 5/10/2024 00:03:55'!
PASSED!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/10/2024 00:03:55'!
PASSED!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/10/2024 00:03:55'!
PASSED!

!testRun: #MarsRoversTest #test10 stamp: 'I 5/10/2024 00:03:55'!
PASSED!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/10/2024 00:03:55'!
PASSED!

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRangeMovingNorth stamp: 'I 5/10/2024 00:03:55'!
PASSED!

!testRun: #MarsRoversTest #test13RoverOutOfRangeMovingForwardEast stamp: 'I 5/10/2024 00:03:55'!
PASSED!

!testRun: #MarsRoversTest #test14RoverOutOfRangeMovingForwardSouth stamp: 'I 5/10/2024 00:03:55'!
PASSED!

!testRun: #MarsRoversTest #test15RoverOutOfRangeMovingBackwardWest stamp: 'I 5/10/2024 00:03:55'!
PASSED!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/10/2024 00:04:25'!
test15RoverOutOfRangeMovingBackwardEast
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 0 y:3.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'O' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveBackward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Rover fuera de rango' ]! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/10/2024 00:04:41'!
test16RoverOutOfRangeMovingBackwardEast
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 0 y:3.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'O' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveBackward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Rover fuera de rango' ]! !

!methodRemoval: MarsRoversTest #test15RoverOutOfRangeMovingBackwardEast stamp: 'I 5/10/2024 00:04:41'!
test15RoverOutOfRangeMovingBackwardEast
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 0 y:3.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'O' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveBackward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Rover fuera de rango' ]!

!testRun: #MarsRoversTest #test16RoverOutOfRangeMovingBackwardEast stamp: 'I 5/10/2024 00:11:50'!
FAILURE!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/10/2024 00:12:07' prior: 50599079!
test16RoverOutOfRangeMovingBackwardEast
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 0 y:3.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'E' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveBackward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Rover fuera de rango' ]! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/10/2024 00:12:23' prior: 50599115!
test16RoverOutOfRangeMovingBackwardEast
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 0 y:3.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'E' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveBackward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Coordenadas negativas no son validas' ]! !

!testRun: #MarsRoversTest #test16RoverOutOfRangeMovingBackwardEast stamp: 'I 5/10/2024 00:12:24'!
ERROR!
!E methodsFor: 'as yet unclassified' stamp: 'I 5/10/2024 00:13:03'!
canMoveBackward: aMarsRovers inAreaOfWork: aWorkingArea 
	self shouldBeImplemented.! !
!E methodsFor: 'as yet unclassified' stamp: 'I 5/10/2024 00:14:04' prior: 50599151!
canMoveBackward: aMarsRovers inAreaOfWork: aWorkingArea 
	(aMarsRovers location x = 0) ifTrue:[^self class error: self class negativeCoordinatesNotAllowed ].
	^self moveBackward ! !

!testRun: #MarsRoversTest #test01InitializeAndReturnsTheLocationOfTheRover stamp: 'I 5/10/2024 00:14:09'!
PASSED!

!testRun: #MarsRoversTest #test02ARoverIsPlacedOutOfTheReachOfWork stamp: 'I 5/10/2024 00:14:09'!
PASSED!

!testRun: #MarsRoversTest #test03ARoverPointingToNorthMoveForward stamp: 'I 5/10/2024 00:14:09'!
PASSED!

!testRun: #MarsRoversTest #test04RoverPointingToNorthMoveBackward stamp: 'I 5/10/2024 00:14:09'!
PASSED!

!testRun: #MarsRoversTest #test05RoverPointingSouthMoveForward stamp: 'I 5/10/2024 00:14:09'!
PASSED!

!testRun: #MarsRoversTest #test06RoverMoveForwardTwoTimes stamp: 'I 5/10/2024 00:14:09'!
PASSED!

!testRun: #MarsRoversTest #test07RoverPointingWestMoveForward stamp: 'I 5/10/2024 00:14:09'!
PASSED!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/10/2024 00:14:09'!
PASSED!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/10/2024 00:14:09'!
PASSED!

!testRun: #MarsRoversTest #test10 stamp: 'I 5/10/2024 00:14:09'!
PASSED!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/10/2024 00:14:09'!
PASSED!

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRangeMovingNorth stamp: 'I 5/10/2024 00:14:09'!
PASSED!

!testRun: #MarsRoversTest #test13RoverOutOfRangeMovingForwardEast stamp: 'I 5/10/2024 00:14:09'!
PASSED!

!testRun: #MarsRoversTest #test14RoverOutOfRangeMovingForwardSouth stamp: 'I 5/10/2024 00:14:09'!
PASSED!

!testRun: #MarsRoversTest #test15RoverOutOfRangeMovingBackwardWest stamp: 'I 5/10/2024 00:14:09'!
PASSED!

!testRun: #MarsRoversTest #test16RoverOutOfRangeMovingBackwardEast stamp: 'I 5/10/2024 00:14:09'!
ERROR!

!testRun: #MarsRoversTest #test16RoverOutOfRangeMovingBackwardEast stamp: 'I 5/10/2024 00:14:09'!
ERROR!

!testRun: #MarsRoversTest #test16RoverOutOfRangeMovingBackwardEast stamp: 'I 5/10/2024 00:14:36'!
ERROR!
!E methodsFor: 'as yet unclassified' stamp: 'I 5/10/2024 00:14:45' prior: 50599157!
canMoveBackward: aMarsRovers inAreaOfWork: aWorkingArea 
	(aMarsRovers location x = 0) ifTrue:[^self class error:aMarsRovers class negativeCoordinatesNotAllowed ].
	^self moveBackward ! !

!testRun: #MarsRoversTest #test16RoverOutOfRangeMovingBackwardEast stamp: 'I 5/10/2024 00:14:47'!
PASSED!

!testRun: #MarsRoversTest #test01InitializeAndReturnsTheLocationOfTheRover stamp: 'I 5/10/2024 00:14:47'!
PASSED!

!testRun: #MarsRoversTest #test02ARoverIsPlacedOutOfTheReachOfWork stamp: 'I 5/10/2024 00:14:47'!
PASSED!

!testRun: #MarsRoversTest #test03ARoverPointingToNorthMoveForward stamp: 'I 5/10/2024 00:14:47'!
PASSED!

!testRun: #MarsRoversTest #test04RoverPointingToNorthMoveBackward stamp: 'I 5/10/2024 00:14:47'!
PASSED!

!testRun: #MarsRoversTest #test05RoverPointingSouthMoveForward stamp: 'I 5/10/2024 00:14:47'!
PASSED!

!testRun: #MarsRoversTest #test06RoverMoveForwardTwoTimes stamp: 'I 5/10/2024 00:14:47'!
PASSED!

!testRun: #MarsRoversTest #test07RoverPointingWestMoveForward stamp: 'I 5/10/2024 00:14:47'!
PASSED!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/10/2024 00:14:47'!
PASSED!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/10/2024 00:14:47'!
PASSED!

!testRun: #MarsRoversTest #test10 stamp: 'I 5/10/2024 00:14:47'!
PASSED!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/10/2024 00:14:47'!
PASSED!

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRangeMovingNorth stamp: 'I 5/10/2024 00:14:47'!
PASSED!

!testRun: #MarsRoversTest #test13RoverOutOfRangeMovingForwardEast stamp: 'I 5/10/2024 00:14:47'!
PASSED!

!testRun: #MarsRoversTest #test14RoverOutOfRangeMovingForwardSouth stamp: 'I 5/10/2024 00:14:47'!
PASSED!

!testRun: #MarsRoversTest #test15RoverOutOfRangeMovingBackwardWest stamp: 'I 5/10/2024 00:14:47'!
PASSED!

!testRun: #MarsRoversTest #test16RoverOutOfRangeMovingBackwardEast stamp: 'I 5/10/2024 00:14:47'!
PASSED!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/10/2024 00:16:34'!
test17RoverOutOfRangeMovingForwardWest
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 0 y:2.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'O' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveForward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Coordenadas negativas no son validas' ]! !

!testRun: #MarsRoversTest #test17RoverOutOfRangeMovingForwardWest stamp: 'I 5/10/2024 00:16:36'!
PASSED!

!testRun: #MarsRoversTest #test01InitializeAndReturnsTheLocationOfTheRover stamp: 'I 5/10/2024 00:16:36'!
PASSED!

!testRun: #MarsRoversTest #test02ARoverIsPlacedOutOfTheReachOfWork stamp: 'I 5/10/2024 00:16:36'!
PASSED!

!testRun: #MarsRoversTest #test03ARoverPointingToNorthMoveForward stamp: 'I 5/10/2024 00:16:36'!
PASSED!

!testRun: #MarsRoversTest #test04RoverPointingToNorthMoveBackward stamp: 'I 5/10/2024 00:16:36'!
PASSED!

!testRun: #MarsRoversTest #test05RoverPointingSouthMoveForward stamp: 'I 5/10/2024 00:16:36'!
PASSED!

!testRun: #MarsRoversTest #test06RoverMoveForwardTwoTimes stamp: 'I 5/10/2024 00:16:36'!
PASSED!

!testRun: #MarsRoversTest #test07RoverPointingWestMoveForward stamp: 'I 5/10/2024 00:16:36'!
PASSED!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/10/2024 00:16:36'!
PASSED!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/10/2024 00:16:36'!
PASSED!

!testRun: #MarsRoversTest #test10 stamp: 'I 5/10/2024 00:16:36'!
PASSED!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/10/2024 00:16:36'!
PASSED!

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRangeMovingNorth stamp: 'I 5/10/2024 00:16:36'!
PASSED!

!testRun: #MarsRoversTest #test13RoverOutOfRangeMovingForwardEast stamp: 'I 5/10/2024 00:16:36'!
PASSED!

!testRun: #MarsRoversTest #test14RoverOutOfRangeMovingForwardSouth stamp: 'I 5/10/2024 00:16:36'!
PASSED!

!testRun: #MarsRoversTest #test15RoverOutOfRangeMovingBackwardWest stamp: 'I 5/10/2024 00:16:36'!
PASSED!

!testRun: #MarsRoversTest #test16RoverOutOfRangeMovingBackwardEast stamp: 'I 5/10/2024 00:16:36'!
PASSED!

!testRun: #MarsRoversTest #test17RoverOutOfRangeMovingForwardWest stamp: 'I 5/10/2024 00:16:36'!
PASSED!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/10/2024 00:17:00'!
test16RoverOutOfRangeMovingBackwardNort
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 3 y:0.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'N' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveBackward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Coordenadas negativas no son validas' ]! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/10/2024 00:17:09'!
test18RoverOutOfRangeMovingBackwardNort
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 3 y:0.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'N' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveBackward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Coordenadas negativas no son validas' ]! !

!methodRemoval: MarsRoversTest #test16RoverOutOfRangeMovingBackwardNort stamp: 'I 5/10/2024 00:17:09'!
test16RoverOutOfRangeMovingBackwardNort
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 3 y:0.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'N' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveBackward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Coordenadas negativas no son validas' ]!

!testRun: #MarsRoversTest #test18RoverOutOfRangeMovingBackwardNort stamp: 'I 5/10/2024 00:17:11'!
PASSED!

!testRun: #MarsRoversTest #test01InitializeAndReturnsTheLocationOfTheRover stamp: 'I 5/10/2024 00:17:11'!
PASSED!

!testRun: #MarsRoversTest #test02ARoverIsPlacedOutOfTheReachOfWork stamp: 'I 5/10/2024 00:17:11'!
PASSED!

!testRun: #MarsRoversTest #test03ARoverPointingToNorthMoveForward stamp: 'I 5/10/2024 00:17:11'!
PASSED!

!testRun: #MarsRoversTest #test04RoverPointingToNorthMoveBackward stamp: 'I 5/10/2024 00:17:11'!
PASSED!

!testRun: #MarsRoversTest #test05RoverPointingSouthMoveForward stamp: 'I 5/10/2024 00:17:11'!
PASSED!

!testRun: #MarsRoversTest #test06RoverMoveForwardTwoTimes stamp: 'I 5/10/2024 00:17:11'!
PASSED!

!testRun: #MarsRoversTest #test07RoverPointingWestMoveForward stamp: 'I 5/10/2024 00:17:11'!
PASSED!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/10/2024 00:17:11'!
PASSED!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/10/2024 00:17:11'!
PASSED!

!testRun: #MarsRoversTest #test10 stamp: 'I 5/10/2024 00:17:11'!
PASSED!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/10/2024 00:17:11'!
PASSED!

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRangeMovingNorth stamp: 'I 5/10/2024 00:17:11'!
PASSED!

!testRun: #MarsRoversTest #test13RoverOutOfRangeMovingForwardEast stamp: 'I 5/10/2024 00:17:11'!
PASSED!

!testRun: #MarsRoversTest #test14RoverOutOfRangeMovingForwardSouth stamp: 'I 5/10/2024 00:17:11'!
PASSED!

!testRun: #MarsRoversTest #test15RoverOutOfRangeMovingBackwardWest stamp: 'I 5/10/2024 00:17:11'!
PASSED!

!testRun: #MarsRoversTest #test16RoverOutOfRangeMovingBackwardEast stamp: 'I 5/10/2024 00:17:11'!
PASSED!

!testRun: #MarsRoversTest #test17RoverOutOfRangeMovingForwardWest stamp: 'I 5/10/2024 00:17:11'!
PASSED!

!testRun: #MarsRoversTest #test18RoverOutOfRangeMovingBackwardNort stamp: 'I 5/10/2024 00:17:11'!
PASSED!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/10/2024 00:17:40'!
test18RoverOutOfRangeMovingBackwardSouth
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 3 y:3.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'S' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveBackward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Rover fuera de rango' ]! !

!testRun: #MarsRoversTest #test18RoverOutOfRangeMovingBackwardSouth stamp: 'I 5/10/2024 00:17:41'!
PASSED!

!testRun: #MarsRoversTest #test01InitializeAndReturnsTheLocationOfTheRover stamp: 'I 5/10/2024 00:17:41'!
PASSED!

!testRun: #MarsRoversTest #test02ARoverIsPlacedOutOfTheReachOfWork stamp: 'I 5/10/2024 00:17:41'!
PASSED!

!testRun: #MarsRoversTest #test03ARoverPointingToNorthMoveForward stamp: 'I 5/10/2024 00:17:41'!
PASSED!

!testRun: #MarsRoversTest #test04RoverPointingToNorthMoveBackward stamp: 'I 5/10/2024 00:17:41'!
PASSED!

!testRun: #MarsRoversTest #test05RoverPointingSouthMoveForward stamp: 'I 5/10/2024 00:17:41'!
PASSED!

!testRun: #MarsRoversTest #test06RoverMoveForwardTwoTimes stamp: 'I 5/10/2024 00:17:41'!
PASSED!

!testRun: #MarsRoversTest #test07RoverPointingWestMoveForward stamp: 'I 5/10/2024 00:17:41'!
PASSED!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/10/2024 00:17:41'!
PASSED!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/10/2024 00:17:41'!
PASSED!

!testRun: #MarsRoversTest #test10 stamp: 'I 5/10/2024 00:17:41'!
PASSED!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/10/2024 00:17:41'!
PASSED!

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRangeMovingNorth stamp: 'I 5/10/2024 00:17:41'!
PASSED!

!testRun: #MarsRoversTest #test13RoverOutOfRangeMovingForwardEast stamp: 'I 5/10/2024 00:17:41'!
PASSED!

!testRun: #MarsRoversTest #test14RoverOutOfRangeMovingForwardSouth stamp: 'I 5/10/2024 00:17:41'!
PASSED!

!testRun: #MarsRoversTest #test15RoverOutOfRangeMovingBackwardWest stamp: 'I 5/10/2024 00:17:41'!
PASSED!

!testRun: #MarsRoversTest #test16RoverOutOfRangeMovingBackwardEast stamp: 'I 5/10/2024 00:17:41'!
PASSED!

!testRun: #MarsRoversTest #test17RoverOutOfRangeMovingForwardWest stamp: 'I 5/10/2024 00:17:41'!
PASSED!

!testRun: #MarsRoversTest #test18RoverOutOfRangeMovingBackwardNort stamp: 'I 5/10/2024 00:17:41'!
PASSED!

!testRun: #MarsRoversTest #test18RoverOutOfRangeMovingBackwardSouth stamp: 'I 5/10/2024 00:17:42'!
PASSED!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/10/2024 00:17:58'!
test19RoverOutOfRangeMovingBackwardSouth
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 3 y:3.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'S' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveBackward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Rover fuera de rango' ]! !

!methodRemoval: MarsRoversTest #test18RoverOutOfRangeMovingBackwardSouth stamp: 'I 5/10/2024 00:17:58'!
test18RoverOutOfRangeMovingBackwardSouth
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 3 y:3.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'S' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveBackward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Rover fuera de rango' ]!

----SNAPSHOT----(10 May 2024 00:51:32) CuisUniversity-6169.image priorSource: 8536741!

----QUIT----(10 May 2024 00:53:27) CuisUniversity-6169.image priorSource: 8573650!

----STARTUP---- (13 May 2024 01:03:44) as /home/ivan/Documents/Facu/Inge 1/linux64/linux64/CuisUniversity-6169.image!


!testRun: #MarsRoversTest #test01InitializeAndReturnsTheLocationOfTheRover stamp: 'I 5/13/2024 01:03:51'!
PASSED!

!testRun: #MarsRoversTest #test02ARoverIsPlacedOutOfTheReachOfWork stamp: 'I 5/13/2024 01:03:51'!
PASSED!

!testRun: #MarsRoversTest #test03ARoverPointingToNorthMoveForward stamp: 'I 5/13/2024 01:03:51'!
PASSED!

!testRun: #MarsRoversTest #test04RoverPointingToNorthMoveBackward stamp: 'I 5/13/2024 01:03:51'!
PASSED!

!testRun: #MarsRoversTest #test05RoverPointingSouthMoveForward stamp: 'I 5/13/2024 01:03:51'!
PASSED!

!testRun: #MarsRoversTest #test06RoverMoveForwardTwoTimes stamp: 'I 5/13/2024 01:03:51'!
PASSED!

!testRun: #MarsRoversTest #test07RoverPointingWestMoveForward stamp: 'I 5/13/2024 01:03:51'!
PASSED!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/13/2024 01:03:51'!
PASSED!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/13/2024 01:03:51'!
PASSED!

!testRun: #MarsRoversTest #test10 stamp: 'I 5/13/2024 01:03:51'!
PASSED!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/13/2024 01:03:51'!
PASSED!

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRangeMovingNorth stamp: 'I 5/13/2024 01:03:51'!
PASSED!

!testRun: #MarsRoversTest #test13RoverOutOfRangeMovingForwardEast stamp: 'I 5/13/2024 01:03:51'!
PASSED!

!testRun: #MarsRoversTest #test14RoverOutOfRangeMovingForwardSouth stamp: 'I 5/13/2024 01:03:51'!
PASSED!

!testRun: #MarsRoversTest #test15RoverOutOfRangeMovingBackwardWest stamp: 'I 5/13/2024 01:03:51'!
PASSED!

!testRun: #MarsRoversTest #test16RoverOutOfRangeMovingBackwardEast stamp: 'I 5/13/2024 01:03:51'!
PASSED!

!testRun: #MarsRoversTest #test17RoverOutOfRangeMovingForwardWest stamp: 'I 5/13/2024 01:03:51'!
PASSED!

!testRun: #MarsRoversTest #test18RoverOutOfRangeMovingBackwardNort stamp: 'I 5/13/2024 01:03:51'!
PASSED!

!testRun: #MarsRoversTest #test19RoverOutOfRangeMovingBackwardSouth stamp: 'I 5/13/2024 01:03:51'!
PASSED!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/13/2024 01:04:24' prior: 50601164!
test11
	| rover temp2 |
	temp2 := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: temp2
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover moveBackward.
	rover rotateToRight.
	rover rotateToLeft.
	rover moveForward.
	self
		assert: 'O'
		equals: rover cardinalLocation.
	self
		assert:
			(Point
				x: 1
				y: 2)
		equals: rover location.! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/13/2024 01:04:47' prior: 50599647!
test11
	| rover startingPoint |
	startingPoint := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: startingPoint
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover moveBackward.
	rover rotateToRight.
	rover rotateToLeft.
	rover moveForward.
	self
		assert: 'O'
		equals: rover cardinalLocation.
	self
		assert:
			(Point
				x: 1
				y: 2)
		equals: rover location.! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/13/2024 01:06:11' prior: 50599662!
test11
	| rover startingPoint |
	startingPoint := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: startingPoint
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover doAction: 'brf'.
	self
		assert: 'O'
		equals: rover cardinalLocation.
	self
		assert:
			(Point
				x: 2
				y: 3)
		equals: rover location.! !

!testRun: #MarsRoversTest #test11 stamp: 'I 5/13/2024 01:06:13'!
ERROR!
!MarsRovers methodsFor: 'action' stamp: 'I 5/13/2024 01:06:21'!
doAction: aRenameMe1 
	self shouldBeImplemented.! !

!classDefinition: #Actions category: #'Mars Rovers' stamp: 'I 5/13/2024 01:11:50'!
Object subclass: #Actions
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!
!MarsRovers methodsFor: 'action' stamp: 'I 5/13/2024 01:11:39' prior: 50599692!
doAction: listOfAction
	listOfAction do: [:action | |actionToRealize|
			actionToRealize := Actions for: action.
			actionToRealize doOnRover: self].! !

!testRun: #MarsRoversTest #test11 stamp: 'I 5/13/2024 01:11:59'!
ERROR!
!Object class methodsFor: 'instance creation' stamp: 'I 5/13/2024 01:12:10'!
for: action 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeFor: action ! !
!Object class methodsFor: 'instance creation' stamp: 'I 5/13/2024 01:13:17' prior: 50599713!
for: action 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	^(self subclasses detect: [:a | a asString asUppercase = (a asString)]) new .! !

!testRun: #MarsRoversTest #test11 stamp: 'I 5/13/2024 01:13:20'!
ERROR!

!testRun: #MarsRoversTest #test10 stamp: 'I 5/13/2024 01:14:24'!
PASSED!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/13/2024 01:14:36' prior: 50601012!
test10
	| rover temp2 |
	temp2 := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: temp2
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover moveBackward.
	rover rotateToRight.
	rover moveForward.
	self
		assert: 'N'
		equals: rover cardinalLocation.
	self
		assert:
			(Point
				x: 2
				y: 3)
		equals: rover location.! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/13/2024 01:14:42' prior: 50599734!
test10
	| rover starting |
	starting := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: starting
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover moveBackward.
	rover rotateToRight.
	rover moveForward.
	self
		assert: 'N'
		equals: rover cardinalLocation.
	self
		assert:
			(Point
				x: 2
				y: 3)
		equals: rover location.! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/13/2024 01:14:47'!
test20
	| rover starting |
	starting := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: starting
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover moveBackward.
	rover rotateToRight.
	rover moveForward.
	self
		assert: 'N'
		equals: rover cardinalLocation.
	self
		assert:
			(Point
				x: 2
				y: 3)
		equals: rover location.! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/13/2024 01:15:30' prior: 50599762!
test20
	| rover starting |
	starting := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: starting
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover doAction: 'brf'.	
	self
		assert: 'N'
		equals: rover cardinalLocation.
	self
		assert:
			(Point
				x: 2
				y: 3)
		equals: rover location.! !

!testRun: #MarsRoversTest #test20 stamp: 'I 5/13/2024 01:15:34'!
ERROR!

Actions subclass: #F
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!classDefinition: #F category: #'Mars Rovers' stamp: 'I 5/13/2024 01:15:56'!
Actions subclass: #F
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

Actions subclass: #B
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!classDefinition: #B category: #'Mars Rovers' stamp: 'I 5/13/2024 01:16:10'!
Actions subclass: #B
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

Actions subclass: #R
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!classDefinition: #R category: #'Mars Rovers' stamp: 'I 5/13/2024 01:16:12'!
Actions subclass: #R
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

Actions subclass: #L
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!classDefinition: #L category: #'Mars Rovers' stamp: 'I 5/13/2024 01:16:14'!
Actions subclass: #L
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!testRun: #MarsRoversTest #test20 stamp: 'I 5/13/2024 01:16:56'!
ERROR!

!testRun: #MarsRoversTest #test20 stamp: 'I 5/13/2024 01:16:56'!
ERROR!
!Object class methodsFor: 'instance creation' stamp: 'I 5/13/2024 01:17:34' prior: 50599721!
for: action 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	^(self subclasses detect: [:a | a asString = (a asStringas Uppercase)]) new .! !
!Object class methodsFor: 'instance creation' stamp: 'I 5/13/2024 01:17:40' prior: 50599836!
for: action 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	^(self subclasses detect: [:a | a asString = (a asString asUppercase)]) new .! !

!testRun: #MarsRoversTest #test20 stamp: 'I 5/13/2024 01:17:44'!
ERROR!
!Actions methodsFor: 'action' stamp: 'I 5/13/2024 01:18:07'!
doOnRover: aMarsRovers 
	self shouldBeImplemented.! !
!Actions methodsFor: 'action' stamp: 'I 5/13/2024 01:18:19' prior: 50599855!
doOnRover: aMarsRovers 
	self subclassResponsibility! !
!F methodsFor: 'action' stamp: 'I 5/13/2024 01:18:29' overrides: 50599860!
doOnRover: aMarsRovers 
	self subclassResponsibility! !
!B methodsFor: 'action' stamp: 'I 5/13/2024 01:18:29' overrides: 50599860!
doOnRover: aMarsRovers 
	self subclassResponsibility! !
!R methodsFor: 'action' stamp: 'I 5/13/2024 01:18:29' overrides: 50599860!
doOnRover: aMarsRovers 
	self subclassResponsibility! !
!L methodsFor: 'action' stamp: 'I 5/13/2024 01:18:29' overrides: 50599860!
doOnRover: aMarsRovers 
	self subclassResponsibility! !
!Actions methodsFor: 'action' stamp: 'I 5/13/2024 01:18:29' prior: 50599860!
doOnRover: aMarsRovers

	self subclassResponsibility! !
!B methodsFor: 'action' stamp: 'I 5/13/2024 01:18:45' prior: 50599870 overrides: 50599885!
doOnRover: aMarsRovers 
	aMarsRovers moveBackward.! !
!F methodsFor: 'action' stamp: 'I 5/13/2024 01:18:55' prior: 50599865 overrides: 50599885!
doOnRover: aMarsRovers 
	aMarsRovers moveForward ! !
!L methodsFor: 'action' stamp: 'I 5/13/2024 01:19:07' prior: 50599880 overrides: 50599885!
doOnRover: aMarsRovers 
	aMarsRovers rotateToLeft ! !
!R methodsFor: 'action' stamp: 'I 5/13/2024 01:19:21' prior: 50599875 overrides: 50599885!
doOnRover: aMarsRovers 
	aMarsRovers rotateToRight ! !

!testRun: #MarsRoversTest #test20 stamp: 'I 5/13/2024 01:19:23'!
ERROR!

!testRun: #MarsRoversTest #test20 stamp: 'I 5/13/2024 01:19:23'!
ERROR!
!Object class methodsFor: 'instance creation' stamp: 'I 5/13/2024 01:20:01' prior: 50599845!
for: action 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	^(self subclasses detect: [:a | a asString = (action asString asUppercase)]) new .! !

!testRun: #MarsRoversTest #test20 stamp: 'I 5/13/2024 01:22:54'!
PASSED!

!testRun: #MarsRoversTest #test20 stamp: 'I 5/13/2024 01:23:06'!
PASSED!

!testRun: #MarsRoversTest #test01InitializeAndReturnsTheLocationOfTheRover stamp: 'I 5/13/2024 01:23:08'!
PASSED!

!testRun: #MarsRoversTest #test02ARoverIsPlacedOutOfTheReachOfWork stamp: 'I 5/13/2024 01:23:08'!
PASSED!

!testRun: #MarsRoversTest #test03ARoverPointingToNorthMoveForward stamp: 'I 5/13/2024 01:23:08'!
PASSED!

!testRun: #MarsRoversTest #test04RoverPointingToNorthMoveBackward stamp: 'I 5/13/2024 01:23:08'!
PASSED!

!testRun: #MarsRoversTest #test05RoverPointingSouthMoveForward stamp: 'I 5/13/2024 01:23:08'!
PASSED!

!testRun: #MarsRoversTest #test06RoverMoveForwardTwoTimes stamp: 'I 5/13/2024 01:23:08'!
PASSED!

!testRun: #MarsRoversTest #test07RoverPointingWestMoveForward stamp: 'I 5/13/2024 01:23:08'!
PASSED!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/13/2024 01:23:08'!
PASSED!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/13/2024 01:23:08'!
PASSED!

!testRun: #MarsRoversTest #test10 stamp: 'I 5/13/2024 01:23:08'!
PASSED!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/13/2024 01:23:08'!
FAILURE!

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRangeMovingNorth stamp: 'I 5/13/2024 01:23:08'!
PASSED!

!testRun: #MarsRoversTest #test13RoverOutOfRangeMovingForwardEast stamp: 'I 5/13/2024 01:23:08'!
PASSED!

!testRun: #MarsRoversTest #test14RoverOutOfRangeMovingForwardSouth stamp: 'I 5/13/2024 01:23:08'!
PASSED!

!testRun: #MarsRoversTest #test15RoverOutOfRangeMovingBackwardWest stamp: 'I 5/13/2024 01:23:08'!
PASSED!

!testRun: #MarsRoversTest #test16RoverOutOfRangeMovingBackwardEast stamp: 'I 5/13/2024 01:23:08'!
PASSED!

!testRun: #MarsRoversTest #test17RoverOutOfRangeMovingForwardWest stamp: 'I 5/13/2024 01:23:08'!
PASSED!

!testRun: #MarsRoversTest #test18RoverOutOfRangeMovingBackwardNort stamp: 'I 5/13/2024 01:23:08'!
PASSED!

!testRun: #MarsRoversTest #test19RoverOutOfRangeMovingBackwardSouth stamp: 'I 5/13/2024 01:23:08'!
PASSED!

!testRun: #MarsRoversTest #test20 stamp: 'I 5/13/2024 01:23:08'!
PASSED!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/13/2024 01:23:08'!
FAILURE!

----SNAPSHOT----(13 May 2024 01:23:24) CuisUniversity-6169.image priorSource: 8573738!

----SNAPSHOT----(13 May 2024 01:25:14) CuisUniversity-6169.image priorSource: 8586925!

----SNAPSHOT----(13 May 2024 01:25:37) CuisUniversity-6169.image priorSource: 8587013!

----QUIT----(13 May 2024 01:29:01) CuisUniversity-6169.image priorSource: 8587101!

----STARTUP---- (13 May 2024 22:15:04) as /home/ivan/Documents/Facu/Inge 1/linux64/linux64/CuisUniversity-6169.image!

!MarsRovers methodsFor: 'action' stamp: 'I 5/13/2024 22:27:24' prior: 50599703!
doAction: listOfAction
	! !

!classRemoval: #F stamp: 'I 5/13/2024 22:27:34'!
Actions subclass: #F
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!classRemoval: #B stamp: 'I 5/13/2024 22:27:34'!
Actions subclass: #B
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!classRemoval: #R stamp: 'I 5/13/2024 22:27:34'!
Actions subclass: #R
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!classRemoval: #L stamp: 'I 5/13/2024 22:27:35'!
Actions subclass: #L
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!classRemoval: #Actions stamp: 'I 5/13/2024 22:27:35'!
Object subclass: #Actions
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!methodRemoval: E #canMoveForward:inAreaOfWork: stamp: 'I 5/13/2024 22:27:43'!
canMoveForward: arg1 inAreaOfWork: arg2
	arg1 location x = arg2 x ifTrue: [ ^ arg1 class error: arg1 class outOfRangeOfWork ].
	^ self moveForward.!

!methodRemoval: E #canMoveBackward:inAreaOfWork: stamp: 'I 5/13/2024 22:27:46'!
canMoveBackward: aMarsRovers inAreaOfWork: aWorkingArea 
	(aMarsRovers location x = 0) ifTrue:[^self class error:aMarsRovers class negativeCoordinatesNotAllowed ].
	^self moveBackward !
!MarsRovers methodsFor: 'action' stamp: 'I 5/13/2024 22:28:03'!
process: sequenceOfCommands
	! !

!methodRemoval: MarsRovers #doAction: stamp: 'I 5/13/2024 22:28:07'!
doAction: listOfAction
	!

----STARTUP---- (15 May 2024 17:32:35) as /home/ivan/Documents/Facu/Inge 1/linux64/linux64/CuisUniversity-6169.image!

!MarsRovers methodsFor: 'action' stamp: 'I 5/13/2024 22:27:24' prior: 50599703!
doAction: listOfAction
	! !

!classRemoval: #F stamp: 'I 5/15/2024 17:32:48'!
Actions subclass: #F
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!classRemoval: #B stamp: 'I 5/15/2024 17:32:49'!
Actions subclass: #B
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!classRemoval: #R stamp: 'I 5/15/2024 17:32:49'!
Actions subclass: #R
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!classRemoval: #L stamp: 'I 5/15/2024 17:32:49'!
Actions subclass: #L
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!classRemoval: #Actions stamp: 'I 5/15/2024 17:32:50'!
Object subclass: #Actions
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!methodRemoval: E #canMoveForward:inAreaOfWork: stamp: 'I 5/15/2024 17:32:50'!
canMoveForward: arg1 inAreaOfWork: arg2
	arg1 location x = arg2 x ifTrue: [ ^ arg1 class error: arg1 class outOfRangeOfWork ].
	^ self moveForward.!

!methodRemoval: E #canMoveBackward:inAreaOfWork: stamp: 'I 5/15/2024 17:32:50'!
canMoveBackward: aMarsRovers inAreaOfWork: aWorkingArea 
	(aMarsRovers location x = 0) ifTrue:[^self class error:aMarsRovers class negativeCoordinatesNotAllowed ].
	^self moveBackward !
!MarsRovers methodsFor: 'action' stamp: 'I 5/13/2024 22:28:03'!
process: sequenceOfCommands
	! !

!methodRemoval: MarsRovers #doAction: stamp: 'I 5/15/2024 17:32:50'!
doAction: listOfAction
	!
!MarsRovers methodsFor: 'action' stamp: 'I 5/15/2024 17:53:33' prior: 50600110!
process: sequenceOfCommands
	sequenceOfCommands do:[:command | self processComand: command].! !

!testRun: #MarsRoversTest #test01InitializeAndReturnsTheLocationOfTheRover stamp: 'I 5/15/2024 17:53:36'!
PASSED!

!testRun: #MarsRoversTest #test02ARoverIsPlacedOutOfTheReachOfWork stamp: 'I 5/15/2024 17:53:36'!
PASSED!

!testRun: #MarsRoversTest #test03ARoverPointingToNorthMoveForward stamp: 'I 5/15/2024 17:53:36'!
PASSED!

!testRun: #MarsRoversTest #test04RoverPointingToNorthMoveBackward stamp: 'I 5/15/2024 17:53:36'!
PASSED!

!testRun: #MarsRoversTest #test05RoverPointingSouthMoveForward stamp: 'I 5/15/2024 17:53:36'!
PASSED!

!testRun: #MarsRoversTest #test06RoverMoveForwardTwoTimes stamp: 'I 5/15/2024 17:53:36'!
PASSED!

!testRun: #MarsRoversTest #test07RoverPointingWestMoveForward stamp: 'I 5/15/2024 17:53:36'!
PASSED!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/15/2024 17:53:36'!
PASSED!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/15/2024 17:53:36'!
PASSED!

!testRun: #MarsRoversTest #test10 stamp: 'I 5/15/2024 17:53:36'!
PASSED!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/15/2024 17:53:36'!
ERROR!

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRangeMovingNorth stamp: 'I 5/15/2024 17:53:36'!
PASSED!

!testRun: #MarsRoversTest #test13RoverOutOfRangeMovingForwardEast stamp: 'I 5/15/2024 17:53:36'!
FAILURE!

!testRun: #MarsRoversTest #test14RoverOutOfRangeMovingForwardSouth stamp: 'I 5/15/2024 17:53:36'!
PASSED!

!testRun: #MarsRoversTest #test15RoverOutOfRangeMovingBackwardWest stamp: 'I 5/15/2024 17:53:36'!
PASSED!

!testRun: #MarsRoversTest #test16RoverOutOfRangeMovingBackwardEast stamp: 'I 5/15/2024 17:53:36'!
ERROR!

!testRun: #MarsRoversTest #test17RoverOutOfRangeMovingForwardWest stamp: 'I 5/15/2024 17:53:36'!
PASSED!

!testRun: #MarsRoversTest #test18RoverOutOfRangeMovingBackwardNort stamp: 'I 5/15/2024 17:53:36'!
PASSED!

!testRun: #MarsRoversTest #test19RoverOutOfRangeMovingBackwardSouth stamp: 'I 5/15/2024 17:53:36'!
PASSED!

!testRun: #MarsRoversTest #test20 stamp: 'I 5/15/2024 17:53:36'!
ERROR!
!MarsRoversTest methodsFor: 'as yet unclassified' stamp: 'I 5/15/2024 18:01:54' prior: 50599776!
test20
	| rover starting |
	starting := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: starting
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover process: 'brf'.	
	self
		assert: 'N'
		equals: rover cardinalLocation.
	self
		assert:
			(Point
				x: 2
				y: 3)
		equals: rover location.! !
!MarsRoversTest methodsFor: 'as yet unclassified' stamp: 'I 5/15/2024 18:01:54' prior: 50599677!
test11
	| rover startingPoint |
	startingPoint := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: startingPoint
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover process: 'brf'.
	self
		assert: 'O'
		equals: rover cardinalLocation.
	self
		assert:
			(Point
				x: 2
				y: 3)
		equals: rover location.! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/15/2024 18:02:29' prior: 50600792!
test07RoverPointingWestMoveForward
	| rover temp2 |
	temp2 := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: temp2
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover moveForward.
	self
		assert:
			(Point
				x: 0
				y: 2)
		equals: rover location.! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/15/2024 18:02:35' prior: 50600214!
test07RoverPointingWestMoveForward
	| rover initial |
	initial := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: initial
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover moveForward.
	self
		assert:
			(Point
				x: 0
				y: 2)
		equals: rover location.! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/15/2024 18:02:56' prior: 50598652!
test08RoverPointingWestMoveBackward
	| rover startingPoint |
	startingPoint := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: startingPoint
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover process: 'b'.
	self
		assert:
			(Point
				x: 2
				y: 2)
		equals: rover location.! !

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/15/2024 18:02:59'!
ERROR!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/15/2024 18:03:04'!
ERROR!
!MarsRovers methodsFor: 'action' stamp: 'I 5/15/2024 18:03:10'!
processComand: command 
	self shouldBeImplemented.! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/15/2024 18:04:12' prior: 50600257!
processComand: command 
	(command = 'f') ifTrue: [self moveForward ].
	(command = 'b') ifTrue: [self moveBackward ].
	(command = 'r') ifTrue: [self rotateToRight ].
	(command = 'l') ifTrue: [self rotateToLeft ].! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/15/2024 18:04:36' prior: 50600262!
processComand: command 
	(command = 'f') ifTrue: [self moveForward ].
	(command = 'b') ifTrue: [self moveBackward ].
	(command = 'r') ifTrue: [self rotateToRight ].
	(command = 'l') ifTrue: [self rotateToLeft ].
	self class error: self class invalidCommand.! !

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/15/2024 18:04:41'!
ERROR!
!MarsRovers class methodsFor: 'error' stamp: 'I 5/15/2024 18:04:57'!
invalidCommand
	self shouldBeImplemented.! !
!MarsRovers class methodsFor: 'error' stamp: 'I 5/15/2024 18:05:17' prior: 50600286!
invalidCommand
	^'Invalid command passed'! !

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/15/2024 18:05:20'!
ERROR!
!MarsRovers methodsFor: 'action' stamp: 'I 5/15/2024 18:06:08' prior: 50600272!
processComand: command 
	(command = $f) ifTrue: [self moveForward ].
	(command = $b) ifTrue: [self moveBackward ].
	(command = $r) ifTrue: [self rotateToRight ].
	(command = $l) ifTrue: [self rotateToLeft ].
	self class error: self class invalidCommand.! !

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/15/2024 18:06:11'!
ERROR!
!MarsRovers methodsFor: 'action' stamp: 'I 5/15/2024 18:08:37' prior: 50600299!
processComand: command 
	(command = $f) ifTrue: [^self moveForward ].
	(command = $b) ifTrue: [^self moveBackward ].
	(command = $r) ifTrue: [^self rotateToRight ].
	(command = $l) ifTrue: [^self rotateToLeft ].
	self class error: self class invalidCommand.! !

----STARTUP---- (15 May 2024 18:11:57) as /home/ivan/Documents/Facu/Inge 1/linux64/linux64/CuisUniversity-6169.image!

!MarsRovers methodsFor: 'action' stamp: 'I 5/13/2024 22:27:24' prior: 50599703!
doAction: listOfAction
	! !

!classRemoval: #F stamp: 'I 5/15/2024 18:12:00'!
Actions subclass: #F
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!classRemoval: #B stamp: 'I 5/15/2024 18:12:00'!
Actions subclass: #B
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!classRemoval: #R stamp: 'I 5/15/2024 18:12:01'!
Actions subclass: #R
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!classRemoval: #L stamp: 'I 5/15/2024 18:12:01'!
Actions subclass: #L
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!classRemoval: #Actions stamp: 'I 5/15/2024 18:12:01'!
Object subclass: #Actions
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!methodRemoval: E #canMoveForward:inAreaOfWork: stamp: 'I 5/15/2024 18:12:01'!
canMoveForward: arg1 inAreaOfWork: arg2
	arg1 location x = arg2 x ifTrue: [ ^ arg1 class error: arg1 class outOfRangeOfWork ].
	^ self moveForward.!

!methodRemoval: E #canMoveBackward:inAreaOfWork: stamp: 'I 5/15/2024 18:12:01'!
canMoveBackward: aMarsRovers inAreaOfWork: aWorkingArea 
	(aMarsRovers location x = 0) ifTrue:[^self class error:aMarsRovers class negativeCoordinatesNotAllowed ].
	^self moveBackward !
!MarsRovers methodsFor: 'action' stamp: 'I 5/13/2024 22:28:03'!
process: sequenceOfCommands
	! !

!methodRemoval: MarsRovers #doAction: stamp: 'I 5/15/2024 18:12:01'!
doAction: listOfAction
	!
!MarsRovers methodsFor: 'action' stamp: 'I 5/13/2024 22:27:24'!
doAction: listOfAction
	! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/13/2024 22:28:03' prior: 50600374!
process: sequenceOfCommands
	! !

!methodRemoval: MarsRovers #doAction: stamp: 'I 5/15/2024 18:12:01'!
doAction: listOfAction
	!
!MarsRovers methodsFor: 'action' stamp: 'I 5/15/2024 17:53:33' prior: 50600385!
process: sequenceOfCommands
	sequenceOfCommands do:[:command | self processComand: command].! !
!MarsRoversTest methodsFor: 'as yet unclassified' stamp: 'I 5/15/2024 18:01:54' prior: 50599776!
test20
	| rover starting |
	starting := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: starting
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover process: 'brf'.	
	self
		assert: 'N'
		equals: rover cardinalLocation.
	self
		assert:
			(Point
				x: 2
				y: 3)
		equals: rover location.! !
!MarsRoversTest methodsFor: 'as yet unclassified' stamp: 'I 5/15/2024 18:01:54' prior: 50599677!
test11
	| rover startingPoint |
	startingPoint := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: startingPoint
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover process: 'brf'.
	self
		assert: 'O'
		equals: rover cardinalLocation.
	self
		assert:
			(Point
				x: 2
				y: 3)
		equals: rover location.! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/15/2024 18:02:29' prior: 50600792!
test07RoverPointingWestMoveForward
	| rover temp2 |
	temp2 := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: temp2
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover moveForward.
	self
		assert:
			(Point
				x: 0
				y: 2)
		equals: rover location.! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/15/2024 18:02:35' prior: 50600427!
test07RoverPointingWestMoveForward
	| rover initial |
	initial := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: initial
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover moveForward.
	self
		assert:
			(Point
				x: 0
				y: 2)
		equals: rover location.! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/15/2024 18:02:56' prior: 50598652!
test08RoverPointingWestMoveBackward
	| rover startingPoint |
	startingPoint := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: startingPoint
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover process: 'b'.
	self
		assert:
			(Point
				x: 2
				y: 2)
		equals: rover location.! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/15/2024 18:03:10'!
processComand: command 
	self shouldBeImplemented.! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/15/2024 18:04:12' prior: 50600463!
processComand: command 
	(command = 'f') ifTrue: [self moveForward ].
	(command = 'b') ifTrue: [self moveBackward ].
	(command = 'r') ifTrue: [self rotateToRight ].
	(command = 'l') ifTrue: [self rotateToLeft ].! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/15/2024 18:04:36' prior: 50600468!
processComand: command 
	(command = 'f') ifTrue: [self moveForward ].
	(command = 'b') ifTrue: [self moveBackward ].
	(command = 'r') ifTrue: [self rotateToRight ].
	(command = 'l') ifTrue: [self rotateToLeft ].
	self class error: self class invalidCommand.! !
!MarsRovers class methodsFor: 'error' stamp: 'I 5/15/2024 18:04:57'!
invalidCommand
	self shouldBeImplemented.! !
!MarsRovers class methodsFor: 'error' stamp: 'I 5/15/2024 18:05:17' prior: 50600489!
invalidCommand
	^'Invalid command passed'! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/15/2024 18:06:08' prior: 50600478!
processComand: command 
	(command = $f) ifTrue: [self moveForward ].
	(command = $b) ifTrue: [self moveBackward ].
	(command = $r) ifTrue: [self rotateToRight ].
	(command = $l) ifTrue: [self rotateToLeft ].
	self class error: self class invalidCommand.! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/15/2024 18:08:37' prior: 50600498!
processComand: command 
	(command = $f) ifTrue: [^self moveForward ].
	(command = $b) ifTrue: [^self moveBackward ].
	(command = $r) ifTrue: [^self rotateToRight ].
	(command = $l) ifTrue: [^self rotateToLeft ].
	self class error: self class invalidCommand.! !

----STARTUP---- (15 May 2024 18:19:54) as /home/ivan/Documents/Facu/Inge 1/linux64/linux64/CuisUniversity-6169.image!

!MarsRovers methodsFor: 'action' stamp: 'I 5/13/2024 22:27:24' prior: 50599703!
doAction: listOfAction
	! !

!classRemoval: #F stamp: 'I 5/15/2024 18:19:57'!
Actions subclass: #F
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!classRemoval: #B stamp: 'I 5/15/2024 18:19:57'!
Actions subclass: #B
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!classRemoval: #R stamp: 'I 5/15/2024 18:19:58'!
Actions subclass: #R
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!classRemoval: #L stamp: 'I 5/15/2024 18:19:58'!
Actions subclass: #L
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!classRemoval: #Actions stamp: 'I 5/15/2024 18:19:58'!
Object subclass: #Actions
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!methodRemoval: E #canMoveForward:inAreaOfWork: stamp: 'I 5/15/2024 18:19:58'!
canMoveForward: arg1 inAreaOfWork: arg2
	arg1 location x = arg2 x ifTrue: [ ^ arg1 class error: arg1 class outOfRangeOfWork ].
	^ self moveForward.!

!methodRemoval: E #canMoveBackward:inAreaOfWork: stamp: 'I 5/15/2024 18:19:58'!
canMoveBackward: aMarsRovers inAreaOfWork: aWorkingArea 
	(aMarsRovers location x = 0) ifTrue:[^self class error:aMarsRovers class negativeCoordinatesNotAllowed ].
	^self moveBackward !
!MarsRovers methodsFor: 'action' stamp: 'I 5/13/2024 22:28:03'!
process: sequenceOfCommands
	! !

!methodRemoval: MarsRovers #doAction: stamp: 'I 5/15/2024 18:19:58'!
doAction: listOfAction
	!
!MarsRovers methodsFor: 'action' stamp: 'I 5/13/2024 22:27:24'!
doAction: listOfAction
	! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/13/2024 22:28:03' prior: 50600570!
process: sequenceOfCommands
	! !

!methodRemoval: MarsRovers #doAction: stamp: 'I 5/15/2024 18:19:58'!
doAction: listOfAction
	!
!MarsRovers methodsFor: 'action' stamp: 'I 5/15/2024 17:53:33' prior: 50600581!
process: sequenceOfCommands
	sequenceOfCommands do:[:command | self processComand: command].! !
!MarsRoversTest methodsFor: 'as yet unclassified' stamp: 'I 5/15/2024 18:01:54' prior: 50599776!
test20
	| rover starting |
	starting := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: starting
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover process: 'brf'.	
	self
		assert: 'N'
		equals: rover cardinalLocation.
	self
		assert:
			(Point
				x: 2
				y: 3)
		equals: rover location.! !
!MarsRoversTest methodsFor: 'as yet unclassified' stamp: 'I 5/15/2024 18:01:54' prior: 50599677!
test11
	| rover startingPoint |
	startingPoint := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: startingPoint
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover process: 'brf'.
	self
		assert: 'O'
		equals: rover cardinalLocation.
	self
		assert:
			(Point
				x: 2
				y: 3)
		equals: rover location.! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/15/2024 18:02:29' prior: 50600792!
test07RoverPointingWestMoveForward
	| rover temp2 |
	temp2 := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: temp2
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover moveForward.
	self
		assert:
			(Point
				x: 0
				y: 2)
		equals: rover location.! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/15/2024 18:02:35' prior: 50600623!
test07RoverPointingWestMoveForward
	| rover initial |
	initial := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: initial
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover moveForward.
	self
		assert:
			(Point
				x: 0
				y: 2)
		equals: rover location.! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/15/2024 18:02:56' prior: 50598652!
test08RoverPointingWestMoveBackward
	| rover startingPoint |
	startingPoint := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: startingPoint
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover process: 'b'.
	self
		assert:
			(Point
				x: 2
				y: 2)
		equals: rover location.! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/15/2024 18:03:10'!
processComand: command 
	self shouldBeImplemented.! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/15/2024 18:04:12' prior: 50600659!
processComand: command 
	(command = 'f') ifTrue: [self moveForward ].
	(command = 'b') ifTrue: [self moveBackward ].
	(command = 'r') ifTrue: [self rotateToRight ].
	(command = 'l') ifTrue: [self rotateToLeft ].! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/15/2024 18:04:36' prior: 50600664!
processComand: command 
	(command = 'f') ifTrue: [self moveForward ].
	(command = 'b') ifTrue: [self moveBackward ].
	(command = 'r') ifTrue: [self rotateToRight ].
	(command = 'l') ifTrue: [self rotateToLeft ].
	self class error: self class invalidCommand.! !
!MarsRovers class methodsFor: 'error' stamp: 'I 5/15/2024 18:04:57'!
invalidCommand
	self shouldBeImplemented.! !
!MarsRovers class methodsFor: 'error' stamp: 'I 5/15/2024 18:05:17' prior: 50600685!
invalidCommand
	^'Invalid command passed'! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/15/2024 18:06:08' prior: 50600674!
processComand: command 
	(command = $f) ifTrue: [self moveForward ].
	(command = $b) ifTrue: [self moveBackward ].
	(command = $r) ifTrue: [self rotateToRight ].
	(command = $l) ifTrue: [self rotateToLeft ].
	self class error: self class invalidCommand.! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/15/2024 18:08:37' prior: 50600694!
processComand: command 
	(command = $f) ifTrue: [^self moveForward ].
	(command = $b) ifTrue: [^self moveBackward ].
	(command = $r) ifTrue: [^self rotateToRight ].
	(command = $l) ifTrue: [^self rotateToLeft ].
	self class error: self class invalidCommand.! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/13/2024 22:27:24'!
doAction: listOfAction
	! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/13/2024 22:28:03' prior: 50600588!
process: sequenceOfCommands
	! !

!methodRemoval: MarsRovers #doAction: stamp: 'I 5/15/2024 18:19:59'!
doAction: listOfAction
	!
!MarsRovers methodsFor: 'action' stamp: 'I 5/13/2024 22:27:24'!
doAction: listOfAction
	! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/13/2024 22:28:03' prior: 50600720!
process: sequenceOfCommands
	! !

!methodRemoval: MarsRovers #doAction: stamp: 'I 5/15/2024 18:19:59'!
doAction: listOfAction
	!
!MarsRovers methodsFor: 'action' stamp: 'I 5/15/2024 17:53:33' prior: 50600731!
process: sequenceOfCommands
	sequenceOfCommands do:[:command | self processComand: command].! !
!MarsRoversTest methodsFor: 'as yet unclassified' stamp: 'I 5/15/2024 18:01:54' prior: 50600595!
test20
	| rover starting |
	starting := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: starting
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover process: 'brf'.	
	self
		assert: 'N'
		equals: rover cardinalLocation.
	self
		assert:
			(Point
				x: 2
				y: 3)
		equals: rover location.! !
!MarsRoversTest methodsFor: 'as yet unclassified' stamp: 'I 5/15/2024 18:01:54' prior: 50600609!
test11
	| rover startingPoint |
	startingPoint := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: startingPoint
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover process: 'brf'.
	self
		assert: 'O'
		equals: rover cardinalLocation.
	self
		assert:
			(Point
				x: 2
				y: 3)
		equals: rover location.! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/15/2024 18:02:29' prior: 50600635!
test07RoverPointingWestMoveForward
	| rover temp2 |
	temp2 := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: temp2
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover moveForward.
	self
		assert:
			(Point
				x: 0
				y: 2)
		equals: rover location.! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/15/2024 18:02:35' prior: 50600773!
test07RoverPointingWestMoveForward
	| rover initial |
	initial := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: initial
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover moveForward.
	self
		assert:
			(Point
				x: 0
				y: 2)
		equals: rover location.! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/15/2024 18:02:56' prior: 50600647!
test08RoverPointingWestMoveBackward
	| rover startingPoint |
	startingPoint := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: startingPoint
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover process: 'b'.
	self
		assert:
			(Point
				x: 2
				y: 2)
		equals: rover location.! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/15/2024 18:03:10' prior: 50600705!
processComand: command 
	self shouldBeImplemented.! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/15/2024 18:04:12' prior: 50600810!
processComand: command 
	(command = 'f') ifTrue: [self moveForward ].
	(command = 'b') ifTrue: [self moveBackward ].
	(command = 'r') ifTrue: [self rotateToRight ].
	(command = 'l') ifTrue: [self rotateToLeft ].! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/15/2024 18:04:36' prior: 50600815!
processComand: command 
	(command = 'f') ifTrue: [self moveForward ].
	(command = 'b') ifTrue: [self moveBackward ].
	(command = 'r') ifTrue: [self rotateToRight ].
	(command = 'l') ifTrue: [self rotateToLeft ].
	self class error: self class invalidCommand.! !
!MarsRovers class methodsFor: 'error' stamp: 'I 5/15/2024 18:04:57' prior: 50600690!
invalidCommand
	self shouldBeImplemented.! !
!MarsRovers class methodsFor: 'error' stamp: 'I 5/15/2024 18:05:17' prior: 50600836!
invalidCommand
	^'Invalid command passed'! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/15/2024 18:06:08' prior: 50600825!
processComand: command 
	(command = $f) ifTrue: [self moveForward ].
	(command = $b) ifTrue: [self moveBackward ].
	(command = $r) ifTrue: [self rotateToRight ].
	(command = $l) ifTrue: [self rotateToLeft ].
	self class error: self class invalidCommand.! !
!MarsRovers methodsFor: 'action' stamp: 'I 5/15/2024 18:08:37' prior: 50600845!
processComand: command 
	(command = $f) ifTrue: [^self moveForward ].
	(command = $b) ifTrue: [^self moveBackward ].
	(command = $r) ifTrue: [^self rotateToRight ].
	(command = $l) ifTrue: [^self rotateToLeft ].
	self class error: self class invalidCommand.! !
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/15/2024 18:20:54' prior: 50600797!
test08RoverPointingWestMoveBackward
	| rover startingPoint |
	startingPoint := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: startingPoint
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover process: 'b'.
	self
		assert:(rover isLocatedAt: (2@2)).! !

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/15/2024 18:20:56'!
ERROR!
!MarsRovers methodsFor: 'value' stamp: 'I 5/15/2024 18:21:06'!
isLocatedAt: aRenameMe1 
	self shouldBeImplemented.! !
!MarsRovers methodsFor: 'value' stamp: 'I 5/15/2024 18:21:25' prior: 50600881!
isLocatedAt: positionToVerify
	positionToVerify = locationPoint .! !

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/15/2024 18:21:30'!
ERROR!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/15/2024 18:21:39'!
ERROR!
!MarsRovers methodsFor: 'value' stamp: 'I 5/15/2024 18:22:43' prior: 50600886!
isLocatedAt: positionToVerify
	^positionToVerify = locationPoint .! !

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/15/2024 18:22:52'!
PASSED!

!testRun: #MarsRoversTest #test01InitializeAndReturnsTheLocationOfTheRover stamp: 'I 5/15/2024 18:22:52'!
PASSED!

!testRun: #MarsRoversTest #test02ARoverIsPlacedOutOfTheReachOfWork stamp: 'I 5/15/2024 18:22:52'!
PASSED!

!testRun: #MarsRoversTest #test03ARoverPointingToNorthMoveForward stamp: 'I 5/15/2024 18:22:52'!
PASSED!

!testRun: #MarsRoversTest #test04RoverPointingToNorthMoveBackward stamp: 'I 5/15/2024 18:22:52'!
PASSED!

!testRun: #MarsRoversTest #test05RoverPointingSouthMoveForward stamp: 'I 5/15/2024 18:22:52'!
PASSED!

!testRun: #MarsRoversTest #test06RoverMoveForwardTwoTimes stamp: 'I 5/15/2024 18:22:52'!
PASSED!

!testRun: #MarsRoversTest #test07RoverPointingWestMoveForward stamp: 'I 5/15/2024 18:22:52'!
PASSED!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/15/2024 18:22:52'!
PASSED!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/15/2024 18:22:52'!
PASSED!

!testRun: #MarsRoversTest #test10 stamp: 'I 5/15/2024 18:22:52'!
PASSED!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/15/2024 18:22:52'!
FAILURE!

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRangeMovingNorth stamp: 'I 5/15/2024 18:22:52'!
PASSED!

!testRun: #MarsRoversTest #test13RoverOutOfRangeMovingForwardEast stamp: 'I 5/15/2024 18:22:52'!
FAILURE!

!testRun: #MarsRoversTest #test14RoverOutOfRangeMovingForwardSouth stamp: 'I 5/15/2024 18:22:52'!
PASSED!

!testRun: #MarsRoversTest #test15RoverOutOfRangeMovingBackwardWest stamp: 'I 5/15/2024 18:22:52'!
PASSED!

!testRun: #MarsRoversTest #test16RoverOutOfRangeMovingBackwardEast stamp: 'I 5/15/2024 18:22:52'!
ERROR!

!testRun: #MarsRoversTest #test17RoverOutOfRangeMovingForwardWest stamp: 'I 5/15/2024 18:22:52'!
PASSED!

!testRun: #MarsRoversTest #test18RoverOutOfRangeMovingBackwardNort stamp: 'I 5/15/2024 18:22:52'!
PASSED!

!testRun: #MarsRoversTest #test19RoverOutOfRangeMovingBackwardSouth stamp: 'I 5/15/2024 18:22:52'!
PASSED!

!testRun: #MarsRoversTest #test20 stamp: 'I 5/15/2024 18:22:52'!
PASSED!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/15/2024 18:22:56'!
PASSED!

!testRun: #MarsRoversTest #test01InitializeAndReturnsTheLocationOfTheRover stamp: 'I 5/15/2024 18:22:56'!
PASSED!

!testRun: #MarsRoversTest #test02ARoverIsPlacedOutOfTheReachOfWork stamp: 'I 5/15/2024 18:22:56'!
PASSED!

!testRun: #MarsRoversTest #test03ARoverPointingToNorthMoveForward stamp: 'I 5/15/2024 18:22:56'!
PASSED!

!testRun: #MarsRoversTest #test04RoverPointingToNorthMoveBackward stamp: 'I 5/15/2024 18:22:56'!
PASSED!

!testRun: #MarsRoversTest #test05RoverPointingSouthMoveForward stamp: 'I 5/15/2024 18:22:56'!
PASSED!

!testRun: #MarsRoversTest #test06RoverMoveForwardTwoTimes stamp: 'I 5/15/2024 18:22:56'!
PASSED!

!testRun: #MarsRoversTest #test07RoverPointingWestMoveForward stamp: 'I 5/15/2024 18:22:56'!
PASSED!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/15/2024 18:22:56'!
PASSED!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/15/2024 18:22:56'!
PASSED!

!testRun: #MarsRoversTest #test10 stamp: 'I 5/15/2024 18:22:56'!
PASSED!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/15/2024 18:22:56'!
FAILURE!

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRangeMovingNorth stamp: 'I 5/15/2024 18:22:56'!
PASSED!

!testRun: #MarsRoversTest #test13RoverOutOfRangeMovingForwardEast stamp: 'I 5/15/2024 18:22:56'!
FAILURE!

!testRun: #MarsRoversTest #test14RoverOutOfRangeMovingForwardSouth stamp: 'I 5/15/2024 18:22:56'!
PASSED!

!testRun: #MarsRoversTest #test15RoverOutOfRangeMovingBackwardWest stamp: 'I 5/15/2024 18:22:56'!
PASSED!

!testRun: #MarsRoversTest #test16RoverOutOfRangeMovingBackwardEast stamp: 'I 5/15/2024 18:22:56'!
ERROR!

!testRun: #MarsRoversTest #test17RoverOutOfRangeMovingForwardWest stamp: 'I 5/15/2024 18:22:56'!
PASSED!

!testRun: #MarsRoversTest #test18RoverOutOfRangeMovingBackwardNort stamp: 'I 5/15/2024 18:22:56'!
PASSED!

!testRun: #MarsRoversTest #test19RoverOutOfRangeMovingBackwardSouth stamp: 'I 5/15/2024 18:22:56'!
PASSED!

!testRun: #MarsRoversTest #test20 stamp: 'I 5/15/2024 18:22:56'!
PASSED!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/15/2024 18:23:44' prior: 50600759!
test11
	| rover startingPoint |
	startingPoint := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: startingPoint
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover process: 'brf'.
	self
		assert: (rover cardinalPointing: 'O') .
	self
		assert:(rover isLocatedAt: (2@3))
		! !

!testRun: #MarsRoversTest #test11 stamp: 'I 5/15/2024 18:23:46'!
ERROR!
!MarsRovers methodsFor: 'value' stamp: 'I 5/15/2024 18:23:55'!
cardinalPointing: aRenameMe1 
	self shouldBeImplemented.! !
!MarsRovers methodsFor: 'value' stamp: 'I 5/15/2024 18:24:18' prior: 50601047!
cardinalPointing: headingPosition
	^headingPosition = cardinalPoint ! !

!testRun: #MarsRoversTest #test11 stamp: 'I 5/15/2024 18:24:21'!
FAILURE!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/15/2024 18:24:34' prior: 50601033!
test11
	| rover startingPoint |
	startingPoint := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: startingPoint
		pointingTo: 'O'
		inWorkingArea:
			(Point
				x: 4
				y: 4).
	rover process: 'brf'.
	self
		assert: (rover cardinalPointing: 'N') .
	self
		assert:(rover isLocatedAt: (2@3))
		! !

!testRun: #MarsRoversTest #test11 stamp: 'I 5/15/2024 18:24:35'!
FAILURE!
!MarsRovers methodsFor: 'value' stamp: 'I 5/15/2024 18:25:14' prior: 50601052!
cardinalPointing: headingPosition
	^headingPosition = (cardinalPoint class asString)! !

!testRun: #MarsRoversTest #test11 stamp: 'I 5/15/2024 18:25:17'!
PASSED!

!testRun: #MarsRoversTest #test01InitializeAndReturnsTheLocationOfTheRover stamp: 'I 5/15/2024 18:25:17'!
PASSED!

!testRun: #MarsRoversTest #test02ARoverIsPlacedOutOfTheReachOfWork stamp: 'I 5/15/2024 18:25:17'!
PASSED!

!testRun: #MarsRoversTest #test03ARoverPointingToNorthMoveForward stamp: 'I 5/15/2024 18:25:17'!
PASSED!

!testRun: #MarsRoversTest #test04RoverPointingToNorthMoveBackward stamp: 'I 5/15/2024 18:25:17'!
PASSED!

!testRun: #MarsRoversTest #test05RoverPointingSouthMoveForward stamp: 'I 5/15/2024 18:25:17'!
PASSED!

!testRun: #MarsRoversTest #test06RoverMoveForwardTwoTimes stamp: 'I 5/15/2024 18:25:17'!
PASSED!

!testRun: #MarsRoversTest #test07RoverPointingWestMoveForward stamp: 'I 5/15/2024 18:25:17'!
PASSED!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/15/2024 18:25:17'!
PASSED!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/15/2024 18:25:17'!
PASSED!

!testRun: #MarsRoversTest #test10 stamp: 'I 5/15/2024 18:25:17'!
PASSED!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/15/2024 18:25:17'!
PASSED!

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRangeMovingNorth stamp: 'I 5/15/2024 18:25:17'!
PASSED!

!testRun: #MarsRoversTest #test13RoverOutOfRangeMovingForwardEast stamp: 'I 5/15/2024 18:25:17'!
FAILURE!

!testRun: #MarsRoversTest #test14RoverOutOfRangeMovingForwardSouth stamp: 'I 5/15/2024 18:25:17'!
PASSED!

!testRun: #MarsRoversTest #test15RoverOutOfRangeMovingBackwardWest stamp: 'I 5/15/2024 18:25:17'!
PASSED!

!testRun: #MarsRoversTest #test16RoverOutOfRangeMovingBackwardEast stamp: 'I 5/15/2024 18:25:17'!
ERROR!

!testRun: #MarsRoversTest #test17RoverOutOfRangeMovingForwardWest stamp: 'I 5/15/2024 18:25:17'!
PASSED!

!testRun: #MarsRoversTest #test18RoverOutOfRangeMovingBackwardNort stamp: 'I 5/15/2024 18:25:17'!
PASSED!

!testRun: #MarsRoversTest #test19RoverOutOfRangeMovingBackwardSouth stamp: 'I 5/15/2024 18:25:17'!
PASSED!

!testRun: #MarsRoversTest #test20 stamp: 'I 5/15/2024 18:25:17'!
PASSED!

!testRun: #MarsRoversTest #test01InitializeAndReturnsTheLocationOfTheRover stamp: 'I 5/15/2024 18:25:35'!
PASSED!

!testRun: #MarsRoversTest #test01InitializeAndReturnsTheLocationOfTheRover stamp: 'I 5/15/2024 18:25:35'!
PASSED!

!testRun: #MarsRoversTest #test02ARoverIsPlacedOutOfTheReachOfWork stamp: 'I 5/15/2024 18:25:35'!
PASSED!

!testRun: #MarsRoversTest #test03ARoverPointingToNorthMoveForward stamp: 'I 5/15/2024 18:25:35'!
PASSED!

!testRun: #MarsRoversTest #test04RoverPointingToNorthMoveBackward stamp: 'I 5/15/2024 18:25:35'!
PASSED!

!testRun: #MarsRoversTest #test05RoverPointingSouthMoveForward stamp: 'I 5/15/2024 18:25:35'!
PASSED!

!testRun: #MarsRoversTest #test06RoverMoveForwardTwoTimes stamp: 'I 5/15/2024 18:25:35'!
PASSED!

!testRun: #MarsRoversTest #test07RoverPointingWestMoveForward stamp: 'I 5/15/2024 18:25:35'!
PASSED!

!testRun: #MarsRoversTest #test08RoverPointingWestMoveBackward stamp: 'I 5/15/2024 18:25:35'!
PASSED!

!testRun: #MarsRoversTest #test09 stamp: 'I 5/15/2024 18:25:35'!
PASSED!

!testRun: #MarsRoversTest #test10 stamp: 'I 5/15/2024 18:25:35'!
PASSED!

!testRun: #MarsRoversTest #test11 stamp: 'I 5/15/2024 18:25:35'!
PASSED!

!testRun: #MarsRoversTest #test12ARoverMoveOutOfRangeMovingNorth stamp: 'I 5/15/2024 18:25:35'!
PASSED!

!testRun: #MarsRoversTest #test13RoverOutOfRangeMovingForwardEast stamp: 'I 5/15/2024 18:25:35'!
FAILURE!

!testRun: #MarsRoversTest #test14RoverOutOfRangeMovingForwardSouth stamp: 'I 5/15/2024 18:25:35'!
PASSED!

!testRun: #MarsRoversTest #test15RoverOutOfRangeMovingBackwardWest stamp: 'I 5/15/2024 18:25:35'!
PASSED!

!testRun: #MarsRoversTest #test16RoverOutOfRangeMovingBackwardEast stamp: 'I 5/15/2024 18:25:35'!
ERROR!

!testRun: #MarsRoversTest #test17RoverOutOfRangeMovingForwardWest stamp: 'I 5/15/2024 18:25:35'!
PASSED!

!testRun: #MarsRoversTest #test18RoverOutOfRangeMovingBackwardNort stamp: 'I 5/15/2024 18:25:35'!
PASSED!

!testRun: #MarsRoversTest #test19RoverOutOfRangeMovingBackwardSouth stamp: 'I 5/15/2024 18:25:35'!
PASSED!

!testRun: #MarsRoversTest #test20 stamp: 'I 5/15/2024 18:25:35'!
PASSED!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/15/2024 18:36:22' prior: 50600651!
test01InitializeAndReturnsTheLocationOfTheRover
		|rover|
		
		rover initializeLocationAt: (2@2) pointingTo: 'O' 		.
	self
		assert: (rover isLocatedAt: 2@2).! !
!MarsRovers class methodsFor: 'instance creation' stamp: 'I 5/15/2024 18:38:14'!
locationAt: startingLocation pointingTo: headingTo 
	^ self new
		initializeLocationAt: startingLocation
		pointingTo: headingTo.! !

!methodRemoval: MarsRovers class #locationAt:pointingTo:inWorkingArea: stamp: 'I 5/15/2024 18:38:25'!
locationAt: arg1 pointingTo: arg2 inWorkingArea: arg3
	(arg1 x negative or: [ arg1 y negative ]) ifTrue: [ self error: self negativeCoordinatesNotAllowed ].
	(arg1 x <= arg3 x and: [ arg1 y <= arg3 y ]) ifFalse: [ self error: self outOfRangeOfWork ].
	^ self new
		initializeLocationAt: arg1
		pointingTo: arg2
		inWorkingArea: arg3.!
!MarsRovers methodsFor: 'initialization' stamp: 'I 5/15/2024 18:39:03'!
initializeLocationAt: startingPoint pointingTo: headingTo 
	locationPoint := startingPoint.
	cardinalPoint := CardinalRule stateFor: headingTo.! !

Object subclass: #MarsRovers
	instanceVariableNames: 'locationPoint cardinalPoint '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rovers'!

!methodRemoval: MarsRoversTest #test14RoverOutOfRangeMovingForwardSouth stamp: 'I 5/15/2024 18:39:35'!
test14RoverOutOfRangeMovingForwardSouth
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 4 y:0.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'S' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveForward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Coordenadas negativas no son validas' ]!

!methodRemoval: MarsRoversTest #test15RoverOutOfRangeMovingBackwardWest stamp: 'I 5/15/2024 18:39:36'!
test15RoverOutOfRangeMovingBackwardWest
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 4 y:3.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'O' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveBackward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Rover fuera de rango' ]!

!methodRemoval: MarsRoversTest #test13RoverOutOfRangeMovingForwardEast stamp: 'I 5/15/2024 18:39:37'!
test13RoverOutOfRangeMovingForwardEast
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 4 y:3.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'E' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveForward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Rover fuera de rango' ]!

!methodRemoval: MarsRoversTest #test16RoverOutOfRangeMovingBackwardEast stamp: 'I 5/15/2024 18:39:38'!
test16RoverOutOfRangeMovingBackwardEast
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 0 y:3.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'E' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveBackward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Coordenadas negativas no son validas' ]!

!methodRemoval: MarsRoversTest #test18RoverOutOfRangeMovingBackwardNort stamp: 'I 5/15/2024 18:39:39'!
test18RoverOutOfRangeMovingBackwardNort
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 3 y:0.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'N' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveBackward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Coordenadas negativas no son validas' ]!

!methodRemoval: MarsRoversTest #test17RoverOutOfRangeMovingForwardWest stamp: 'I 5/15/2024 18:39:41'!
test17RoverOutOfRangeMovingForwardWest
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 0 y:2.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'O' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveForward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Coordenadas negativas no son validas' ]!

!methodRemoval: MarsRoversTest #test19RoverOutOfRangeMovingBackwardSouth stamp: 'I 5/15/2024 18:39:42'!
test19RoverOutOfRangeMovingBackwardSouth
	|startingLocation areaOfWork rover|
	startingLocation := Point x: 3 y:3.
	areaOfWork := Point x: 4 y: 3.
	rover := MarsRovers locationAt: startingLocation pointingTo: 'S' inWorkingArea: areaOfWork. 
	self 
		should: [rover moveBackward]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText equals: 'Rover fuera de rango' ]!
!MarsRoversTest methodsFor: 'tests' stamp: 'I 5/15/2024 18:40:28' prior: 50600745!
test20
	| rover starting |
	starting := Point
		x: 1
		y: 2.
	rover := MarsRovers
		locationAt: starting
		pointingTo: 'O'.
	rover process: 'brf'.	
	self
		assert:(rover cardinalPointing: 'N').
	self
		assert:(rover isLocatedAt: (2@3)).! !

!testRun: #MarsRoversTest #test20 stamp: 'I 5/15/2024 18:40:28'!
ERROR!

!testRun: #MarsRoversTest #test20 stamp: 'I 5/15/2024 18:40:33'!
ERROR!

!testRun: #MarsRoversTest #test20 stamp: 'I 5/15/2024 18:44:17'!
ERROR!
!O methodsFor: 'as yet unclassified' stamp: 'I 5/15/2024 18:44:33' prior: 50598685!
canMoveBackward: aRover inAreaOfWork: areaOfWork
	^ self moveBackward.
! !

----End fileIn of /home/ivan/Downloads/Portfolio-Ejercicio.st----!

----End fileIn of /home/ivan/Downloads/Portfolio-Ejercicio.st----!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'I 5/15/2024 19:03:28'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'I 5/15/2024 19:03:28'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'I 5/15/2024 19:03:28'!
FAILURE!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'I 5/15/2024 19:03:28'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'I 5/15/2024 19:03:28'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'I 5/15/2024 19:03:28'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'I 5/15/2024 19:03:28'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'I 5/15/2024 19:03:28'!
FAILURE!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'I 5/15/2024 19:12:10'!
FAILURE!
!ReceptiveAccount methodsFor: 'balance' stamp: 'I 5/15/2024 19:15:40' prior: 50601838!
balance
	|balanceTotal|
	balanceTotal := 0.
	transactions do:[ :aTransaction | balanceTotal :=  balanceTotal + aTransaction value ]. 
	^balanceTotal .! !
!Withdraw methodsFor: 'value' stamp: 'I 5/15/2024 19:16:53' prior: 50601791 overrides: 50601717!
value

	^ (value negative ).! !

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'I 5/15/2024 19:17:03'!
ERROR!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'I 5/15/2024 19:17:11'!
ERROR!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'I 5/15/2024 19:20:20'!
ERROR!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'I 5/15/2024 19:20:27'!
ERROR!
!Withdraw methodsFor: 'value' stamp: 'I 5/15/2024 19:21:06' prior: 50601893 overrides: 50601717!
value

	^ (value * (-1) ).! !

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'I 5/15/2024 19:21:20'!
PASSED!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'I 5/15/2024 19:21:20'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'I 5/15/2024 19:21:21'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'I 5/15/2024 19:21:21'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'I 5/15/2024 19:21:21'!
FAILURE!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'I 5/15/2024 19:21:21'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'I 5/15/2024 19:21:21'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'I 5/15/2024 19:21:21'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'I 5/15/2024 19:21:21'!
FAILURE!
!ReceptiveAccount methodsFor: 'balance' stamp: 'I 5/16/2024 00:13:04' prior: 50601885!
balance
	|balanceTotal|
	balanceTotal := 0.
	transactions do:[ :aTransaction | balanceTotal :=  balanceTotal + aTransaction balance ]. 
	^balanceTotal .! !
!AccountTransaction methodsFor: 'value' stamp: 'I 5/16/2024 00:13:33'!
balance
	self shouldBeImplemented.! !
!AccountTransaction methodsFor: 'value' stamp: 'I 5/16/2024 00:14:01' prior: 50601958!
balance
	^100! !
!AccountTransaction methodsFor: 'value' stamp: 'I 5/16/2024 00:14:18' prior: 50601962!
balance
	^self subclassResponsibility ! !
!Deposit methodsFor: 'value' stamp: 'I 5/16/2024 00:14:24' overrides: 50601966!
balance
	^self subclassResponsibility ! !
!Withdraw methodsFor: 'value' stamp: 'I 5/16/2024 00:14:24' overrides: 50601966!
balance
	^self subclassResponsibility ! !
!AccountTransaction methodsFor: 'value' stamp: 'I 5/16/2024 00:14:24' prior: 50601966!
balance

	self subclassResponsibility! !
!Deposit methodsFor: 'value' stamp: 'I 5/16/2024 00:14:35' prior: 50601970 overrides: 50601979!
balance
	^value! !
!Withdraw methodsFor: 'value' stamp: 'I 5/16/2024 00:14:45' prior: 50601974 overrides: 50601979!
balance
	^(value * (-1))! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'I 5/16/2024 00:14:48'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'I 5/16/2024 00:14:48'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'I 5/16/2024 00:14:48'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'I 5/16/2024 00:14:48'!
FAILURE!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'I 5/16/2024 00:14:48'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'I 5/16/2024 00:14:48'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'I 5/16/2024 00:14:48'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'I 5/16/2024 00:14:48'!
FAILURE!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'I 5/16/2024 00:16:22'!
PASSED!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'I 5/16/2024 00:16:24'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'I 5/16/2024 00:16:26'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'I 5/16/2024 00:16:29'!
FAILURE!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'I 5/16/2024 00:16:29'!
FAILURE!
!Withdraw methodsFor: 'value' stamp: 'I 5/16/2024 00:16:48' prior: 50601913 overrides: 50601717!
value

	^value.! !

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'I 5/16/2024 00:16:50'!
PASSED!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'I 5/16/2024 00:16:50'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'I 5/16/2024 00:16:50'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'I 5/16/2024 00:16:50'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'I 5/16/2024 00:16:50'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'I 5/16/2024 00:16:50'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'I 5/16/2024 00:16:50'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'I 5/16/2024 00:16:50'!
PASSED!

TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #PortfolioTest category: #'Portfolio-Ejercicio' stamp: 'I 5/16/2024 00:24:40'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Object subclass: #Portfolio
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio' stamp: 'I 5/16/2024 00:24:49'!
Object subclass: #Portfolio
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

----End fileIn of /home/ivan/Documents/Facu/Inge 1/linux64/linux64/MarsRover-WithHeading.st----!

Object subclass: #Portfolio
	instanceVariableNames: 'accounts portfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio' stamp: 'I 5/16/2024 00:40:14'!
Object subclass: #Portfolio
	instanceVariableNames: 'accounts portfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

----QUIT----(16 May 2024 01:03:33) CuisUniversity-6169.image priorSource: 8587189!

----STARTUP---- (23 May 2024 16:15:53) as /home/ivan/Documents/Facu/Inge 1/linux64/linux64/CuisUniversity-6169.image!


!classRemoval: #ReceptiveAccount stamp: 'I 5/23/2024 16:16:00'!
Object subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Portfolio stamp: 'I 5/23/2024 16:16:01'!
Object subclass: #Portfolio
	instanceVariableNames: 'accounts portfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Withdraw stamp: 'I 5/23/2024 16:16:01'!
AccountTransaction subclass: #Withdraw
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Deposit stamp: 'I 5/23/2024 16:16:01'!
AccountTransaction subclass: #Deposit
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #AccountTransaction stamp: 'I 5/23/2024 16:16:02'!
Object subclass: #AccountTransaction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #ReceptiveAccountTest stamp: 'I 5/23/2024 16:16:02'!
TestCase subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #PortfolioTest stamp: 'I 5/23/2024 16:16:02'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

----End fileIn of /home/ivan/Downloads/Portfolio-Ejercicio(1).st----!

Object subclass: #Account
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Account category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 16:16:22'!
Object subclass: #Account
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Account subclass: #Portfolio
	instanceVariableNames: 'accounts portfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 16:16:32'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts portfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 16:16:48'!
Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'value' stamp: 'I 5/23/2024 16:17:34' prior: 50603013!
balance
	
	^ accounts sum:[:account| account balance].
	! !
!Portfolio methodsFor: 'value' stamp: 'I 5/23/2024 16:18:01' prior: 50603021!
hasRegistered: transaction
	|accum|
	accum := false.
	accounts do:[:account | accum := (account hasRegistered: transaction) or:[accum] ] .
	^accum! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 16:18:14'!
add: account 
	accounts add: account! !
!Portfolio methodsFor: 'initialization' stamp: 'I 5/23/2024 16:50:37' prior: 50603040 overrides: 16932297!
initialize
	| parents |
	accounts  := OrderedCollection new.
	parents := OrderedCollection new.! !

Account subclass: #Portfolio
	instanceVariableNames: 'accounts parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 16:51:10'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Account subclass: #Portfolio
	instanceVariableNames: 'accounts parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Account subclass: #Portfolio
	instanceVariableNames: 'accounts parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'initialization' stamp: 'I 5/23/2024 16:51:28' prior: 50603141 overrides: 16932297!
initialize

	accounts  := OrderedCollection new.
! !

Account subclass: #Portfolio
	instanceVariableNames: 'accounts parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 16:51:31'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'initialization' stamp: 'I 5/23/2024 16:51:44' prior: 50603170 overrides: 16932297!
initialize

	accounts  := OrderedCollection new.
	parents  := OrderedCollection new
! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 16:52:01' prior: 50603136!
add: account 
	self canAddanAccount: account.
	accounts add: account! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 16:53:16' prior: 50603194!
add: account 
	self canAddanAccount: account.
	
	accounts add: account.
	
	account addRotParent: self.
	! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 16:53:24' prior: 50603199!
add: account 
	self canAddanAccount: account.
	
	accounts add: account.
	
	account addRootParent: self.
	! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 17:14:10' prior: 50603205!
add: account 
	self canAddAnAccount: account.
	
	accounts add: account! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 17:14:18' prior: 50603211!
add: account 

	self canAddAnAccount: account.
	
	accounts add: account.
	
	account addRootParent: self.
	! !
!Portfolio class methodsFor: 'nil' stamp: 'I 5/23/2024 17:14:44'!
with: anAccount
	^self new add: anAccount.! !

!testRun: #PortfolioTest #test01 stamp: 'I 5/23/2024 17:18:40'!
ERROR!

!testRun: #PortfolioTest #test01 stamp: 'I 5/23/2024 17:18:40'!
ERROR!
!Portfolio methodsFor: 'value' stamp: 'I 5/23/2024 17:19:04' prior: 50603124!
balance
	
	^ accounts sum:[:account| account balance]ifEmpty: [^0].
	! !

!testRun: #PortfolioTest #test01 stamp: 'I 5/23/2024 17:19:07'!
PASSED!

!testRun: #PortfolioTest #test01 stamp: 'I 5/23/2024 17:19:07'!
PASSED!

!testRun: #PortfolioTest #test02 stamp: 'I 5/23/2024 17:19:07'!
PASSED!

!testRun: #PortfolioTest #test03 stamp: 'I 5/23/2024 17:19:07'!
ERROR!

!testRun: #PortfolioTest #test04 stamp: 'I 5/23/2024 17:19:07'!
ERROR!

!testRun: #PortfolioTest #test05 stamp: 'I 5/23/2024 17:19:07'!
PASSED!

!testRun: #PortfolioTest #test06 stamp: 'I 5/23/2024 17:19:07'!
PASSED!

!testRun: #PortfolioTest #test07 stamp: 'I 5/23/2024 17:19:07'!
ERROR!
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:19:16' prior: 50602714!
test02
	|portfolio account deposit|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio with: account.

	
	self assert: 100 equals:( portfolio balance).! !

!testRun: #PortfolioTest #test02 stamp: 'I 5/23/2024 17:19:21'!
ERROR!

!testRun: #PortfolioTest #test02 stamp: 'I 5/23/2024 17:19:21'!
ERROR!

!testRun: #PortfolioTest #test02 stamp: 'I 5/23/2024 17:19:33'!
ERROR!

!testRun: #PortfolioTest #test02 stamp: 'I 5/23/2024 17:19:38'!
ERROR!

!testRun: #PortfolioTest #test02 stamp: 'I 5/23/2024 17:19:38'!
ERROR!
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 17:20:14'!
canAddAnAccount: account 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 17:23:34' prior: 50603274!
canAddAnAccount: account 
	(parents anySatisfy: [:anAccount| (anAccount has:account) or:[anAccount canAddAnAccount: account ]]) ifTrue: [self class error: self class cannotAddRepetitiveAccount].! !

!testRun: #PortfolioTest #test02 stamp: 'I 5/23/2024 17:23:40'!
ERROR!
!ReceptiveAccount methodsFor: 'boolean' stamp: 'I 5/23/2024 17:25:15'!
addRootParent: aPortfolio 
	self shouldBeImplemented.! !

Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 17:25:45'!
Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ReceptiveAccount methodsFor: 'boolean' stamp: 'I 5/23/2024 17:25:47' prior: 50603290!
addRootParent: aPortfolio 
	parents add: aPortfolio.! !
!ReceptiveAccount methodsFor: 'initialization' stamp: 'I 5/23/2024 17:28:30' prior: 50603059 overrides: 16932297!
initialize

	transactions := OrderedCollection new.
	parents := OrderedCollection new.! !

!testRun: #PortfolioTest #test02 stamp: 'I 5/23/2024 17:28:37'!
PASSED!

!testRun: #PortfolioTest #test01 stamp: 'I 5/23/2024 17:28:37'!
PASSED!

!testRun: #PortfolioTest #test02 stamp: 'I 5/23/2024 17:28:37'!
PASSED!

!testRun: #PortfolioTest #test03 stamp: 'I 5/23/2024 17:28:37'!
ERROR!

!testRun: #PortfolioTest #test04 stamp: 'I 5/23/2024 17:28:37'!
ERROR!

!testRun: #PortfolioTest #test05 stamp: 'I 5/23/2024 17:28:37'!
PASSED!

!testRun: #PortfolioTest #test06 stamp: 'I 5/23/2024 17:28:37'!
PASSED!

!testRun: #PortfolioTest #test07 stamp: 'I 5/23/2024 17:28:37'!
ERROR!

!testRun: #PortfolioTest #test03 stamp: 'I 5/23/2024 17:28:41'!
ERROR!
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:29:17' prior: 50602724!
test03
	|portfolio account deposit portfolio2 account2  deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio with: account2.
	
	portfolio add: portfolio2 .


	
	self assert: 200 equals:( portfolio balance).! !

!testRun: #PortfolioTest #test03 stamp: 'I 5/23/2024 17:29:20'!
ERROR!

!testRun: #PortfolioTest #test03 stamp: 'I 5/23/2024 17:29:28'!
ERROR!
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 17:29:33'!
addRootParent: aPortfolio 
	self shouldBeImplemented.! !

!testRun: #PortfolioTest #test03 stamp: 'I 5/23/2024 17:32:20'!
ERROR!
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 17:33:14' prior: 50603360!
addRootParent: anAccount
	parents add: anAccount 
	! !

!testRun: #PortfolioTest #test03 stamp: 'I 5/23/2024 17:33:17'!
PASSED!

!testRun: #PortfolioTest #test01 stamp: 'I 5/23/2024 17:33:17'!
PASSED!

!testRun: #PortfolioTest #test02 stamp: 'I 5/23/2024 17:33:17'!
PASSED!

!testRun: #PortfolioTest #test03 stamp: 'I 5/23/2024 17:33:17'!
PASSED!

!testRun: #PortfolioTest #test04 stamp: 'I 5/23/2024 17:33:17'!
ERROR!

!testRun: #PortfolioTest #test05 stamp: 'I 5/23/2024 17:33:17'!
PASSED!

!testRun: #PortfolioTest #test06 stamp: 'I 5/23/2024 17:33:17'!
PASSED!

!testRun: #PortfolioTest #test07 stamp: 'I 5/23/2024 17:33:17'!
ERROR!
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:33:40' prior: 50603340!
test03
	|portfolio account deposit portfolio2 account2  deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio with: account2.
	
	portfolio add: portfolio2 .


	
	self assert: 200 equals:( portfolio balance).
	self assert: (portfolio hasRegistered: deposit2 )! !

!testRun: #PortfolioTest #test03 stamp: 'I 5/23/2024 17:33:44'!
PASSED!
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:34:05' prior: 50603390!
test03
	|portfolio account deposit portfolio2 account2  deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio with: account2.
	
	portfolio add: portfolio2 .


	
	self assert: 200 equals:( portfolio balance).
	self assert: (portfolio hasRegistered: deposit2 ).
	self deny: (portfolio2 hasRegistered: deposit )! !

!testRun: #PortfolioTest #test03 stamp: 'I 5/23/2024 17:34:06'!
PASSED!

!testRun: #PortfolioTest #test01 stamp: 'I 5/23/2024 17:34:06'!
PASSED!

!testRun: #PortfolioTest #test02 stamp: 'I 5/23/2024 17:34:06'!
PASSED!

!testRun: #PortfolioTest #test03 stamp: 'I 5/23/2024 17:34:06'!
PASSED!

!testRun: #PortfolioTest #test04 stamp: 'I 5/23/2024 17:34:06'!
ERROR!

!testRun: #PortfolioTest #test05 stamp: 'I 5/23/2024 17:34:06'!
PASSED!

!testRun: #PortfolioTest #test06 stamp: 'I 5/23/2024 17:34:06'!
PASSED!

!testRun: #PortfolioTest #test07 stamp: 'I 5/23/2024 17:34:06'!
ERROR!
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:35:05' prior: 50602741!
test04
	|portfolio account deposit portfolio2 portfolio3 account2 account3 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio with: account2.
	
	
	
	account3 := ReceptiveAccount new. 
	
	account3 register:(Withdraw  for: 50).
	portfolio3  := Portfolio with: account3 .
	portfolio3  addAcount: account3.
	portfolio2 addPortfolio: portfolio3 .
	portfolio addPortfolio: portfolio2 .
	
	
	self assert: 150 equals:( portfolio balance).! !

!testRun: #PortfolioTest #test04 stamp: 'I 5/23/2024 17:35:09'!
ERROR!
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:35:33' prior: 50603447!
test04
	|portfolio account deposit portfolio2 portfolio3 account2 account3 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio with: account2.
	
	
	
	account3 := ReceptiveAccount new. 
	account3 register:(Withdraw  for: 50).
	portfolio3  := Portfolio with: account3 .
	portfolio2 add: portfolio3 .
	portfolio add: portfolio2 .
	
	
	self assert: 150 equals:( portfolio balance).! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 17:40:44' prior: 50603279!
canAddAnAccount: account 
	((parents anySatisfy: [:anAccount| (anAccount hasAccount:account) or:[anAccount canAddAnAccount: account ]])
	or:[accounts anySatisfy: [:anAccount| (anAccount =account )or:[anAccount canAddAccount: account] ]]) 
	ifTrue: [self class error: self class cannotAddRepetitiveAccount].! !

!testRun: #PortfolioTest #test04 stamp: 'I 5/23/2024 17:40:54'!
ERROR!
!ReceptiveAccount methodsFor: 'boolean' stamp: 'I 5/23/2024 17:41:32'!
canAddAccount: account 
	self shouldBeImplemented.! !
!ReceptiveAccount methodsFor: 'boolean' stamp: 'I 5/23/2024 17:41:37' prior: 50603508!
canAddAccount: account 
	^false! !

!testRun: #PortfolioTest #test04 stamp: 'I 5/23/2024 17:41:42'!
PASSED!

!testRun: #PortfolioTest #test01 stamp: 'I 5/23/2024 17:41:42'!
PASSED!

!testRun: #PortfolioTest #test02 stamp: 'I 5/23/2024 17:41:42'!
PASSED!

!testRun: #PortfolioTest #test03 stamp: 'I 5/23/2024 17:41:42'!
PASSED!

!testRun: #PortfolioTest #test04 stamp: 'I 5/23/2024 17:41:42'!
PASSED!

!testRun: #PortfolioTest #test05 stamp: 'I 5/23/2024 17:41:42'!
PASSED!

!testRun: #PortfolioTest #test06 stamp: 'I 5/23/2024 17:41:42'!
PASSED!

!testRun: #PortfolioTest #test07 stamp: 'I 5/23/2024 17:41:42'!
ERROR!

!testRun: #PortfolioTest #test07 stamp: 'I 5/23/2024 17:41:42'!
ERROR!

!testRun: #PortfolioTest #test04 stamp: 'I 5/23/2024 17:43:19'!
PASSED!

!testRun: #PortfolioTest #test04 stamp: 'I 5/23/2024 17:43:24'!
PASSED!

!testRun: #PortfolioTest #test05 stamp: 'I 5/23/2024 17:46:06'!
PASSED!

!testRun: #PortfolioTest #test06 stamp: 'I 5/23/2024 17:46:08'!
PASSED!

!testRun: #PortfolioTest #test07 stamp: 'I 5/23/2024 17:46:13'!
ERROR!
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:46:33' prior: 50602783!
test07
	|compoundPortfolio account deposit portfolio2 portfolio3 account2 account3 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	compoundPortfolio  := Portfolio new.
	compoundPortfolio addAcount: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio new.
	portfolio2 addAcount: account2.
	
	
	portfolio3  := Portfolio new.
	account3 := ReceptiveAccount new. 
	account3 register:(Withdraw  for: 50).
	portfolio3  addAcount: account3.
	portfolio2 addPortfolio: portfolio3 .
	compoundPortfolio addPortfolio: portfolio2 .
	
	
	self assert: ( compoundPortfolio hasRegistered: deposit2 ).! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:47:04' prior: 50603549!
test07
	|compoundPortfolio account deposit simplePortfolio portfolio3 account2 account3 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	compoundPortfolio  := Portfolio new.
	compoundPortfolio addAcount: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	simplePortfolio  := Portfolio new.
	simplePortfolio addAcount: account2.
	
	
	portfolio3  := Portfolio new.
	account3 := ReceptiveAccount new. 
	account3 register:(Withdraw  for: 50).
	portfolio3  addAcount: account3.
	simplePortfolio addPortfolio: portfolio3 .
	compoundPortfolio addPortfolio: simplePortfolio .
	
	
	self assert: ( compoundPortfolio hasRegistered: deposit2 ).! !
!Portfolio class methodsFor: 'as yet unclassified' stamp: 'I 5/23/2024 17:50:29'!
cannotAddRepetitiveAccount
	^'Can put repetitive accounts'! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:50:36' prior: 50603574!
test07
	|compoundPortfolio account deposit simplePortfolio account2 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	compoundPortfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	simplePortfolio  := Portfolio with: account2.
	
	compoundPortfolio add: simplePortfolio. 
	
	
	self should:[simplePortfolio add: account ] 
	raise: Error - Message 
	description: [self assert: Portfolio cannotAddRepetitiveAccount ].! !

!testRun: #PortfolioTest #test07 stamp: 'I 5/23/2024 17:50:41'!
ERROR!

!testRun: #PortfolioTest #test07 stamp: 'I 5/23/2024 17:50:47'!
ERROR!

!testRun: #PortfolioTest #test07 stamp: 'I 5/23/2024 17:50:47'!
ERROR!

!testRun: #PortfolioTest #test07 stamp: 'I 5/23/2024 17:50:59'!
ERROR!
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:51:05' prior: 50603605!
test07
	|compoundPortfolio account deposit simplePortfolio account2 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	compoundPortfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	simplePortfolio  := Portfolio with: account2.
	
	compoundPortfolio add: simplePortfolio. 
	
	
	self should:[simplePortfolio add: account ] 
	raise: Error 
	description: [self assert: Portfolio cannotAddRepetitiveAccount ].! !

!testRun: #PortfolioTest #test07 stamp: 'I 5/23/2024 17:51:08'!
PASSED!

!testRun: #PortfolioTest #test01 stamp: 'I 5/23/2024 17:51:08'!
PASSED!

!testRun: #PortfolioTest #test02 stamp: 'I 5/23/2024 17:51:09'!
PASSED!

!testRun: #PortfolioTest #test03 stamp: 'I 5/23/2024 17:51:09'!
PASSED!

!testRun: #PortfolioTest #test04 stamp: 'I 5/23/2024 17:51:09'!
PASSED!

!testRun: #PortfolioTest #test05 stamp: 'I 5/23/2024 17:51:09'!
PASSED!

!testRun: #PortfolioTest #test06 stamp: 'I 5/23/2024 17:51:09'!
PASSED!

!testRun: #PortfolioTest #test07 stamp: 'I 5/23/2024 17:51:09'!
PASSED!
!Portfolio methodsFor: 'boolean' stamp: 'I 5/23/2024 17:52:09'!
hasAccount: account 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'boolean' stamp: 'I 5/23/2024 17:52:52' prior: 50603671!
hasAccount: anAccount 
	^accounts anySatisfy: [:account | account = anAccount ]! !

!testRun: #PortfolioTest #test07 stamp: 'I 5/23/2024 17:52:56'!
PASSED!

!testRun: #PortfolioTest #test01 stamp: 'I 5/23/2024 18:09:55'!
PASSED!

!testRun: #PortfolioTest #test02 stamp: 'I 5/23/2024 18:09:55'!
PASSED!

!testRun: #PortfolioTest #test03 stamp: 'I 5/23/2024 18:09:55'!
PASSED!

!testRun: #PortfolioTest #test04 stamp: 'I 5/23/2024 18:09:55'!
PASSED!

!testRun: #PortfolioTest #test05 stamp: 'I 5/23/2024 18:09:55'!
PASSED!

!testRun: #PortfolioTest #test06 stamp: 'I 5/23/2024 18:09:55'!
PASSED!

!testRun: #PortfolioTest #test07 stamp: 'I 5/23/2024 18:09:55'!
PASSED!
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 18:11:09' prior: 50603493!
canAddAnAccount: account 
	((parents anySatisfy: [:anAccount| (anAccount hasAccount:account) or:[anAccount canAddAnAccount: account ]])
	or:[accounts anySatisfy: [:anAccount| (anAccount =account )or:[anAccount canAddAccount: account] ]]) 
	ifTrue: [^self class error: self class cannotAddRepetitiveAccount].! !

!testRun: #PortfolioTest #test07 stamp: 'I 5/23/2024 18:11:22'!
PASSED!

!testRun: #PortfolioTest #test01 stamp: 'I 5/23/2024 18:11:22'!
PASSED!

!testRun: #PortfolioTest #test02 stamp: 'I 5/23/2024 18:11:22'!
PASSED!

!testRun: #PortfolioTest #test03 stamp: 'I 5/23/2024 18:11:22'!
PASSED!

!testRun: #PortfolioTest #test04 stamp: 'I 5/23/2024 18:11:22'!
PASSED!

!testRun: #PortfolioTest #test05 stamp: 'I 5/23/2024 18:11:22'!
PASSED!

!testRun: #PortfolioTest #test06 stamp: 'I 5/23/2024 18:11:22'!
PASSED!

!testRun: #PortfolioTest #test07 stamp: 'I 5/23/2024 18:11:22'!
PASSED!
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 18:31:59' prior: 50603634!
test07
	|compoundPortfolio account deposit simplePortfolio account2 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	compoundPortfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	simplePortfolio  := Portfolio with: account2.
	
	compoundPortfolio add: simplePortfolio. 
	
	
	self should:[simplePortfolio add: account ] 
	raise: Error 
	description: [:anError |
			self assert: Portfolio cannotAddRepetitiveAccount equals: anError messageText.].! !

!testRun: #PortfolioTest #test07 stamp: 'I 5/23/2024 18:32:03'!
PASSED!

!testRun: #PortfolioTest #test01 stamp: 'I 5/23/2024 18:32:03'!
PASSED!

!testRun: #PortfolioTest #test02 stamp: 'I 5/23/2024 18:32:03'!
PASSED!

!testRun: #PortfolioTest #test03 stamp: 'I 5/23/2024 18:32:03'!
PASSED!

!testRun: #PortfolioTest #test04 stamp: 'I 5/23/2024 18:32:03'!
PASSED!

!testRun: #PortfolioTest #test05 stamp: 'I 5/23/2024 18:32:03'!
PASSED!

!testRun: #PortfolioTest #test06 stamp: 'I 5/23/2024 18:32:03'!
PASSED!

!testRun: #PortfolioTest #test07 stamp: 'I 5/23/2024 18:32:03'!
PASSED!

!testRun: #PortfolioTest #test07 stamp: 'I 5/23/2024 18:32:28'!
PASSED!
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 18:32:45' prior: 50603731!
test07
	|compoundPortfolio account deposit simplePortfolio account2 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	compoundPortfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	simplePortfolio  := Portfolio with: account2.
	
	compoundPortfolio add: simplePortfolio. 
	
	
	self should:[simplePortfolio add: account ] 
	raise: Error - MessageNotUnderstood 
	description: [:anError |
			self assert: Portfolio cannotAddRepetitiveAccount equals: anError messageText.].! !

!testRun: #PortfolioTest #test07 stamp: 'I 5/23/2024 18:32:48'!
PASSED!

!testRun: #PortfolioTest #test01 stamp: 'I 5/23/2024 18:32:48'!
PASSED!

!testRun: #PortfolioTest #test02 stamp: 'I 5/23/2024 18:32:48'!
PASSED!

!testRun: #PortfolioTest #test03 stamp: 'I 5/23/2024 18:32:48'!
PASSED!

!testRun: #PortfolioTest #test04 stamp: 'I 5/23/2024 18:32:48'!
PASSED!

!testRun: #PortfolioTest #test05 stamp: 'I 5/23/2024 18:32:48'!
PASSED!

!testRun: #PortfolioTest #test06 stamp: 'I 5/23/2024 18:32:48'!
PASSED!

!testRun: #PortfolioTest #test07 stamp: 'I 5/23/2024 18:32:48'!
PASSED!
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 18:33:24' prior: 50603772!
test07
	|compoundPortfolio account deposit simplePortfolio account2 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	compoundPortfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	simplePortfolio  := Portfolio with: account2.
	
	compoundPortfolio add: simplePortfolio. 
	
	
	self should:[simplePortfolio add: account ] 
	raise: Error - MessageNotUnderstood 
	description: [:anError |
			self assert: Portfolio cannotAddRepetitiveAccount equals: anError messageText.
			self assert: (compoundPortfolio hasRegistered: deposit2 )].! !

!testRun: #PortfolioTest #test07 stamp: 'I 5/23/2024 18:33:27'!
PASSED!

!testRun: #PortfolioTest #test01 stamp: 'I 5/23/2024 18:33:27'!
PASSED!

!testRun: #PortfolioTest #test02 stamp: 'I 5/23/2024 18:33:27'!
PASSED!

!testRun: #PortfolioTest #test03 stamp: 'I 5/23/2024 18:33:27'!
PASSED!

!testRun: #PortfolioTest #test04 stamp: 'I 5/23/2024 18:33:27'!
PASSED!

!testRun: #PortfolioTest #test05 stamp: 'I 5/23/2024 18:33:27'!
PASSED!

!testRun: #PortfolioTest #test06 stamp: 'I 5/23/2024 18:33:27'!
PASSED!

!testRun: #PortfolioTest #test07 stamp: 'I 5/23/2024 18:33:27'!
PASSED!

!methodRemoval: Portfolio #addPortfolio: stamp: 'I 5/23/2024 18:34:03'!
addPortfolio: portfolioToAdd 
	portfolios add: portfolioToAdd .!
!Portfolio methodsFor: 'nil' stamp: 'I 5/23/2024 18:45:06'!
transactions! !
!Portfolio methodsFor: 'transactions' stamp: 'I 5/23/2024 18:46:43' prior: 50603857!
transactions
	|transactionsList|
	
	transactionsList := Set new.
	
	accounts do: [:anAccount | transactionsList addTransaction: anAccount].
	

	^transactionsList .! !
!Portfolio methodsFor: 'transactions' stamp: 'I 5/23/2024 18:46:52' prior: 50603861!
transactions
	|transactionsList|
	
	transactionsList := Set new.
	
	accounts do: [:anAccount | transactionsList addTransactionTo: anAccount].
	

	^transactionsList .! !
!Portfolio methodsFor: 'transactions' stamp: 'I 5/23/2024 18:47:00' prior: 50603869!
transactions
	|transactionsList|
	
	transactionsList := Set new.
	
	accounts do: [:anAccount | transactionsList addTransactionFrom: anAccount].
	

	^transactionsList .! !
!Portfolio methodsFor: 'transactions' stamp: 'I 5/23/2024 18:47:37' prior: 50603877!
transactions
	|transactionsList|
	
	transactionsList := Set new.
	
	accounts do: [:anAccount | anAccount addTransactionTo: transactionsList ].
	

	^transactionsList .! !
!Portfolio methodsFor: 'transactions' stamp: 'I 5/23/2024 18:59:36' prior: 50603885!
transactions
	|transactionsList|
	
	transactionsList := Set new.
	
	accounts do: [:anAccount | anAccount addTransactionsTo: transactionsList ].
	

	^transactionsList .! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 19:00:21'!
addTransactionsTo: transactions
	accounts do: [:anAccount | anAccount addTransactionsTo: transactions].! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'I 5/23/2024 19:01:12'!
addTransactionsTo: transactionsList
	transactions do: [:transaction | transactionsList add: transaction ].! !

!testRun: #PortfolioTest #test01 stamp: 'I 5/23/2024 19:01:13'!
PASSED!

!testRun: #PortfolioTest #test02 stamp: 'I 5/23/2024 19:01:13'!
PASSED!

!testRun: #PortfolioTest #test03 stamp: 'I 5/23/2024 19:01:13'!
PASSED!

!testRun: #PortfolioTest #test04 stamp: 'I 5/23/2024 19:01:13'!
PASSED!

!testRun: #PortfolioTest #test05 stamp: 'I 5/23/2024 19:01:13'!
PASSED!

!testRun: #PortfolioTest #test06 stamp: 'I 5/23/2024 19:01:13'!
PASSED!

!testRun: #PortfolioTest #test07 stamp: 'I 5/23/2024 19:01:13'!
PASSED!
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 19:02:52'!
test08PortfolioTransactionsAreCalculatedRecursively

	| simplePortfolioAccount simplePortfolio composedPortfolioAccount composedPortfolio composedPortfolioAccountWithdraw simplePortfolioAccountDeposit composedPortfolioTransactions |
	
	simplePortfolioAccount := ReceptiveAccount new.
	simplePortfolioAccountDeposit := Deposit register: 100 on: simplePortfolioAccount.
	simplePortfolio := Portfolio with: simplePortfolioAccount.
	
	composedPortfolioAccount := ReceptiveAccount new.
	composedPortfolioAccountWithdraw := Withdraw register: 50 on: composedPortfolioAccount.
	composedPortfolio := Portfolio with: simplePortfolio with: composedPortfolioAccount.
	
	composedPortfolioTransactions := composedPortfolio transactions.
	self assert: 2 equals: composedPortfolioTransactions size.
	self assert: (composedPortfolioTransactions includes: simplePortfolioAccountDeposit).
	self assert: (composedPortfolioTransactions includes: composedPortfolioAccountWithdraw)! !

!testRun: #PortfolioTest #test08PortfolioTransactionsAreCalculatedRecursively stamp: 'I 5/23/2024 19:02:54'!
ERROR!
!Portfolio class methodsFor: 'as yet unclassified' stamp: 'I 5/23/2024 19:03:24'!
with: anAccount with: anotherAccount
	^self new add: anAccount; add: anotherAccount .! !

!testRun: #PortfolioTest #test08PortfolioTransactionsAreCalculatedRecursively stamp: 'I 5/23/2024 19:03:31'!
ERROR!

!testRun: #PortfolioTest #test08PortfolioTransactionsAreCalculatedRecursively stamp: 'I 5/23/2024 19:03:31'!
ERROR!

!testRun: #PortfolioTest #test08PortfolioTransactionsAreCalculatedRecursively stamp: 'I 5/23/2024 19:03:47'!
ERROR!

!testRun: #PortfolioTest #test08PortfolioTransactionsAreCalculatedRecursively stamp: 'I 5/23/2024 19:03:56'!
ERROR!

!testRun: #PortfolioTest #test08PortfolioTransactionsAreCalculatedRecursively stamp: 'I 5/23/2024 19:04:21'!
ERROR!

!testRun: #PortfolioTest #test08PortfolioTransactionsAreCalculatedRecursively stamp: 'I 5/23/2024 19:04:36'!
ERROR!
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 19:05:48' prior: 50603700!
canAddAnAccount: account 
	((parents anySatisfy: [:anAccount| (anAccount hasAccount:account) or:[anAccount canAddAnAccount: account ]])
	or:[accounts anySatisfy: [:anAccount| (anAccount =account )or:[anAccount canAddAnAccount: account] ]]) 
	ifTrue: [^self class error: self class cannotAddRepetitiveAccount].! !

----STARTUP---- (23 May 2024 19:08:10) as /home/ivan/Documents/Facu/Inge 1/linux64/linux64/CuisUniversity-6169.image!


!classRemoval: #ReceptiveAccount stamp: 'I 5/23/2024 19:08:12'!
Object subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Portfolio stamp: 'I 5/23/2024 19:08:12'!
Object subclass: #Portfolio
	instanceVariableNames: 'accounts portfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Withdraw stamp: 'I 5/23/2024 19:08:12'!
AccountTransaction subclass: #Withdraw
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Deposit stamp: 'I 5/23/2024 19:08:13'!
AccountTransaction subclass: #Deposit
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #AccountTransaction stamp: 'I 5/23/2024 19:08:13'!
Object subclass: #AccountTransaction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #ReceptiveAccountTest stamp: 'I 5/23/2024 19:08:13'!
TestCase subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #PortfolioTest stamp: 'I 5/23/2024 19:08:14'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #PortfolioTest category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:14'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #PortfolioTest category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:14'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/16/2024 11:33:49'!
test01
	|portfolio|
	
	portfolio  := Portfolio new.
	
	self assert: 0 equals: portfolio balance.! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/16/2024 12:24:15'!
test02
	|portfolio account deposit|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio new.
	portfolio addAcount: account.

	
	self assert: 100 equals:( portfolio balance).! !
!PortfolioTest methodsFor: 'tests' stamp: 'i 5/16/2024 21:03:46'!
test03
	|portfolio account deposit portfolio2 account2  deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio new.
	portfolio addAcount: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio new.
	portfolio2 addAcount: account2.
	
	portfolio addPortfolio: portfolio2 .


	
	self assert: 200 equals:( portfolio balance).! !
!PortfolioTest methodsFor: 'tests' stamp: 'i 5/16/2024 21:02:25'!
test04
	|portfolio account deposit portfolio2 portfolio3 account2 account3 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio new.
	portfolio addAcount: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio new.
	portfolio2 addAcount: account2.
	
	
	portfolio3  := Portfolio new.
	account3 := ReceptiveAccount new. 
	account3 register:(Withdraw  for: 50).
	portfolio3  addAcount: account3.
	portfolio2 addPortfolio: portfolio3 .
	portfolio addPortfolio: portfolio2 .
	
	
	self assert: 150 equals:( portfolio balance).! !
!PortfolioTest methodsFor: 'tests' stamp: 'i 5/16/2024 21:07:57'!
test05
	|portfolio account deposit|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio new.
	portfolio addAcount: account.

	
	self assert:( portfolio hasRegistered:deposit).! !
!PortfolioTest methodsFor: 'tests' stamp: 'i 5/16/2024 21:14:12'!
test06
	|portfolio account deposit|
	
	account := ReceptiveAccount new.
	deposit  := Deposit for: 100  .
	portfolio  := Portfolio new.
	portfolio addAcount: account.

	
	self deny:( portfolio hasRegistered:deposit).! !
!PortfolioTest methodsFor: 'tests' stamp: 'i 5/16/2024 21:23:47'!
test07
	|portfolio account deposit portfolio2 portfolio3 account2 account3 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio new.
	portfolio addAcount: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio new.
	portfolio2 addAcount: account2.
	
	
	portfolio3  := Portfolio new.
	account3 := ReceptiveAccount new. 
	account3 register:(Withdraw  for: 50).
	portfolio3  addAcount: account3.
	portfolio2 addPortfolio: portfolio3 .
	portfolio addPortfolio: portfolio2 .
	
	
	self assert: ( portfolio hasRegistered: deposit2 ).! !

!classDefinition: #ReceptiveAccountTest category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:14'!
TestCase subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccountTest category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:14'!
TestCase subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'NR 11/2/2020 17:13:44'!
test01ReceptiveAccountHaveZeroAsBalanceWhenCreated 

	| account |
	
	account := ReceptiveAccount new.

	self assert: 0 equals: account balance.
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'NR 11/2/2020 17:13:48'!
test02DepositIncreasesBalanceOnTransactionValue 

	| account |
	
	account := ReceptiveAccount  new.
	Deposit register: 100 on: account.
		
	self assert: 100 equals: account balance.
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'NR 11/2/2020 17:13:52'!
test03WithdrawDecreasesBalanceOnTransactionValue 

	| account |
	
	account := ReceptiveAccount new.
	Deposit register: 100 on: account.
	Withdraw register: 50 on: account.
		
	self assert: 50 equals: account balance.
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'HAW 5/23/2019 15:20:32'!
test04WithdrawValueMustBePositive 

	| account withdrawValue |
	
	account := ReceptiveAccount new.
	withdrawValue := 50.
	
	self assert: withdrawValue equals: (Withdraw register: withdrawValue on: account) value
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'HAW 5/23/2019 15:20:46'!
test05ReceptiveAccountKnowsRegisteredTransactions 

	| account deposit withdraw |
	
	account := ReceptiveAccount new.
	deposit := Deposit register: 100 on: account.
	withdraw := Withdraw register: 50 on: account.
		
	self assert: (account hasRegistered: deposit).
	self assert: (account hasRegistered: withdraw).
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'NR 5/17/2021 17:29:53'!
test06ReceptiveAccountDoNotKnowNotRegisteredTransactions

	| deposit withdraw account |
	
	account := ReceptiveAccount new.
	deposit :=  Deposit for: 200.
	withdraw := Withdraw for: 50.
		
	self deny: (account hasRegistered: deposit).
	self deny: (account hasRegistered:withdraw).
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'NR 11/2/2020 17:14:01'!
test07AccountKnowsItsTransactions 

	| account1 deposit1 |
	
	account1 := ReceptiveAccount new.
	
	deposit1 := Deposit register: 50 on: account1.
		
	self assert: 1 equals: account1 transactions size.
	self assert: (account1 transactions includes: deposit1).
! !

!classDefinition: #AccountTransaction category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:14'!
Object subclass: #AccountTransaction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AccountTransaction category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:14'!
Object subclass: #AccountTransaction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!AccountTransaction methodsFor: 'value' stamp: 'HernanWilkinson 9/12/2011 12:25' overrides: 16914075!
value 

	self subclassResponsibility ! !

!classDefinition: 'AccountTransaction class' category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:14'!
AccountTransaction class
	instanceVariableNames: ''!

!classDefinition: 'AccountTransaction class' category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:14'!
AccountTransaction class
	instanceVariableNames: ''!
!AccountTransaction class methodsFor: 'instance creation' stamp: 'NR 10/17/2019 03:22:00'!
register: aValue on: account

	| transaction |
	
	transaction := self for: aValue.
	account register: transaction.
		
	^ transaction! !

!classDefinition: #Deposit category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:14'!
AccountTransaction subclass: #Deposit
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Deposit category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:14'!
AccountTransaction subclass: #Deposit
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Deposit methodsFor: 'initialization' stamp: 'HernanWilkinson 7/13/2011 18:45'!
initializeFor: aValue

	value := aValue ! !
!Deposit methodsFor: 'value' stamp: 'HernanWilkinson 7/13/2011 18:38' overrides: 50604273!
value

	^ value! !
!Deposit methodsFor: 'add' stamp: 'i 5/16/2024 20:47:22'!
addTo: balance 
	^balance + value! !

!classDefinition: 'Deposit class' category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:14'!
Deposit class
	instanceVariableNames: ''!

!classDefinition: 'Deposit class' category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:14'!
Deposit class
	instanceVariableNames: ''!
!Deposit class methodsFor: 'instance creation' stamp: 'HernanWilkinson 7/13/2011 18:38' overrides: 50599915!
for: aValue

	^ self new initializeFor: aValue ! !

!classDefinition: #Withdraw category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:14'!
AccountTransaction subclass: #Withdraw
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Withdraw category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:14'!
AccountTransaction subclass: #Withdraw
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Withdraw methodsFor: 'initialization' stamp: 'HernanWilkinson 7/13/2011 18:46'!
initializeFor: aValue

	value := aValue ! !
!Withdraw methodsFor: 'value' stamp: 'HernanWilkinson 7/13/2011 18:33' overrides: 50604273!
value

	^ value! !
!Withdraw methodsFor: 'add' stamp: 'i 5/16/2024 20:47:53'!
addTo: balance 
	^balance - value! !

!classDefinition: 'Withdraw class' category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:14'!
Withdraw class
	instanceVariableNames: ''!

!classDefinition: 'Withdraw class' category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:14'!
Withdraw class
	instanceVariableNames: ''!
!Withdraw class methodsFor: 'instance creation' stamp: 'HernanWilkinson 7/13/2011 18:33' overrides: 50599915!
for: aValue

	^ self new initializeFor: aValue ! !

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:14'!
Object subclass: #Portfolio
	instanceVariableNames: 'accounts portfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:14'!
Object subclass: #Portfolio
	instanceVariableNames: 'accounts portfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'value' stamp: 'I 5/16/2024 12:39:23'!
balance
	|balance| 
	balance := 0.
	accounts do:[:account| balance := balance + account balance].
	portfolios do: [:portfolio | balance := balance + portfolio balance].
	
	^balance ! !
!Portfolio methodsFor: 'value' stamp: 'i 5/16/2024 21:21:53'!
hasRegistered: transaction
	|accum|
	accum := false.
	accounts do:[:account | accum := (account hasRegistered: transaction) or:[accum] ] .
	portfolios do:[:portfolio | accum := (portfolio hasRegistered: transaction ) or:[accum] ] .
	^accum! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/16/2024 12:20:32'!
addAcount: account 
	accounts add: account! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/16/2024 12:37:10'!
addPortfolio: portfolioToAdd 
	portfolios add: portfolioToAdd .! !
!Portfolio methodsFor: 'initialization' stamp: 'I 5/16/2024 12:22:10' overrides: 16932297!
initialize
	accounts  := OrderedCollection new.
	portfolios := OrderedCollection new.! !

!classDefinition: #ReceptiveAccount category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:14'!
Object subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:14'!
Object subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ReceptiveAccount methodsFor: 'initialization' stamp: 'NR 10/17/2019 15:06:56' overrides: 16932297!
initialize

	transactions := OrderedCollection new.! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'HernanWilkinson 7/13/2011 18:37'!
register: aTransaction

	transactions add: aTransaction 
! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'HernanWilkinson 7/13/2011 18:37'!
transactions 

	^ transactions copy! !
!ReceptiveAccount methodsFor: 'balance' stamp: 'i 5/16/2024 20:48:35'!
balance
	|balance|
	balance := 0.
	transactions do: [ :aTransaction |balance := aTransaction addTo: balance ].
	^balance ! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'NR 10/17/2019 03:28:43'!
hasRegistered: aTransaction

	^ transactions includes: aTransaction 
! !

!classDefinition: #Account category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:14'!
Object subclass: #Account
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Account category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:14'!
Object subclass: #Account
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:14'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts portfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:14'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts portfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:14'!
Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:14'!
Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'value' stamp: 'I 5/23/2024 16:17:34' prior: 50604394!
balance
	
	^ accounts sum:[:account| account balance].
	! !
!Portfolio methodsFor: 'value' stamp: 'I 5/23/2024 16:18:01' prior: 50604402!
hasRegistered: transaction
	|accum|
	accum := false.
	accounts do:[:account | accum := (account hasRegistered: transaction) or:[accum] ] .
	^accum! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 16:18:14'!
add: account 
	accounts add: account! !
!Portfolio methodsFor: 'initialization' stamp: 'I 5/23/2024 16:50:37' prior: 50604421 overrides: 16932297!
initialize
	| parents |
	accounts  := OrderedCollection new.
	parents := OrderedCollection new.! !

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:14'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:15'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'initialization' stamp: 'I 5/23/2024 16:51:28' prior: 50604532 overrides: 16932297!
initialize

	accounts  := OrderedCollection new.
! !

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:15'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:15'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'initialization' stamp: 'I 5/23/2024 16:51:44' prior: 50604554 overrides: 16932297!
initialize

	accounts  := OrderedCollection new.
	parents  := OrderedCollection new
! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 16:52:01' prior: 50604527!
add: account 
	self canAddanAccount: account.
	accounts add: account! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 16:53:16' prior: 50604581!
add: account 
	self canAddanAccount: account.
	
	accounts add: account.
	
	account addRotParent: self.
	! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 16:53:24' prior: 50604586!
add: account 
	self canAddanAccount: account.
	
	accounts add: account.
	
	account addRootParent: self.
	! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 17:14:10' prior: 50604592!
add: account 
	self canAddAnAccount: account.
	
	accounts add: account! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 17:14:18' prior: 50604598!
add: account 

	self canAddAnAccount: account.
	
	accounts add: account.
	
	account addRootParent: self.
	! !
!Portfolio class methodsFor: 'nil' stamp: 'I 5/23/2024 17:14:44'!
with: anAccount
	^self new add: anAccount.! !
!Portfolio methodsFor: 'value' stamp: 'I 5/23/2024 17:19:04' prior: 50604515!
balance
	
	^ accounts sum:[:account| account balance]ifEmpty: [^0].
	! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:19:16' prior: 50604077!
test02
	|portfolio account deposit|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio with: account.

	
	self assert: 100 equals:( portfolio balance).! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 17:20:14'!
canAddAnAccount: account 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 17:23:34' prior: 50604627!
canAddAnAccount: account 
	(parents anySatisfy: [:anAccount| (anAccount has:account) or:[anAccount canAddAnAccount: account ]]) ifTrue: [self class error: self class cannotAddRepetitiveAccount].! !
!ReceptiveAccount methodsFor: 'boolean' stamp: 'I 5/23/2024 17:25:15'!
addRootParent: aPortfolio 
	self shouldBeImplemented.! !

!classDefinition: #ReceptiveAccount category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:15'!
Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: #'Portfolio-Ejercicio' stamp: 'I 5/23/2024 19:08:15'!
Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ReceptiveAccount methodsFor: 'boolean' stamp: 'I 5/23/2024 17:25:47' prior: 50604641!
addRootParent: aPortfolio 
	parents add: aPortfolio.! !
!ReceptiveAccount methodsFor: 'initialization' stamp: 'I 5/23/2024 17:28:30' prior: 50604443 overrides: 16932297!
initialize

	transactions := OrderedCollection new.
	parents := OrderedCollection new.! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:29:17' prior: 50604087!
test03
	|portfolio account deposit portfolio2 account2  deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio with: account2.
	
	portfolio add: portfolio2 .


	
	self assert: 200 equals:( portfolio balance).! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 17:29:33'!
addRootParent: aPortfolio 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 17:33:14' prior: 50604689!
addRootParent: anAccount
	parents add: anAccount 
	! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:33:40' prior: 50604674!
test03
	|portfolio account deposit portfolio2 account2  deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio with: account2.
	
	portfolio add: portfolio2 .


	
	self assert: 200 equals:( portfolio balance).
	self assert: (portfolio hasRegistered: deposit2 )! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:34:05' prior: 50604699!
test03
	|portfolio account deposit portfolio2 account2  deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio with: account2.
	
	portfolio add: portfolio2 .


	
	self assert: 200 equals:( portfolio balance).
	self assert: (portfolio hasRegistered: deposit2 ).
	self deny: (portfolio2 hasRegistered: deposit )! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:35:05' prior: 50604104!
test04
	|portfolio account deposit portfolio2 portfolio3 account2 account3 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio with: account2.
	
	
	
	account3 := ReceptiveAccount new. 
	
	account3 register:(Withdraw  for: 50).
	portfolio3  := Portfolio with: account3 .
	portfolio3  addAcount: account3.
	portfolio2 addPortfolio: portfolio3 .
	portfolio addPortfolio: portfolio2 .
	
	
	self assert: 150 equals:( portfolio balance).! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:35:33' prior: 50604735!
test04
	|portfolio account deposit portfolio2 portfolio3 account2 account3 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio with: account2.
	
	
	
	account3 := ReceptiveAccount new. 
	account3 register:(Withdraw  for: 50).
	portfolio3  := Portfolio with: account3 .
	portfolio2 add: portfolio3 .
	portfolio add: portfolio2 .
	
	
	self assert: 150 equals:( portfolio balance).! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 17:40:44' prior: 50604632!
canAddAnAccount: account 
	((parents anySatisfy: [:anAccount| (anAccount hasAccount:account) or:[anAccount canAddAnAccount: account ]])
	or:[accounts anySatisfy: [:anAccount| (anAccount =account )or:[anAccount canAddAccount: account] ]]) 
	ifTrue: [self class error: self class cannotAddRepetitiveAccount].! !
!ReceptiveAccount methodsFor: 'boolean' stamp: 'I 5/23/2024 17:41:32'!
canAddAccount: account 
	self shouldBeImplemented.! !
!ReceptiveAccount methodsFor: 'boolean' stamp: 'I 5/23/2024 17:41:37' prior: 50604791!
canAddAccount: account 
	^false! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:46:33' prior: 50604146!
test07
	|compoundPortfolio account deposit portfolio2 portfolio3 account2 account3 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	compoundPortfolio  := Portfolio new.
	compoundPortfolio addAcount: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio new.
	portfolio2 addAcount: account2.
	
	
	portfolio3  := Portfolio new.
	account3 := ReceptiveAccount new. 
	account3 register:(Withdraw  for: 50).
	portfolio3  addAcount: account3.
	portfolio2 addPortfolio: portfolio3 .
	compoundPortfolio addPortfolio: portfolio2 .
	
	
	self assert: ( compoundPortfolio hasRegistered: deposit2 ).! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:47:04' prior: 50604800!
test07
	|compoundPortfolio account deposit simplePortfolio portfolio3 account2 account3 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	compoundPortfolio  := Portfolio new.
	compoundPortfolio addAcount: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	simplePortfolio  := Portfolio new.
	simplePortfolio addAcount: account2.
	
	
	portfolio3  := Portfolio new.
	account3 := ReceptiveAccount new. 
	account3 register:(Withdraw  for: 50).
	portfolio3  addAcount: account3.
	simplePortfolio addPortfolio: portfolio3 .
	compoundPortfolio addPortfolio: simplePortfolio .
	
	
	self assert: ( compoundPortfolio hasRegistered: deposit2 ).! !
!Portfolio class methodsFor: 'as yet unclassified' stamp: 'I 5/23/2024 17:50:29'!
cannotAddRepetitiveAccount
	^'Can put repetitive accounts'! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:50:36' prior: 50604825!
test07
	|compoundPortfolio account deposit simplePortfolio account2 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	compoundPortfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	simplePortfolio  := Portfolio with: account2.
	
	compoundPortfolio add: simplePortfolio. 
	
	
	self should:[simplePortfolio add: account ] 
	raise: Error - Message 
	description: [self assert: Portfolio cannotAddRepetitiveAccount ].! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:51:05' prior: 50604856!
test07
	|compoundPortfolio account deposit simplePortfolio account2 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	compoundPortfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	simplePortfolio  := Portfolio with: account2.
	
	compoundPortfolio add: simplePortfolio. 
	
	
	self should:[simplePortfolio add: account ] 
	raise: Error 
	description: [self assert: Portfolio cannotAddRepetitiveAccount ].! !
!Portfolio methodsFor: 'boolean' stamp: 'I 5/23/2024 17:52:09'!
hasAccount: account 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'boolean' stamp: 'I 5/23/2024 17:52:52' prior: 50604895!
hasAccount: anAccount 
	^accounts anySatisfy: [:account | account = anAccount ]! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 18:11:09' prior: 50604779!
canAddAnAccount: account 
	((parents anySatisfy: [:anAccount| (anAccount hasAccount:account) or:[anAccount canAddAnAccount: account ]])
	or:[accounts anySatisfy: [:anAccount| (anAccount =account )or:[anAccount canAddAccount: account] ]]) 
	ifTrue: [^self class error: self class cannotAddRepetitiveAccount].! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 18:31:59' prior: 50604876!
test07
	|compoundPortfolio account deposit simplePortfolio account2 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	compoundPortfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	simplePortfolio  := Portfolio with: account2.
	
	compoundPortfolio add: simplePortfolio. 
	
	
	self should:[simplePortfolio add: account ] 
	raise: Error 
	description: [:anError |
			self assert: Portfolio cannotAddRepetitiveAccount equals: anError messageText.].! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 18:32:45' prior: 50604919!
test07
	|compoundPortfolio account deposit simplePortfolio account2 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	compoundPortfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	simplePortfolio  := Portfolio with: account2.
	
	compoundPortfolio add: simplePortfolio. 
	
	
	self should:[simplePortfolio add: account ] 
	raise: Error - MessageNotUnderstood 
	description: [:anError |
			self assert: Portfolio cannotAddRepetitiveAccount equals: anError messageText.].! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 18:33:24' prior: 50604940!
test07
	|compoundPortfolio account deposit simplePortfolio account2 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	compoundPortfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	simplePortfolio  := Portfolio with: account2.
	
	compoundPortfolio add: simplePortfolio. 
	
	
	self should:[simplePortfolio add: account ] 
	raise: Error - MessageNotUnderstood 
	description: [:anError |
			self assert: Portfolio cannotAddRepetitiveAccount equals: anError messageText.
			self assert: (compoundPortfolio hasRegistered: deposit2 )].! !

!methodRemoval: Portfolio #addPortfolio: stamp: 'I 5/23/2024 19:08:15'!
addPortfolio: portfolioToAdd 
	portfolios add: portfolioToAdd .!
!Portfolio methodsFor: 'nil' stamp: 'I 5/23/2024 18:45:06'!
transactions! !
!Portfolio methodsFor: 'transactions' stamp: 'I 5/23/2024 18:46:43' prior: 50604989!
transactions
	|transactionsList|
	
	transactionsList := Set new.
	
	accounts do: [:anAccount | transactionsList addTransaction: anAccount].
	

	^transactionsList .! !
!Portfolio methodsFor: 'transactions' stamp: 'I 5/23/2024 18:46:52' prior: 50604993!
transactions
	|transactionsList|
	
	transactionsList := Set new.
	
	accounts do: [:anAccount | transactionsList addTransactionTo: anAccount].
	

	^transactionsList .! !
!Portfolio methodsFor: 'transactions' stamp: 'I 5/23/2024 18:47:00' prior: 50605001!
transactions
	|transactionsList|
	
	transactionsList := Set new.
	
	accounts do: [:anAccount | transactionsList addTransactionFrom: anAccount].
	

	^transactionsList .! !
!Portfolio methodsFor: 'transactions' stamp: 'I 5/23/2024 18:47:37' prior: 50605009!
transactions
	|transactionsList|
	
	transactionsList := Set new.
	
	accounts do: [:anAccount | anAccount addTransactionTo: transactionsList ].
	

	^transactionsList .! !
!Portfolio methodsFor: 'transactions' stamp: 'I 5/23/2024 18:59:36' prior: 50605017!
transactions
	|transactionsList|
	
	transactionsList := Set new.
	
	accounts do: [:anAccount | anAccount addTransactionsTo: transactionsList ].
	

	^transactionsList .! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 19:00:21'!
addTransactionsTo: transactions
	accounts do: [:anAccount | anAccount addTransactionsTo: transactions].! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'I 5/23/2024 19:01:12'!
addTransactionsTo: transactionsList
	transactions do: [:transaction | transactionsList add: transaction ].! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 19:02:52'!
test08PortfolioTransactionsAreCalculatedRecursively

	| simplePortfolioAccount simplePortfolio composedPortfolioAccount composedPortfolio composedPortfolioAccountWithdraw simplePortfolioAccountDeposit composedPortfolioTransactions |
	
	simplePortfolioAccount := ReceptiveAccount new.
	simplePortfolioAccountDeposit := Deposit register: 100 on: simplePortfolioAccount.
	simplePortfolio := Portfolio with: simplePortfolioAccount.
	
	composedPortfolioAccount := ReceptiveAccount new.
	composedPortfolioAccountWithdraw := Withdraw register: 50 on: composedPortfolioAccount.
	composedPortfolio := Portfolio with: simplePortfolio with: composedPortfolioAccount.
	
	composedPortfolioTransactions := composedPortfolio transactions.
	self assert: 2 equals: composedPortfolioTransactions size.
	self assert: (composedPortfolioTransactions includes: simplePortfolioAccountDeposit).
	self assert: (composedPortfolioTransactions includes: composedPortfolioAccountWithdraw)! !
!Portfolio class methodsFor: 'as yet unclassified' stamp: 'I 5/23/2024 19:03:24'!
with: anAccount with: anotherAccount
	^self new add: anAccount; add: anotherAccount .! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 19:05:48' prior: 50604906!
canAddAnAccount: account 
	((parents anySatisfy: [:anAccount| (anAccount hasAccount:account) or:[anAccount canAddAnAccount: account ]])
	or:[accounts anySatisfy: [:anAccount| (anAccount =account )or:[anAccount canAddAnAccount: account] ]]) 
	ifTrue: [^self class error: self class cannotAddRepetitiveAccount].! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 19:10:28' prior: 50605084!
canAddAnAccount: account 
	((self parentsHaveAnAccount: account)
	or:[accounts anySatisfy: [:anAccount| (anAccount =account )or:[anAccount canAddAnAccount: account] ]]) 
	ifTrue: [^self class error: self class cannotAddRepetitiveAccount].! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 19:12:59'!
parentsHaveAnAccount: account

	^self rootsParents anySatisfy: [:aParent| aParent isComposedBy: account ].! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 19:17:40'!
addParentsTo: setOfParents

	parents ifEmpty: [setOfParents add: self]
	 ifNotEmpty: [ parents do: [ :aParent | aParent addParentsTo: setOfParents  ]].! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 19:21:52'!
rootsParents

	|rootsParents|
	
	rootsParents := Set new.
	
	self addParentsTo: rootsParents .
	
	^rootsParents ! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 19:22:45' prior: 50605113!
addParentsTo: rootsParents
	
	parents ifEmpty: [rootsParents add: self]
	 ifNotEmpty: [parents do:[:aParent| aParent addParentsTo: rootsParents ]].! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 19:24:12'!
isComposedBy: account 
	^accounts anySatisfy: [:anAccount| (anAccount = account )or:[anAccount isComposedBy: account]].! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'I 5/23/2024 19:24:29'!
isComposedBy: account
	^account = self.! !

!testRun: #PortfolioTest #test08PortfolioTransactionsAreCalculatedRecursively stamp: 'I 5/23/2024 19:24:37'!
ERROR!

!testRun: #PortfolioTest #test08PortfolioTransactionsAreCalculatedRecursively stamp: 'I 5/23/2024 19:24:37'!
ERROR!
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 19:25:05' prior: 50605097!
canAddAnAccount: account 
	(self parentsHaveAnAccount: account) 	ifTrue: [^self class error: self class cannotAddRepetitiveAccount].! !

!testRun: #PortfolioTest #test08PortfolioTransactionsAreCalculatedRecursively stamp: 'I 5/23/2024 19:25:49'!
PASSED!

!testRun: #PortfolioTest #test01 stamp: 'I 5/23/2024 19:25:51'!
PASSED!

!testRun: #PortfolioTest #test02 stamp: 'I 5/23/2024 19:25:51'!
PASSED!

!testRun: #PortfolioTest #test03 stamp: 'I 5/23/2024 19:25:51'!
PASSED!

!testRun: #PortfolioTest #test04 stamp: 'I 5/23/2024 19:25:51'!
PASSED!

!testRun: #PortfolioTest #test05 stamp: 'I 5/23/2024 19:25:51'!
PASSED!

!testRun: #PortfolioTest #test06 stamp: 'I 5/23/2024 19:25:51'!
PASSED!

!testRun: #PortfolioTest #test07 stamp: 'I 5/23/2024 19:25:51'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioTransactionsAreCalculatedRecursively stamp: 'I 5/23/2024 19:25:51'!
PASSED!

----STARTUP---- (26 May 2024 11:08:46) as /home/ivan/Documents/Facu/Inge 1/linux64/linux64/CuisUniversity-6169.image!


!classRemoval: #ReceptiveAccount stamp: 'I 5/26/2024 11:08:50'!
Object subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Portfolio stamp: 'I 5/26/2024 11:08:50'!
Object subclass: #Portfolio
	instanceVariableNames: 'accounts portfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Withdraw stamp: 'I 5/26/2024 11:08:50'!
AccountTransaction subclass: #Withdraw
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Deposit stamp: 'I 5/26/2024 11:08:51'!
AccountTransaction subclass: #Deposit
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #AccountTransaction stamp: 'I 5/26/2024 11:08:51'!
Object subclass: #AccountTransaction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #ReceptiveAccountTest stamp: 'I 5/26/2024 11:08:51'!
TestCase subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #PortfolioTest stamp: 'I 5/26/2024 11:08:52'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #PortfolioTest category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:52'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #PortfolioTest category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:52'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/16/2024 11:33:49'!
test01
	|portfolio|
	
	portfolio  := Portfolio new.
	
	self assert: 0 equals: portfolio balance.! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/16/2024 12:24:15'!
test02
	|portfolio account deposit|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio new.
	portfolio addAcount: account.

	
	self assert: 100 equals:( portfolio balance).! !
!PortfolioTest methodsFor: 'tests' stamp: 'i 5/16/2024 21:03:46'!
test03
	|portfolio account deposit portfolio2 account2  deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio new.
	portfolio addAcount: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio new.
	portfolio2 addAcount: account2.
	
	portfolio addPortfolio: portfolio2 .


	
	self assert: 200 equals:( portfolio balance).! !
!PortfolioTest methodsFor: 'tests' stamp: 'i 5/16/2024 21:02:25'!
test04
	|portfolio account deposit portfolio2 portfolio3 account2 account3 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio new.
	portfolio addAcount: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio new.
	portfolio2 addAcount: account2.
	
	
	portfolio3  := Portfolio new.
	account3 := ReceptiveAccount new. 
	account3 register:(Withdraw  for: 50).
	portfolio3  addAcount: account3.
	portfolio2 addPortfolio: portfolio3 .
	portfolio addPortfolio: portfolio2 .
	
	
	self assert: 150 equals:( portfolio balance).! !
!PortfolioTest methodsFor: 'tests' stamp: 'i 5/16/2024 21:07:57'!
test05
	|portfolio account deposit|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio new.
	portfolio addAcount: account.

	
	self assert:( portfolio hasRegistered:deposit).! !
!PortfolioTest methodsFor: 'tests' stamp: 'i 5/16/2024 21:14:12'!
test06
	|portfolio account deposit|
	
	account := ReceptiveAccount new.
	deposit  := Deposit for: 100  .
	portfolio  := Portfolio new.
	portfolio addAcount: account.

	
	self deny:( portfolio hasRegistered:deposit).! !
!PortfolioTest methodsFor: 'tests' stamp: 'i 5/16/2024 21:23:47'!
test07
	|portfolio account deposit portfolio2 portfolio3 account2 account3 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio new.
	portfolio addAcount: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio new.
	portfolio2 addAcount: account2.
	
	
	portfolio3  := Portfolio new.
	account3 := ReceptiveAccount new. 
	account3 register:(Withdraw  for: 50).
	portfolio3  addAcount: account3.
	portfolio2 addPortfolio: portfolio3 .
	portfolio addPortfolio: portfolio2 .
	
	
	self assert: ( portfolio hasRegistered: deposit2 ).! !

!classDefinition: #ReceptiveAccountTest category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:52'!
TestCase subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccountTest category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:52'!
TestCase subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'NR 11/2/2020 17:13:44'!
test01ReceptiveAccountHaveZeroAsBalanceWhenCreated 

	| account |
	
	account := ReceptiveAccount new.

	self assert: 0 equals: account balance.
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'NR 11/2/2020 17:13:48'!
test02DepositIncreasesBalanceOnTransactionValue 

	| account |
	
	account := ReceptiveAccount  new.
	Deposit register: 100 on: account.
		
	self assert: 100 equals: account balance.
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'NR 11/2/2020 17:13:52'!
test03WithdrawDecreasesBalanceOnTransactionValue 

	| account |
	
	account := ReceptiveAccount new.
	Deposit register: 100 on: account.
	Withdraw register: 50 on: account.
		
	self assert: 50 equals: account balance.
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'HAW 5/23/2019 15:20:32'!
test04WithdrawValueMustBePositive 

	| account withdrawValue |
	
	account := ReceptiveAccount new.
	withdrawValue := 50.
	
	self assert: withdrawValue equals: (Withdraw register: withdrawValue on: account) value
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'HAW 5/23/2019 15:20:46'!
test05ReceptiveAccountKnowsRegisteredTransactions 

	| account deposit withdraw |
	
	account := ReceptiveAccount new.
	deposit := Deposit register: 100 on: account.
	withdraw := Withdraw register: 50 on: account.
		
	self assert: (account hasRegistered: deposit).
	self assert: (account hasRegistered: withdraw).
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'NR 5/17/2021 17:29:53'!
test06ReceptiveAccountDoNotKnowNotRegisteredTransactions

	| deposit withdraw account |
	
	account := ReceptiveAccount new.
	deposit :=  Deposit for: 200.
	withdraw := Withdraw for: 50.
		
	self deny: (account hasRegistered: deposit).
	self deny: (account hasRegistered:withdraw).
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'NR 11/2/2020 17:14:01'!
test07AccountKnowsItsTransactions 

	| account1 deposit1 |
	
	account1 := ReceptiveAccount new.
	
	deposit1 := Deposit register: 50 on: account1.
		
	self assert: 1 equals: account1 transactions size.
	self assert: (account1 transactions includes: deposit1).
! !

!classDefinition: #AccountTransaction category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:52'!
Object subclass: #AccountTransaction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AccountTransaction category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:52'!
Object subclass: #AccountTransaction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!AccountTransaction methodsFor: 'value' stamp: 'HernanWilkinson 9/12/2011 12:25' overrides: 16914075!
value 

	self subclassResponsibility ! !

!classDefinition: 'AccountTransaction class' category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:52'!
AccountTransaction class
	instanceVariableNames: ''!

!classDefinition: 'AccountTransaction class' category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:52'!
AccountTransaction class
	instanceVariableNames: ''!
!AccountTransaction class methodsFor: 'instance creation' stamp: 'NR 10/17/2019 03:22:00'!
register: aValue on: account

	| transaction |
	
	transaction := self for: aValue.
	account register: transaction.
		
	^ transaction! !

!classDefinition: #Deposit category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:52'!
AccountTransaction subclass: #Deposit
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Deposit category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:52'!
AccountTransaction subclass: #Deposit
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Deposit methodsFor: 'initialization' stamp: 'HernanWilkinson 7/13/2011 18:45'!
initializeFor: aValue

	value := aValue ! !
!Deposit methodsFor: 'value' stamp: 'HernanWilkinson 7/13/2011 18:38' overrides: 50605450!
value

	^ value! !
!Deposit methodsFor: 'add' stamp: 'i 5/16/2024 20:47:22'!
addTo: balance 
	^balance + value! !

!classDefinition: 'Deposit class' category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:52'!
Deposit class
	instanceVariableNames: ''!

!classDefinition: 'Deposit class' category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:52'!
Deposit class
	instanceVariableNames: ''!
!Deposit class methodsFor: 'instance creation' stamp: 'HernanWilkinson 7/13/2011 18:38' overrides: 50599915!
for: aValue

	^ self new initializeFor: aValue ! !

!classDefinition: #Withdraw category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:52'!
AccountTransaction subclass: #Withdraw
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Withdraw category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:52'!
AccountTransaction subclass: #Withdraw
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Withdraw methodsFor: 'initialization' stamp: 'HernanWilkinson 7/13/2011 18:46'!
initializeFor: aValue

	value := aValue ! !
!Withdraw methodsFor: 'value' stamp: 'HernanWilkinson 7/13/2011 18:33' overrides: 50605450!
value

	^ value! !
!Withdraw methodsFor: 'add' stamp: 'i 5/16/2024 20:47:53'!
addTo: balance 
	^balance - value! !

!classDefinition: 'Withdraw class' category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:52'!
Withdraw class
	instanceVariableNames: ''!

!classDefinition: 'Withdraw class' category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:52'!
Withdraw class
	instanceVariableNames: ''!
!Withdraw class methodsFor: 'instance creation' stamp: 'HernanWilkinson 7/13/2011 18:33' overrides: 50599915!
for: aValue

	^ self new initializeFor: aValue ! !

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:52'!
Object subclass: #Portfolio
	instanceVariableNames: 'accounts portfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:52'!
Object subclass: #Portfolio
	instanceVariableNames: 'accounts portfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'value' stamp: 'I 5/16/2024 12:39:23'!
balance
	|balance| 
	balance := 0.
	accounts do:[:account| balance := balance + account balance].
	portfolios do: [:portfolio | balance := balance + portfolio balance].
	
	^balance ! !
!Portfolio methodsFor: 'value' stamp: 'i 5/16/2024 21:21:53'!
hasRegistered: transaction
	|accum|
	accum := false.
	accounts do:[:account | accum := (account hasRegistered: transaction) or:[accum] ] .
	portfolios do:[:portfolio | accum := (portfolio hasRegistered: transaction ) or:[accum] ] .
	^accum! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/16/2024 12:20:32'!
addAcount: account 
	accounts add: account! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/16/2024 12:37:10'!
addPortfolio: portfolioToAdd 
	portfolios add: portfolioToAdd .! !
!Portfolio methodsFor: 'initialization' stamp: 'I 5/16/2024 12:22:10' overrides: 16932297!
initialize
	accounts  := OrderedCollection new.
	portfolios := OrderedCollection new.! !

!classDefinition: #ReceptiveAccount category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:52'!
Object subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:52'!
Object subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ReceptiveAccount methodsFor: 'initialization' stamp: 'NR 10/17/2019 15:06:56' overrides: 16932297!
initialize

	transactions := OrderedCollection new.! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'HernanWilkinson 7/13/2011 18:37'!
register: aTransaction

	transactions add: aTransaction 
! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'HernanWilkinson 7/13/2011 18:37'!
transactions 

	^ transactions copy! !
!ReceptiveAccount methodsFor: 'balance' stamp: 'i 5/16/2024 20:48:35'!
balance
	|balance|
	balance := 0.
	transactions do: [ :aTransaction |balance := aTransaction addTo: balance ].
	^balance ! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'NR 10/17/2019 03:28:43'!
hasRegistered: aTransaction

	^ transactions includes: aTransaction 
! !

!classDefinition: #Account category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:52'!
Object subclass: #Account
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Account category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:52'!
Object subclass: #Account
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:52'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts portfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:52'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts portfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:52'!
Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:52'!
Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'value' stamp: 'I 5/23/2024 16:17:34' prior: 50605571!
balance
	
	^ accounts sum:[:account| account balance].
	! !
!Portfolio methodsFor: 'value' stamp: 'I 5/23/2024 16:18:01' prior: 50605579!
hasRegistered: transaction
	|accum|
	accum := false.
	accounts do:[:account | accum := (account hasRegistered: transaction) or:[accum] ] .
	^accum! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 16:18:14'!
add: account 
	accounts add: account! !
!Portfolio methodsFor: 'initialization' stamp: 'I 5/23/2024 16:50:37' prior: 50605598 overrides: 16932297!
initialize
	| parents |
	accounts  := OrderedCollection new.
	parents := OrderedCollection new.! !

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:52'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:52'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'initialization' stamp: 'I 5/23/2024 16:51:28' prior: 50605709 overrides: 16932297!
initialize

	accounts  := OrderedCollection new.
! !

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:53'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:53'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'initialization' stamp: 'I 5/23/2024 16:51:44' prior: 50605731 overrides: 16932297!
initialize

	accounts  := OrderedCollection new.
	parents  := OrderedCollection new
! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 16:52:01' prior: 50605704!
add: account 
	self canAddanAccount: account.
	accounts add: account! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 16:53:16' prior: 50605758!
add: account 
	self canAddanAccount: account.
	
	accounts add: account.
	
	account addRotParent: self.
	! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 16:53:24' prior: 50605763!
add: account 
	self canAddanAccount: account.
	
	accounts add: account.
	
	account addRootParent: self.
	! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 17:14:10' prior: 50605769!
add: account 
	self canAddAnAccount: account.
	
	accounts add: account! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 17:14:18' prior: 50605775!
add: account 

	self canAddAnAccount: account.
	
	accounts add: account.
	
	account addRootParent: self.
	! !
!Portfolio class methodsFor: 'nil' stamp: 'I 5/23/2024 17:14:44'!
with: anAccount
	^self new add: anAccount.! !
!Portfolio methodsFor: 'value' stamp: 'I 5/23/2024 17:19:04' prior: 50605692!
balance
	
	^ accounts sum:[:account| account balance]ifEmpty: [^0].
	! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:19:16' prior: 50605254!
test02
	|portfolio account deposit|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio with: account.

	
	self assert: 100 equals:( portfolio balance).! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 17:20:14'!
canAddAnAccount: account 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 17:23:34' prior: 50605804!
canAddAnAccount: account 
	(parents anySatisfy: [:anAccount| (anAccount has:account) or:[anAccount canAddAnAccount: account ]]) ifTrue: [self class error: self class cannotAddRepetitiveAccount].! !
!ReceptiveAccount methodsFor: 'boolean' stamp: 'I 5/23/2024 17:25:15'!
addRootParent: aPortfolio 
	self shouldBeImplemented.! !

!classDefinition: #ReceptiveAccount category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:53'!
Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:53'!
Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ReceptiveAccount methodsFor: 'boolean' stamp: 'I 5/23/2024 17:25:47' prior: 50605818!
addRootParent: aPortfolio 
	parents add: aPortfolio.! !
!ReceptiveAccount methodsFor: 'initialization' stamp: 'I 5/23/2024 17:28:30' prior: 50605620 overrides: 16932297!
initialize

	transactions := OrderedCollection new.
	parents := OrderedCollection new.! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:29:17' prior: 50605264!
test03
	|portfolio account deposit portfolio2 account2  deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio with: account2.
	
	portfolio add: portfolio2 .


	
	self assert: 200 equals:( portfolio balance).! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 17:29:33'!
addRootParent: aPortfolio 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 17:33:14' prior: 50605866!
addRootParent: anAccount
	parents add: anAccount 
	! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:33:40' prior: 50605851!
test03
	|portfolio account deposit portfolio2 account2  deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio with: account2.
	
	portfolio add: portfolio2 .


	
	self assert: 200 equals:( portfolio balance).
	self assert: (portfolio hasRegistered: deposit2 )! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:34:05' prior: 50605876!
test03
	|portfolio account deposit portfolio2 account2  deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio with: account2.
	
	portfolio add: portfolio2 .


	
	self assert: 200 equals:( portfolio balance).
	self assert: (portfolio hasRegistered: deposit2 ).
	self deny: (portfolio2 hasRegistered: deposit )! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:35:05' prior: 50605281!
test04
	|portfolio account deposit portfolio2 portfolio3 account2 account3 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio with: account2.
	
	
	
	account3 := ReceptiveAccount new. 
	
	account3 register:(Withdraw  for: 50).
	portfolio3  := Portfolio with: account3 .
	portfolio3  addAcount: account3.
	portfolio2 addPortfolio: portfolio3 .
	portfolio addPortfolio: portfolio2 .
	
	
	self assert: 150 equals:( portfolio balance).! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:35:33' prior: 50605912!
test04
	|portfolio account deposit portfolio2 portfolio3 account2 account3 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio with: account2.
	
	
	
	account3 := ReceptiveAccount new. 
	account3 register:(Withdraw  for: 50).
	portfolio3  := Portfolio with: account3 .
	portfolio2 add: portfolio3 .
	portfolio add: portfolio2 .
	
	
	self assert: 150 equals:( portfolio balance).! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 17:40:44' prior: 50605809!
canAddAnAccount: account 
	((parents anySatisfy: [:anAccount| (anAccount hasAccount:account) or:[anAccount canAddAnAccount: account ]])
	or:[accounts anySatisfy: [:anAccount| (anAccount =account )or:[anAccount canAddAccount: account] ]]) 
	ifTrue: [self class error: self class cannotAddRepetitiveAccount].! !
!ReceptiveAccount methodsFor: 'boolean' stamp: 'I 5/23/2024 17:41:32'!
canAddAccount: account 
	self shouldBeImplemented.! !
!ReceptiveAccount methodsFor: 'boolean' stamp: 'I 5/23/2024 17:41:37' prior: 50605968!
canAddAccount: account 
	^false! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:46:33' prior: 50605323!
test07
	|compoundPortfolio account deposit portfolio2 portfolio3 account2 account3 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	compoundPortfolio  := Portfolio new.
	compoundPortfolio addAcount: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio new.
	portfolio2 addAcount: account2.
	
	
	portfolio3  := Portfolio new.
	account3 := ReceptiveAccount new. 
	account3 register:(Withdraw  for: 50).
	portfolio3  addAcount: account3.
	portfolio2 addPortfolio: portfolio3 .
	compoundPortfolio addPortfolio: portfolio2 .
	
	
	self assert: ( compoundPortfolio hasRegistered: deposit2 ).! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:47:04' prior: 50605977!
test07
	|compoundPortfolio account deposit simplePortfolio portfolio3 account2 account3 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	compoundPortfolio  := Portfolio new.
	compoundPortfolio addAcount: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	simplePortfolio  := Portfolio new.
	simplePortfolio addAcount: account2.
	
	
	portfolio3  := Portfolio new.
	account3 := ReceptiveAccount new. 
	account3 register:(Withdraw  for: 50).
	portfolio3  addAcount: account3.
	simplePortfolio addPortfolio: portfolio3 .
	compoundPortfolio addPortfolio: simplePortfolio .
	
	
	self assert: ( compoundPortfolio hasRegistered: deposit2 ).! !
!Portfolio class methodsFor: 'as yet unclassified' stamp: 'I 5/23/2024 17:50:29'!
cannotAddRepetitiveAccount
	^'Can put repetitive accounts'! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:50:36' prior: 50606002!
test07
	|compoundPortfolio account deposit simplePortfolio account2 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	compoundPortfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	simplePortfolio  := Portfolio with: account2.
	
	compoundPortfolio add: simplePortfolio. 
	
	
	self should:[simplePortfolio add: account ] 
	raise: Error - Message 
	description: [self assert: Portfolio cannotAddRepetitiveAccount ].! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:51:05' prior: 50606033!
test07
	|compoundPortfolio account deposit simplePortfolio account2 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	compoundPortfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	simplePortfolio  := Portfolio with: account2.
	
	compoundPortfolio add: simplePortfolio. 
	
	
	self should:[simplePortfolio add: account ] 
	raise: Error 
	description: [self assert: Portfolio cannotAddRepetitiveAccount ].! !
!Portfolio methodsFor: 'boolean' stamp: 'I 5/23/2024 17:52:09'!
hasAccount: account 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'boolean' stamp: 'I 5/23/2024 17:52:52' prior: 50606072!
hasAccount: anAccount 
	^accounts anySatisfy: [:account | account = anAccount ]! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 18:11:09' prior: 50605956!
canAddAnAccount: account 
	((parents anySatisfy: [:anAccount| (anAccount hasAccount:account) or:[anAccount canAddAnAccount: account ]])
	or:[accounts anySatisfy: [:anAccount| (anAccount =account )or:[anAccount canAddAccount: account] ]]) 
	ifTrue: [^self class error: self class cannotAddRepetitiveAccount].! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 18:31:59' prior: 50606053!
test07
	|compoundPortfolio account deposit simplePortfolio account2 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	compoundPortfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	simplePortfolio  := Portfolio with: account2.
	
	compoundPortfolio add: simplePortfolio. 
	
	
	self should:[simplePortfolio add: account ] 
	raise: Error 
	description: [:anError |
			self assert: Portfolio cannotAddRepetitiveAccount equals: anError messageText.].! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 18:32:45' prior: 50606096!
test07
	|compoundPortfolio account deposit simplePortfolio account2 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	compoundPortfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	simplePortfolio  := Portfolio with: account2.
	
	compoundPortfolio add: simplePortfolio. 
	
	
	self should:[simplePortfolio add: account ] 
	raise: Error - MessageNotUnderstood 
	description: [:anError |
			self assert: Portfolio cannotAddRepetitiveAccount equals: anError messageText.].! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 18:33:24' prior: 50606117!
test07
	|compoundPortfolio account deposit simplePortfolio account2 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	compoundPortfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	simplePortfolio  := Portfolio with: account2.
	
	compoundPortfolio add: simplePortfolio. 
	
	
	self should:[simplePortfolio add: account ] 
	raise: Error - MessageNotUnderstood 
	description: [:anError |
			self assert: Portfolio cannotAddRepetitiveAccount equals: anError messageText.
			self assert: (compoundPortfolio hasRegistered: deposit2 )].! !

!methodRemoval: Portfolio #addPortfolio: stamp: 'I 5/26/2024 11:08:53'!
addPortfolio: portfolioToAdd 
	portfolios add: portfolioToAdd .!
!Portfolio methodsFor: 'nil' stamp: 'I 5/23/2024 18:45:06'!
transactions! !
!Portfolio methodsFor: 'transactions' stamp: 'I 5/23/2024 18:46:43' prior: 50606166!
transactions
	|transactionsList|
	
	transactionsList := Set new.
	
	accounts do: [:anAccount | transactionsList addTransaction: anAccount].
	

	^transactionsList .! !
!Portfolio methodsFor: 'transactions' stamp: 'I 5/23/2024 18:46:52' prior: 50606170!
transactions
	|transactionsList|
	
	transactionsList := Set new.
	
	accounts do: [:anAccount | transactionsList addTransactionTo: anAccount].
	

	^transactionsList .! !
!Portfolio methodsFor: 'transactions' stamp: 'I 5/23/2024 18:47:00' prior: 50606178!
transactions
	|transactionsList|
	
	transactionsList := Set new.
	
	accounts do: [:anAccount | transactionsList addTransactionFrom: anAccount].
	

	^transactionsList .! !
!Portfolio methodsFor: 'transactions' stamp: 'I 5/23/2024 18:47:37' prior: 50606186!
transactions
	|transactionsList|
	
	transactionsList := Set new.
	
	accounts do: [:anAccount | anAccount addTransactionTo: transactionsList ].
	

	^transactionsList .! !
!Portfolio methodsFor: 'transactions' stamp: 'I 5/23/2024 18:59:36' prior: 50606194!
transactions
	|transactionsList|
	
	transactionsList := Set new.
	
	accounts do: [:anAccount | anAccount addTransactionsTo: transactionsList ].
	

	^transactionsList .! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 19:00:21'!
addTransactionsTo: transactions
	accounts do: [:anAccount | anAccount addTransactionsTo: transactions].! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'I 5/23/2024 19:01:12'!
addTransactionsTo: transactionsList
	transactions do: [:transaction | transactionsList add: transaction ].! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 19:02:52'!
test08PortfolioTransactionsAreCalculatedRecursively

	| simplePortfolioAccount simplePortfolio composedPortfolioAccount composedPortfolio composedPortfolioAccountWithdraw simplePortfolioAccountDeposit composedPortfolioTransactions |
	
	simplePortfolioAccount := ReceptiveAccount new.
	simplePortfolioAccountDeposit := Deposit register: 100 on: simplePortfolioAccount.
	simplePortfolio := Portfolio with: simplePortfolioAccount.
	
	composedPortfolioAccount := ReceptiveAccount new.
	composedPortfolioAccountWithdraw := Withdraw register: 50 on: composedPortfolioAccount.
	composedPortfolio := Portfolio with: simplePortfolio with: composedPortfolioAccount.
	
	composedPortfolioTransactions := composedPortfolio transactions.
	self assert: 2 equals: composedPortfolioTransactions size.
	self assert: (composedPortfolioTransactions includes: simplePortfolioAccountDeposit).
	self assert: (composedPortfolioTransactions includes: composedPortfolioAccountWithdraw)! !
!Portfolio class methodsFor: 'as yet unclassified' stamp: 'I 5/23/2024 19:03:24'!
with: anAccount with: anotherAccount
	^self new add: anAccount; add: anotherAccount .! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 19:05:48' prior: 50606083!
canAddAnAccount: account 
	((parents anySatisfy: [:anAccount| (anAccount hasAccount:account) or:[anAccount canAddAnAccount: account ]])
	or:[accounts anySatisfy: [:anAccount| (anAccount =account )or:[anAccount canAddAnAccount: account] ]]) 
	ifTrue: [^self class error: self class cannotAddRepetitiveAccount].! !

!classRemoval: #ReceptiveAccount stamp: 'I 5/26/2024 11:08:53'!
Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Portfolio stamp: 'I 5/26/2024 11:08:54'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Withdraw stamp: 'I 5/26/2024 11:08:54'!
AccountTransaction subclass: #Withdraw
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Deposit stamp: 'I 5/26/2024 11:08:54'!
AccountTransaction subclass: #Deposit
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #AccountTransaction stamp: 'I 5/26/2024 11:08:55'!
Object subclass: #AccountTransaction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #ReceptiveAccountTest stamp: 'I 5/26/2024 11:08:55'!
TestCase subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #PortfolioTest stamp: 'I 5/26/2024 11:08:55'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #PortfolioTest category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:55'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #PortfolioTest category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:55'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/16/2024 11:33:49'!
test01
	|portfolio|
	
	portfolio  := Portfolio new.
	
	self assert: 0 equals: portfolio balance.! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/16/2024 12:24:15'!
test02
	|portfolio account deposit|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio new.
	portfolio addAcount: account.

	
	self assert: 100 equals:( portfolio balance).! !
!PortfolioTest methodsFor: 'tests' stamp: 'i 5/16/2024 21:03:46'!
test03
	|portfolio account deposit portfolio2 account2  deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio new.
	portfolio addAcount: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio new.
	portfolio2 addAcount: account2.
	
	portfolio addPortfolio: portfolio2 .


	
	self assert: 200 equals:( portfolio balance).! !
!PortfolioTest methodsFor: 'tests' stamp: 'i 5/16/2024 21:02:25'!
test04
	|portfolio account deposit portfolio2 portfolio3 account2 account3 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio new.
	portfolio addAcount: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio new.
	portfolio2 addAcount: account2.
	
	
	portfolio3  := Portfolio new.
	account3 := ReceptiveAccount new. 
	account3 register:(Withdraw  for: 50).
	portfolio3  addAcount: account3.
	portfolio2 addPortfolio: portfolio3 .
	portfolio addPortfolio: portfolio2 .
	
	
	self assert: 150 equals:( portfolio balance).! !
!PortfolioTest methodsFor: 'tests' stamp: 'i 5/16/2024 21:07:57'!
test05
	|portfolio account deposit|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio new.
	portfolio addAcount: account.

	
	self assert:( portfolio hasRegistered:deposit).! !
!PortfolioTest methodsFor: 'tests' stamp: 'i 5/16/2024 21:14:12'!
test06
	|portfolio account deposit|
	
	account := ReceptiveAccount new.
	deposit  := Deposit for: 100  .
	portfolio  := Portfolio new.
	portfolio addAcount: account.

	
	self deny:( portfolio hasRegistered:deposit).! !
!PortfolioTest methodsFor: 'tests' stamp: 'i 5/16/2024 21:23:47'!
test07
	|portfolio account deposit portfolio2 portfolio3 account2 account3 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio new.
	portfolio addAcount: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio new.
	portfolio2 addAcount: account2.
	
	
	portfolio3  := Portfolio new.
	account3 := ReceptiveAccount new. 
	account3 register:(Withdraw  for: 50).
	portfolio3  addAcount: account3.
	portfolio2 addPortfolio: portfolio3 .
	portfolio addPortfolio: portfolio2 .
	
	
	self assert: ( portfolio hasRegistered: deposit2 ).! !

!classDefinition: #ReceptiveAccountTest category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:56'!
TestCase subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccountTest category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:56'!
TestCase subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'NR 11/2/2020 17:13:44'!
test01ReceptiveAccountHaveZeroAsBalanceWhenCreated 

	| account |
	
	account := ReceptiveAccount new.

	self assert: 0 equals: account balance.
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'NR 11/2/2020 17:13:48'!
test02DepositIncreasesBalanceOnTransactionValue 

	| account |
	
	account := ReceptiveAccount  new.
	Deposit register: 100 on: account.
		
	self assert: 100 equals: account balance.
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'NR 11/2/2020 17:13:52'!
test03WithdrawDecreasesBalanceOnTransactionValue 

	| account |
	
	account := ReceptiveAccount new.
	Deposit register: 100 on: account.
	Withdraw register: 50 on: account.
		
	self assert: 50 equals: account balance.
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'HAW 5/23/2019 15:20:32'!
test04WithdrawValueMustBePositive 

	| account withdrawValue |
	
	account := ReceptiveAccount new.
	withdrawValue := 50.
	
	self assert: withdrawValue equals: (Withdraw register: withdrawValue on: account) value
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'HAW 5/23/2019 15:20:46'!
test05ReceptiveAccountKnowsRegisteredTransactions 

	| account deposit withdraw |
	
	account := ReceptiveAccount new.
	deposit := Deposit register: 100 on: account.
	withdraw := Withdraw register: 50 on: account.
		
	self assert: (account hasRegistered: deposit).
	self assert: (account hasRegistered: withdraw).
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'NR 5/17/2021 17:29:53'!
test06ReceptiveAccountDoNotKnowNotRegisteredTransactions

	| deposit withdraw account |
	
	account := ReceptiveAccount new.
	deposit :=  Deposit for: 200.
	withdraw := Withdraw for: 50.
		
	self deny: (account hasRegistered: deposit).
	self deny: (account hasRegistered:withdraw).
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'NR 11/2/2020 17:14:01'!
test07AccountKnowsItsTransactions 

	| account1 deposit1 |
	
	account1 := ReceptiveAccount new.
	
	deposit1 := Deposit register: 50 on: account1.
		
	self assert: 1 equals: account1 transactions size.
	self assert: (account1 transactions includes: deposit1).
! !

!classDefinition: #AccountTransaction category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:56'!
Object subclass: #AccountTransaction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AccountTransaction category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:56'!
Object subclass: #AccountTransaction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!AccountTransaction methodsFor: 'value' stamp: 'HernanWilkinson 9/12/2011 12:25' overrides: 16914075!
value 

	self subclassResponsibility ! !

!classDefinition: 'AccountTransaction class' category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:56'!
AccountTransaction class
	instanceVariableNames: ''!

!classDefinition: 'AccountTransaction class' category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:56'!
AccountTransaction class
	instanceVariableNames: ''!
!AccountTransaction class methodsFor: 'instance creation' stamp: 'NR 10/17/2019 03:22:00'!
register: aValue on: account

	| transaction |
	
	transaction := self for: aValue.
	account register: transaction.
		
	^ transaction! !

!classDefinition: #Deposit category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:56'!
AccountTransaction subclass: #Deposit
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Deposit category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:56'!
AccountTransaction subclass: #Deposit
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Deposit methodsFor: 'initialization' stamp: 'HernanWilkinson 7/13/2011 18:45'!
initializeFor: aValue

	value := aValue ! !
!Deposit methodsFor: 'value' stamp: 'HernanWilkinson 7/13/2011 18:38' overrides: 50606537!
value

	^ value! !
!Deposit methodsFor: 'add' stamp: 'i 5/16/2024 20:47:22'!
addTo: balance 
	^balance + value! !

!classDefinition: 'Deposit class' category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:56'!
Deposit class
	instanceVariableNames: ''!

!classDefinition: 'Deposit class' category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:56'!
Deposit class
	instanceVariableNames: ''!
!Deposit class methodsFor: 'instance creation' stamp: 'HernanWilkinson 7/13/2011 18:38' overrides: 50599915!
for: aValue

	^ self new initializeFor: aValue ! !

!classDefinition: #Withdraw category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:56'!
AccountTransaction subclass: #Withdraw
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Withdraw category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:56'!
AccountTransaction subclass: #Withdraw
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Withdraw methodsFor: 'initialization' stamp: 'HernanWilkinson 7/13/2011 18:46'!
initializeFor: aValue

	value := aValue ! !
!Withdraw methodsFor: 'value' stamp: 'HernanWilkinson 7/13/2011 18:33' overrides: 50606537!
value

	^ value! !
!Withdraw methodsFor: 'add' stamp: 'i 5/16/2024 20:47:53'!
addTo: balance 
	^balance - value! !

!classDefinition: 'Withdraw class' category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:56'!
Withdraw class
	instanceVariableNames: ''!

!classDefinition: 'Withdraw class' category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:56'!
Withdraw class
	instanceVariableNames: ''!
!Withdraw class methodsFor: 'instance creation' stamp: 'HernanWilkinson 7/13/2011 18:33' overrides: 50599915!
for: aValue

	^ self new initializeFor: aValue ! !

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:56'!
Object subclass: #Portfolio
	instanceVariableNames: 'accounts portfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:56'!
Object subclass: #Portfolio
	instanceVariableNames: 'accounts portfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'value' stamp: 'I 5/16/2024 12:39:23'!
balance
	|balance| 
	balance := 0.
	accounts do:[:account| balance := balance + account balance].
	portfolios do: [:portfolio | balance := balance + portfolio balance].
	
	^balance ! !
!Portfolio methodsFor: 'value' stamp: 'i 5/16/2024 21:21:53'!
hasRegistered: transaction
	|accum|
	accum := false.
	accounts do:[:account | accum := (account hasRegistered: transaction) or:[accum] ] .
	portfolios do:[:portfolio | accum := (portfolio hasRegistered: transaction ) or:[accum] ] .
	^accum! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/16/2024 12:20:32'!
addAcount: account 
	accounts add: account! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/16/2024 12:37:10'!
addPortfolio: portfolioToAdd 
	portfolios add: portfolioToAdd .! !
!Portfolio methodsFor: 'initialization' stamp: 'I 5/16/2024 12:22:10' overrides: 16932297!
initialize
	accounts  := OrderedCollection new.
	portfolios := OrderedCollection new.! !

!classDefinition: #ReceptiveAccount category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:56'!
Object subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:56'!
Object subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ReceptiveAccount methodsFor: 'initialization' stamp: 'NR 10/17/2019 15:06:56' overrides: 16932297!
initialize

	transactions := OrderedCollection new.! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'HernanWilkinson 7/13/2011 18:37'!
register: aTransaction

	transactions add: aTransaction 
! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'HernanWilkinson 7/13/2011 18:37'!
transactions 

	^ transactions copy! !
!ReceptiveAccount methodsFor: 'balance' stamp: 'i 5/16/2024 20:48:35'!
balance
	|balance|
	balance := 0.
	transactions do: [ :aTransaction |balance := aTransaction addTo: balance ].
	^balance ! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'NR 10/17/2019 03:28:43'!
hasRegistered: aTransaction

	^ transactions includes: aTransaction 
! !

!classDefinition: #Account category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:56'!
Object subclass: #Account
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Account category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:56'!
Object subclass: #Account
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:56'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts portfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:56'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts portfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:56'!
Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:56'!
Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'value' stamp: 'I 5/23/2024 16:17:34' prior: 50606658!
balance
	
	^ accounts sum:[:account| account balance].
	! !
!Portfolio methodsFor: 'value' stamp: 'I 5/23/2024 16:18:01' prior: 50606666!
hasRegistered: transaction
	|accum|
	accum := false.
	accounts do:[:account | accum := (account hasRegistered: transaction) or:[accum] ] .
	^accum! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 16:18:14'!
add: account 
	accounts add: account! !
!Portfolio methodsFor: 'initialization' stamp: 'I 5/23/2024 16:50:37' prior: 50606685 overrides: 16932297!
initialize
	| parents |
	accounts  := OrderedCollection new.
	parents := OrderedCollection new.! !

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:56'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:56'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts parent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'initialization' stamp: 'I 5/23/2024 16:51:28' prior: 50606796 overrides: 16932297!
initialize

	accounts  := OrderedCollection new.
! !

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:56'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Portfolio category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:56'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Portfolio methodsFor: 'initialization' stamp: 'I 5/23/2024 16:51:44' prior: 50606818 overrides: 16932297!
initialize

	accounts  := OrderedCollection new.
	parents  := OrderedCollection new
! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 16:52:01' prior: 50606791!
add: account 
	self canAddanAccount: account.
	accounts add: account! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 16:53:16' prior: 50606845!
add: account 
	self canAddanAccount: account.
	
	accounts add: account.
	
	account addRotParent: self.
	! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 16:53:24' prior: 50606850!
add: account 
	self canAddanAccount: account.
	
	accounts add: account.
	
	account addRootParent: self.
	! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 17:14:10' prior: 50606856!
add: account 
	self canAddAnAccount: account.
	
	accounts add: account! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 17:14:18' prior: 50606862!
add: account 

	self canAddAnAccount: account.
	
	accounts add: account.
	
	account addRootParent: self.
	! !
!Portfolio class methodsFor: 'nil' stamp: 'I 5/23/2024 17:14:44'!
with: anAccount
	^self new add: anAccount.! !
!Portfolio methodsFor: 'value' stamp: 'I 5/23/2024 17:19:04' prior: 50606779!
balance
	
	^ accounts sum:[:account| account balance]ifEmpty: [^0].
	! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:19:16' prior: 50606341!
test02
	|portfolio account deposit|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio with: account.

	
	self assert: 100 equals:( portfolio balance).! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 17:20:14'!
canAddAnAccount: account 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 17:23:34' prior: 50606891!
canAddAnAccount: account 
	(parents anySatisfy: [:anAccount| (anAccount has:account) or:[anAccount canAddAnAccount: account ]]) ifTrue: [self class error: self class cannotAddRepetitiveAccount].! !
!ReceptiveAccount methodsFor: 'boolean' stamp: 'I 5/23/2024 17:25:15'!
addRootParent: aPortfolio 
	self shouldBeImplemented.! !

!classDefinition: #ReceptiveAccount category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:57'!
Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 11:08:57'!
Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ReceptiveAccount methodsFor: 'boolean' stamp: 'I 5/23/2024 17:25:47' prior: 50606905!
addRootParent: aPortfolio 
	parents add: aPortfolio.! !
!ReceptiveAccount methodsFor: 'initialization' stamp: 'I 5/23/2024 17:28:30' prior: 50606707 overrides: 16932297!
initialize

	transactions := OrderedCollection new.
	parents := OrderedCollection new.! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:29:17' prior: 50606351!
test03
	|portfolio account deposit portfolio2 account2  deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio with: account2.
	
	portfolio add: portfolio2 .


	
	self assert: 200 equals:( portfolio balance).! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 17:29:33'!
addRootParent: aPortfolio 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 17:33:14' prior: 50606953!
addRootParent: anAccount
	parents add: anAccount 
	! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:33:40' prior: 50606938!
test03
	|portfolio account deposit portfolio2 account2  deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio with: account2.
	
	portfolio add: portfolio2 .


	
	self assert: 200 equals:( portfolio balance).
	self assert: (portfolio hasRegistered: deposit2 )! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:34:05' prior: 50606963!
test03
	|portfolio account deposit portfolio2 account2  deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio with: account2.
	
	portfolio add: portfolio2 .


	
	self assert: 200 equals:( portfolio balance).
	self assert: (portfolio hasRegistered: deposit2 ).
	self deny: (portfolio2 hasRegistered: deposit )! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:35:05' prior: 50606368!
test04
	|portfolio account deposit portfolio2 portfolio3 account2 account3 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio with: account2.
	
	
	
	account3 := ReceptiveAccount new. 
	
	account3 register:(Withdraw  for: 50).
	portfolio3  := Portfolio with: account3 .
	portfolio3  addAcount: account3.
	portfolio2 addPortfolio: portfolio3 .
	portfolio addPortfolio: portfolio2 .
	
	
	self assert: 150 equals:( portfolio balance).! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:35:33' prior: 50606999!
test04
	|portfolio account deposit portfolio2 portfolio3 account2 account3 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	portfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio with: account2.
	
	
	
	account3 := ReceptiveAccount new. 
	account3 register:(Withdraw  for: 50).
	portfolio3  := Portfolio with: account3 .
	portfolio2 add: portfolio3 .
	portfolio add: portfolio2 .
	
	
	self assert: 150 equals:( portfolio balance).! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 17:40:44' prior: 50606896!
canAddAnAccount: account 
	((parents anySatisfy: [:anAccount| (anAccount hasAccount:account) or:[anAccount canAddAnAccount: account ]])
	or:[accounts anySatisfy: [:anAccount| (anAccount =account )or:[anAccount canAddAccount: account] ]]) 
	ifTrue: [self class error: self class cannotAddRepetitiveAccount].! !
!ReceptiveAccount methodsFor: 'boolean' stamp: 'I 5/23/2024 17:41:32'!
canAddAccount: account 
	self shouldBeImplemented.! !
!ReceptiveAccount methodsFor: 'boolean' stamp: 'I 5/23/2024 17:41:37' prior: 50607055!
canAddAccount: account 
	^false! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:46:33' prior: 50606410!
test07
	|compoundPortfolio account deposit portfolio2 portfolio3 account2 account3 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	compoundPortfolio  := Portfolio new.
	compoundPortfolio addAcount: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	portfolio2  := Portfolio new.
	portfolio2 addAcount: account2.
	
	
	portfolio3  := Portfolio new.
	account3 := ReceptiveAccount new. 
	account3 register:(Withdraw  for: 50).
	portfolio3  addAcount: account3.
	portfolio2 addPortfolio: portfolio3 .
	compoundPortfolio addPortfolio: portfolio2 .
	
	
	self assert: ( compoundPortfolio hasRegistered: deposit2 ).! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:47:04' prior: 50607064!
test07
	|compoundPortfolio account deposit simplePortfolio portfolio3 account2 account3 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	compoundPortfolio  := Portfolio new.
	compoundPortfolio addAcount: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	simplePortfolio  := Portfolio new.
	simplePortfolio addAcount: account2.
	
	
	portfolio3  := Portfolio new.
	account3 := ReceptiveAccount new. 
	account3 register:(Withdraw  for: 50).
	portfolio3  addAcount: account3.
	simplePortfolio addPortfolio: portfolio3 .
	compoundPortfolio addPortfolio: simplePortfolio .
	
	
	self assert: ( compoundPortfolio hasRegistered: deposit2 ).! !
!Portfolio class methodsFor: 'as yet unclassified' stamp: 'I 5/23/2024 17:50:29'!
cannotAddRepetitiveAccount
	^'Can put repetitive accounts'! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:50:36' prior: 50607089!
test07
	|compoundPortfolio account deposit simplePortfolio account2 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	compoundPortfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	simplePortfolio  := Portfolio with: account2.
	
	compoundPortfolio add: simplePortfolio. 
	
	
	self should:[simplePortfolio add: account ] 
	raise: Error - Message 
	description: [self assert: Portfolio cannotAddRepetitiveAccount ].! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 17:51:05' prior: 50607120!
test07
	|compoundPortfolio account deposit simplePortfolio account2 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	compoundPortfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	simplePortfolio  := Portfolio with: account2.
	
	compoundPortfolio add: simplePortfolio. 
	
	
	self should:[simplePortfolio add: account ] 
	raise: Error 
	description: [self assert: Portfolio cannotAddRepetitiveAccount ].! !
!Portfolio methodsFor: 'boolean' stamp: 'I 5/23/2024 17:52:09'!
hasAccount: account 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'boolean' stamp: 'I 5/23/2024 17:52:52' prior: 50607159!
hasAccount: anAccount 
	^accounts anySatisfy: [:account | account = anAccount ]! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 18:11:09' prior: 50607043!
canAddAnAccount: account 
	((parents anySatisfy: [:anAccount| (anAccount hasAccount:account) or:[anAccount canAddAnAccount: account ]])
	or:[accounts anySatisfy: [:anAccount| (anAccount =account )or:[anAccount canAddAccount: account] ]]) 
	ifTrue: [^self class error: self class cannotAddRepetitiveAccount].! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 18:31:59' prior: 50607140!
test07
	|compoundPortfolio account deposit simplePortfolio account2 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	compoundPortfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	simplePortfolio  := Portfolio with: account2.
	
	compoundPortfolio add: simplePortfolio. 
	
	
	self should:[simplePortfolio add: account ] 
	raise: Error 
	description: [:anError |
			self assert: Portfolio cannotAddRepetitiveAccount equals: anError messageText.].! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 18:32:45' prior: 50607183!
test07
	|compoundPortfolio account deposit simplePortfolio account2 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	compoundPortfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	simplePortfolio  := Portfolio with: account2.
	
	compoundPortfolio add: simplePortfolio. 
	
	
	self should:[simplePortfolio add: account ] 
	raise: Error - MessageNotUnderstood 
	description: [:anError |
			self assert: Portfolio cannotAddRepetitiveAccount equals: anError messageText.].! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 18:33:24' prior: 50607204!
test07
	|compoundPortfolio account deposit simplePortfolio account2 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	compoundPortfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	simplePortfolio  := Portfolio with: account2.
	
	compoundPortfolio add: simplePortfolio. 
	
	
	self should:[simplePortfolio add: account ] 
	raise: Error - MessageNotUnderstood 
	description: [:anError |
			self assert: Portfolio cannotAddRepetitiveAccount equals: anError messageText.
			self assert: (compoundPortfolio hasRegistered: deposit2 )].! !

!methodRemoval: Portfolio #addPortfolio: stamp: 'I 5/26/2024 11:08:57'!
addPortfolio: portfolioToAdd 
	portfolios add: portfolioToAdd .!
!Portfolio methodsFor: 'nil' stamp: 'I 5/23/2024 18:45:06'!
transactions! !
!Portfolio methodsFor: 'transactions' stamp: 'I 5/23/2024 18:46:43' prior: 50607253!
transactions
	|transactionsList|
	
	transactionsList := Set new.
	
	accounts do: [:anAccount | transactionsList addTransaction: anAccount].
	

	^transactionsList .! !
!Portfolio methodsFor: 'transactions' stamp: 'I 5/23/2024 18:46:52' prior: 50607257!
transactions
	|transactionsList|
	
	transactionsList := Set new.
	
	accounts do: [:anAccount | transactionsList addTransactionTo: anAccount].
	

	^transactionsList .! !
!Portfolio methodsFor: 'transactions' stamp: 'I 5/23/2024 18:47:00' prior: 50607265!
transactions
	|transactionsList|
	
	transactionsList := Set new.
	
	accounts do: [:anAccount | transactionsList addTransactionFrom: anAccount].
	

	^transactionsList .! !
!Portfolio methodsFor: 'transactions' stamp: 'I 5/23/2024 18:47:37' prior: 50607273!
transactions
	|transactionsList|
	
	transactionsList := Set new.
	
	accounts do: [:anAccount | anAccount addTransactionTo: transactionsList ].
	

	^transactionsList .! !
!Portfolio methodsFor: 'transactions' stamp: 'I 5/23/2024 18:59:36' prior: 50607281!
transactions
	|transactionsList|
	
	transactionsList := Set new.
	
	accounts do: [:anAccount | anAccount addTransactionsTo: transactionsList ].
	

	^transactionsList .! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 19:00:21'!
addTransactionsTo: transactions
	accounts do: [:anAccount | anAccount addTransactionsTo: transactions].! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'I 5/23/2024 19:01:12'!
addTransactionsTo: transactionsList
	transactions do: [:transaction | transactionsList add: transaction ].! !
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/23/2024 19:02:52'!
test08PortfolioTransactionsAreCalculatedRecursively

	| simplePortfolioAccount simplePortfolio composedPortfolioAccount composedPortfolio composedPortfolioAccountWithdraw simplePortfolioAccountDeposit composedPortfolioTransactions |
	
	simplePortfolioAccount := ReceptiveAccount new.
	simplePortfolioAccountDeposit := Deposit register: 100 on: simplePortfolioAccount.
	simplePortfolio := Portfolio with: simplePortfolioAccount.
	
	composedPortfolioAccount := ReceptiveAccount new.
	composedPortfolioAccountWithdraw := Withdraw register: 50 on: composedPortfolioAccount.
	composedPortfolio := Portfolio with: simplePortfolio with: composedPortfolioAccount.
	
	composedPortfolioTransactions := composedPortfolio transactions.
	self assert: 2 equals: composedPortfolioTransactions size.
	self assert: (composedPortfolioTransactions includes: simplePortfolioAccountDeposit).
	self assert: (composedPortfolioTransactions includes: composedPortfolioAccountWithdraw)! !
!Portfolio class methodsFor: 'as yet unclassified' stamp: 'I 5/23/2024 19:03:24'!
with: anAccount with: anotherAccount
	^self new add: anAccount; add: anotherAccount .! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 19:05:48' prior: 50607170!
canAddAnAccount: account 
	((parents anySatisfy: [:anAccount| (anAccount hasAccount:account) or:[anAccount canAddAnAccount: account ]])
	or:[accounts anySatisfy: [:anAccount| (anAccount =account )or:[anAccount canAddAnAccount: account] ]]) 
	ifTrue: [^self class error: self class cannotAddRepetitiveAccount].! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 19:10:28' prior: 50607348!
canAddAnAccount: account 
	((self parentsHaveAnAccount: account)
	or:[accounts anySatisfy: [:anAccount| (anAccount =account )or:[anAccount canAddAnAccount: account] ]]) 
	ifTrue: [^self class error: self class cannotAddRepetitiveAccount].! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 19:12:59'!
parentsHaveAnAccount: account

	^self rootsParents anySatisfy: [:aParent| aParent isComposedBy: account ].! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 19:17:40'!
addParentsTo: setOfParents

	parents ifEmpty: [setOfParents add: self]
	 ifNotEmpty: [ parents do: [ :aParent | aParent addParentsTo: setOfParents  ]].! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 19:21:52'!
rootsParents

	|rootsParents|
	
	rootsParents := Set new.
	
	self addParentsTo: rootsParents .
	
	^rootsParents ! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 19:22:45' prior: 50607377!
addParentsTo: rootsParents
	
	parents ifEmpty: [rootsParents add: self]
	 ifNotEmpty: [parents do:[:aParent| aParent addParentsTo: rootsParents ]].! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 19:24:12'!
isComposedBy: account 
	^accounts anySatisfy: [:anAccount| (anAccount = account )or:[anAccount isComposedBy: account]].! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'I 5/23/2024 19:24:29'!
isComposedBy: account
	^account = self.! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/23/2024 19:25:05' prior: 50607361!
canAddAnAccount: account 
	(self parentsHaveAnAccount: account) 	ifTrue: [^self class error: self class cannotAddRepetitiveAccount].! !
!Portfolio methodsFor: 'adding' stamp: 'I 5/26/2024 11:09:30' prior: 50607398!
isComposedBy: account 
	^accounts anySatisfy: [:anAccount| (anAccount = account )or:[anAccount isComposedBy: account] or: [account isComposedBy: anAccount ]].! !

!testRun: #PortfolioTest #test08PortfolioTransactionsAreCalculatedRecursively stamp: 'I 5/26/2024 11:09:33'!
PASSED!

!testRun: #PortfolioTest #test01 stamp: 'I 5/26/2024 11:09:35'!
PASSED!

!testRun: #PortfolioTest #test02 stamp: 'I 5/26/2024 11:09:35'!
PASSED!

!testRun: #PortfolioTest #test03 stamp: 'I 5/26/2024 11:09:35'!
PASSED!

!testRun: #PortfolioTest #test04 stamp: 'I 5/26/2024 11:09:35'!
PASSED!

!testRun: #PortfolioTest #test05 stamp: 'I 5/26/2024 11:09:35'!
PASSED!

!testRun: #PortfolioTest #test06 stamp: 'I 5/26/2024 11:09:35'!
PASSED!

!testRun: #PortfolioTest #test07 stamp: 'I 5/26/2024 11:09:35'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioTransactionsAreCalculatedRecursively stamp: 'I 5/26/2024 11:09:35'!
PASSED!
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/26/2024 11:10:13'!
test09PortfolioCanNotIncludeTheSameAccountMoreThanOnce

	| account portfolio |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio with: account.
	
	self 
		should: [ portfolio add: account ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: Portfolio canNotAddAccountErrorMessage equals: anError messageText.
			self assert: 1 equals: portfolio accountsSize.
			self assert: (portfolio accountsIncludes: account) ]! !

!testRun: #PortfolioTest #test09PortfolioCanNotIncludeTheSameAccountMoreThanOnce stamp: 'I 5/26/2024 11:10:16'!
ERROR!
!Portfolio class methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 11:10:49'!
canNotAddAccountErrorMessage
	^'Can put repetitive accounts'! !
!Portfolio methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 11:10:49' prior: 50607409!
canAddAnAccount: account 
	(self parentsHaveAnAccount: account) 	ifTrue: [^self class error: self class canNotAddAccountErrorMessage].! !
!PortfolioTest methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 11:10:49' prior: 50607226!
test07
	|compoundPortfolio account deposit simplePortfolio account2 deposit2|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	compoundPortfolio  := Portfolio with: account.
	
	account2 := ReceptiveAccount new.
	deposit2  := Deposit register: 100 on: account2 .
	simplePortfolio  := Portfolio with: account2.
	
	compoundPortfolio add: simplePortfolio. 
	
	
	self should:[simplePortfolio add: account ] 
	raise: Error - MessageNotUnderstood 
	description: [:anError |
			self assert: Portfolio canNotAddAccountErrorMessage equals: anError messageText.
			self assert: (compoundPortfolio hasRegistered: deposit2 )].! !

!methodRemoval: Portfolio class #cannotAddRepetitiveAccount stamp: 'I 5/26/2024 11:10:49'!
cannotAddRepetitiveAccount
	^'Can put repetitive accounts'!
!Portfolio class methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 11:11:05' prior: 50607468!
canNotAddAccountErrorMessage
	^'Can put repetitive accounts'! !

!testRun: #PortfolioTest #test09PortfolioCanNotIncludeTheSameAccountMoreThanOnce stamp: 'I 5/26/2024 11:11:31'!
ERROR!
!Portfolio methodsFor: 'value' stamp: 'I 5/26/2024 11:11:38'!
accountsSize
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'value' stamp: 'I 5/26/2024 11:12:54' prior: 50607518!
accountsSize
	|size|
	size := 0.
	
	accounts do:[:anAccount| size := size + anAccount  size].
	
	^size.! !
!ReceptiveAccount methodsFor: 'nil' stamp: 'I 5/26/2024 11:13:11'!
accountsSize
	^1! !

!testRun: #PortfolioTest #test09PortfolioCanNotIncludeTheSameAccountMoreThanOnce stamp: 'I 5/26/2024 11:13:37'!
ERROR!

!testRun: #PortfolioTest #test09PortfolioCanNotIncludeTheSameAccountMoreThanOnce stamp: 'I 5/26/2024 11:13:56'!
ERROR!

!testRun: #PortfolioTest #test09PortfolioCanNotIncludeTheSameAccountMoreThanOnce stamp: 'I 5/26/2024 11:14:20'!
ERROR!
!Portfolio methodsFor: 'value' stamp: 'I 5/26/2024 11:14:57' prior: 50607522!
accountsSize
	|size|
	size := 0.
	
	accounts do:[:anAccount| size := size + anAccount  accountsSize].
	
	^size.! !

!testRun: #PortfolioTest #test09PortfolioCanNotIncludeTheSameAccountMoreThanOnce stamp: 'I 5/26/2024 11:15:02'!
ERROR!
!Portfolio methodsFor: 'boolean' stamp: 'I 5/26/2024 11:15:19'!
accountsIncludes: account 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'boolean' stamp: 'I 5/26/2024 11:20:05' prior: 50607553!
accountsIncludes: account 
	^account anySatisfy: [:anAccount| (anAccount = anAccount ) or:[anAccount accountsIncludes: account ]].! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'I 5/26/2024 11:20:29'!
accountsIncludes: account 
	^self = account ! !

!testRun: #PortfolioTest #test09PortfolioCanNotIncludeTheSameAccountMoreThanOnce stamp: 'I 5/26/2024 11:20:36'!
ERROR!
!Portfolio methodsFor: 'boolean' stamp: 'I 5/26/2024 11:21:00' prior: 50607558!
accountsIncludes: account 
	^accounts anySatisfy: [:anAccount| (anAccount = anAccount ) or:[anAccount accountsIncludes: account ]].! !

!testRun: #PortfolioTest #test09PortfolioCanNotIncludeTheSameAccountMoreThanOnce stamp: 'I 5/26/2024 11:21:02'!
PASSED!

!testRun: #PortfolioTest #test01 stamp: 'I 5/26/2024 11:21:02'!
PASSED!

!testRun: #PortfolioTest #test02 stamp: 'I 5/26/2024 11:21:02'!
PASSED!

!testRun: #PortfolioTest #test03 stamp: 'I 5/26/2024 11:21:02'!
PASSED!

!testRun: #PortfolioTest #test04 stamp: 'I 5/26/2024 11:21:02'!
PASSED!

!testRun: #PortfolioTest #test05 stamp: 'I 5/26/2024 11:21:02'!
PASSED!

!testRun: #PortfolioTest #test06 stamp: 'I 5/26/2024 11:21:02'!
PASSED!

!testRun: #PortfolioTest #test07 stamp: 'I 5/26/2024 11:21:02'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioTransactionsAreCalculatedRecursively stamp: 'I 5/26/2024 11:21:02'!
PASSED!

!testRun: #PortfolioTest #test09PortfolioCanNotIncludeTheSameAccountMoreThanOnce stamp: 'I 5/26/2024 11:21:02'!
PASSED!
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/26/2024 11:21:24'!
test10PortfolioCanNotIncludeAccountOfItsPortfolios

	| account simplePortfolio composedPortfolio |
	
	account := ReceptiveAccount new.
	simplePortfolio := Portfolio with: account.
	composedPortfolio := Portfolio with: simplePortfolio.
	
	self 
		should: [ composedPortfolio add: account ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: Portfolio canNotAddAccountErrorMessage equals: anError messageText.
			self assert: 1 equals: composedPortfolio accountsSize.
			self assert: (composedPortfolio accountsIncludes: simplePortfolio) ]! !

!testRun: #PortfolioTest #test10PortfolioCanNotIncludeAccountOfItsPortfolios stamp: 'I 5/26/2024 11:21:25'!
PASSED!

!testRun: #PortfolioTest #test01 stamp: 'I 5/26/2024 11:21:25'!
PASSED!

!testRun: #PortfolioTest #test02 stamp: 'I 5/26/2024 11:21:25'!
PASSED!

!testRun: #PortfolioTest #test03 stamp: 'I 5/26/2024 11:21:25'!
PASSED!

!testRun: #PortfolioTest #test04 stamp: 'I 5/26/2024 11:21:25'!
PASSED!

!testRun: #PortfolioTest #test05 stamp: 'I 5/26/2024 11:21:25'!
PASSED!

!testRun: #PortfolioTest #test06 stamp: 'I 5/26/2024 11:21:25'!
PASSED!

!testRun: #PortfolioTest #test07 stamp: 'I 5/26/2024 11:21:25'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioTransactionsAreCalculatedRecursively stamp: 'I 5/26/2024 11:21:25'!
PASSED!

!testRun: #PortfolioTest #test09PortfolioCanNotIncludeTheSameAccountMoreThanOnce stamp: 'I 5/26/2024 11:21:25'!
PASSED!

!testRun: #PortfolioTest #test10PortfolioCanNotIncludeAccountOfItsPortfolios stamp: 'I 5/26/2024 11:21:25'!
PASSED!
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/26/2024 11:21:47'!
test11PortfolioCanNotIncludeItself

	| account simplePortfolio |
	
	account := ReceptiveAccount new.
	simplePortfolio := Portfolio with: account.
	
	self 
		should: [ simplePortfolio add: simplePortfolio ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: Portfolio canNotAddAccountErrorMessage equals: anError messageText.
			self assert: 1 equals: simplePortfolio accountsSize.
			self assert: (simplePortfolio accountsIncludes: account) ]! !

!testRun: #PortfolioTest #test11PortfolioCanNotIncludeItself stamp: 'I 5/26/2024 11:21:48'!
PASSED!

!testRun: #PortfolioTest #test01 stamp: 'I 5/26/2024 11:21:48'!
PASSED!

!testRun: #PortfolioTest #test02 stamp: 'I 5/26/2024 11:21:48'!
PASSED!

!testRun: #PortfolioTest #test03 stamp: 'I 5/26/2024 11:21:48'!
PASSED!

!testRun: #PortfolioTest #test04 stamp: 'I 5/26/2024 11:21:48'!
PASSED!

!testRun: #PortfolioTest #test05 stamp: 'I 5/26/2024 11:21:48'!
PASSED!

!testRun: #PortfolioTest #test06 stamp: 'I 5/26/2024 11:21:48'!
PASSED!

!testRun: #PortfolioTest #test07 stamp: 'I 5/26/2024 11:21:48'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioTransactionsAreCalculatedRecursively stamp: 'I 5/26/2024 11:21:48'!
PASSED!

!testRun: #PortfolioTest #test09PortfolioCanNotIncludeTheSameAccountMoreThanOnce stamp: 'I 5/26/2024 11:21:48'!
PASSED!

!testRun: #PortfolioTest #test10PortfolioCanNotIncludeAccountOfItsPortfolios stamp: 'I 5/26/2024 11:21:48'!
PASSED!

!testRun: #PortfolioTest #test11PortfolioCanNotIncludeItself stamp: 'I 5/26/2024 11:21:48'!
PASSED!
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/26/2024 11:22:09'!
test12ComposedPortfolioCanNotHaveParentPortfolioAccount

	| account simplePortfolio composedPortfolio |
	
	account := ReceptiveAccount new.
	simplePortfolio := Portfolio new.
	composedPortfolio := Portfolio with: simplePortfolio.
	composedPortfolio add: account.
	
	self 
		should: [ simplePortfolio add: account ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: Portfolio canNotAddAccountErrorMessage equals: anError messageText.
			self assert: simplePortfolio accountsIsEmpty ]! !

!testRun: #PortfolioTest #test12ComposedPortfolioCanNotHaveParentPortfolioAccount stamp: 'I 5/26/2024 11:22:10'!
ERROR!
!Portfolio methodsFor: 'testing' stamp: 'I 5/26/2024 11:22:26'!
accountsIsEmpty
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'testing' stamp: 'I 5/26/2024 11:23:07' prior: 50607732!
accountsIsEmpty
	^accounts size = 0! !

!testRun: #PortfolioTest #test12ComposedPortfolioCanNotHaveParentPortfolioAccount stamp: 'I 5/26/2024 11:23:10'!
PASSED!

!testRun: #PortfolioTest #test01 stamp: 'I 5/26/2024 11:23:11'!
PASSED!

!testRun: #PortfolioTest #test02 stamp: 'I 5/26/2024 11:23:11'!
PASSED!

!testRun: #PortfolioTest #test03 stamp: 'I 5/26/2024 11:23:11'!
PASSED!

!testRun: #PortfolioTest #test04 stamp: 'I 5/26/2024 11:23:11'!
PASSED!

!testRun: #PortfolioTest #test05 stamp: 'I 5/26/2024 11:23:11'!
PASSED!

!testRun: #PortfolioTest #test06 stamp: 'I 5/26/2024 11:23:11'!
PASSED!

!testRun: #PortfolioTest #test07 stamp: 'I 5/26/2024 11:23:11'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioTransactionsAreCalculatedRecursively stamp: 'I 5/26/2024 11:23:11'!
PASSED!

!testRun: #PortfolioTest #test09PortfolioCanNotIncludeTheSameAccountMoreThanOnce stamp: 'I 5/26/2024 11:23:11'!
PASSED!

!testRun: #PortfolioTest #test10PortfolioCanNotIncludeAccountOfItsPortfolios stamp: 'I 5/26/2024 11:23:11'!
PASSED!

!testRun: #PortfolioTest #test11PortfolioCanNotIncludeItself stamp: 'I 5/26/2024 11:23:11'!
PASSED!

!testRun: #PortfolioTest #test12ComposedPortfolioCanNotHaveParentPortfolioAccount stamp: 'I 5/26/2024 11:23:11'!
PASSED!
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/26/2024 11:23:34'!
test13ComposedPortfolioCanNotHaveAccountOfAnyRootParentRecursively

	| account leftParentPortfolio leftRootParentPortfolio portfolio rightParentPortfolio rightRootParentPortfolio |
	
	account := ReceptiveAccount new.
	portfolio := Portfolio new.
	leftParentPortfolio := Portfolio with: portfolio .
	leftRootParentPortfolio := Portfolio with: leftParentPortfolio.
	leftRootParentPortfolio add: account.
	
	rightParentPortfolio := Portfolio with: portfolio .
	rightRootParentPortfolio := Portfolio with: rightParentPortfolio.
	rightRootParentPortfolio add: account.

	self 
		should: [ portfolio add: account ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: Portfolio canNotAddAccountErrorMessage equals: anError messageText.
			self assert: portfolio accountsIsEmpty ]! !

!testRun: #PortfolioTest #test13ComposedPortfolioCanNotHaveAccountOfAnyRootParentRecursively stamp: 'I 5/26/2024 11:23:37'!
PASSED!

!testRun: #PortfolioTest #test01 stamp: 'I 5/26/2024 11:23:37'!
PASSED!

!testRun: #PortfolioTest #test02 stamp: 'I 5/26/2024 11:23:37'!
PASSED!

!testRun: #PortfolioTest #test03 stamp: 'I 5/26/2024 11:23:37'!
PASSED!

!testRun: #PortfolioTest #test04 stamp: 'I 5/26/2024 11:23:37'!
PASSED!

!testRun: #PortfolioTest #test05 stamp: 'I 5/26/2024 11:23:37'!
PASSED!

!testRun: #PortfolioTest #test06 stamp: 'I 5/26/2024 11:23:37'!
PASSED!

!testRun: #PortfolioTest #test07 stamp: 'I 5/26/2024 11:23:37'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioTransactionsAreCalculatedRecursively stamp: 'I 5/26/2024 11:23:37'!
PASSED!

!testRun: #PortfolioTest #test09PortfolioCanNotIncludeTheSameAccountMoreThanOnce stamp: 'I 5/26/2024 11:23:37'!
PASSED!

!testRun: #PortfolioTest #test10PortfolioCanNotIncludeAccountOfItsPortfolios stamp: 'I 5/26/2024 11:23:37'!
PASSED!

!testRun: #PortfolioTest #test11PortfolioCanNotIncludeItself stamp: 'I 5/26/2024 11:23:37'!
PASSED!

!testRun: #PortfolioTest #test12ComposedPortfolioCanNotHaveParentPortfolioAccount stamp: 'I 5/26/2024 11:23:37'!
PASSED!

!testRun: #PortfolioTest #test13ComposedPortfolioCanNotHaveAccountOfAnyRootParentRecursively stamp: 'I 5/26/2024 11:23:37'!
PASSED!
!PortfolioTest methodsFor: 'tests' stamp: 'I 5/26/2024 11:31:21'!
test14PortfolioCanNotIncludeAnyOfTheComposedAccountOfPortfolioToAdd

	| portfolioToAdd portfolioToModify rootPortfolio sharedAccount |
	
	sharedAccount := ReceptiveAccount new.
	portfolioToModify := Portfolio new.
	rootPortfolio := Portfolio with: sharedAccount with: portfolioToModify.
	portfolioToAdd := Portfolio with: sharedAccount.
	
	self 
		should: [ portfolioToModify add: portfolioToAdd ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | 
			self assert: Portfolio canNotAddAccountErrorMessage equals: anError messageText.
			self assert: portfolioToModify accountsIsEmpty ]! !

!testRun: #PortfolioTest #test14PortfolioCanNotIncludeAnyOfTheComposedAccountOfPortfolioToAdd stamp: 'I 5/26/2024 11:31:26'!
PASSED!

!testRun: #PortfolioTest #test01 stamp: 'I 5/26/2024 11:31:26'!
PASSED!

!testRun: #PortfolioTest #test02 stamp: 'I 5/26/2024 11:31:26'!
PASSED!

!testRun: #PortfolioTest #test03 stamp: 'I 5/26/2024 11:31:26'!
PASSED!

!testRun: #PortfolioTest #test04 stamp: 'I 5/26/2024 11:31:26'!
PASSED!

!testRun: #PortfolioTest #test05 stamp: 'I 5/26/2024 11:31:26'!
PASSED!

!testRun: #PortfolioTest #test06 stamp: 'I 5/26/2024 11:31:26'!
PASSED!

!testRun: #PortfolioTest #test07 stamp: 'I 5/26/2024 11:31:26'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioTransactionsAreCalculatedRecursively stamp: 'I 5/26/2024 11:31:26'!
PASSED!

!testRun: #PortfolioTest #test09PortfolioCanNotIncludeTheSameAccountMoreThanOnce stamp: 'I 5/26/2024 11:31:26'!
PASSED!

!testRun: #PortfolioTest #test10PortfolioCanNotIncludeAccountOfItsPortfolios stamp: 'I 5/26/2024 11:31:26'!
PASSED!

!testRun: #PortfolioTest #test11PortfolioCanNotIncludeItself stamp: 'I 5/26/2024 11:31:26'!
PASSED!

!testRun: #PortfolioTest #test12ComposedPortfolioCanNotHaveParentPortfolioAccount stamp: 'I 5/26/2024 11:31:26'!
PASSED!

!testRun: #PortfolioTest #test13ComposedPortfolioCanNotHaveAccountOfAnyRootParentRecursively stamp: 'I 5/26/2024 11:31:26'!
PASSED!

!testRun: #PortfolioTest #test14PortfolioCanNotIncludeAnyOfTheComposedAccountOfPortfolioToAdd stamp: 'I 5/26/2024 11:31:26'!
PASSED!
!Portfolio methodsFor: 'adding' stamp: 'I 5/26/2024 11:31:41' prior: 50607416!
isComposedBy: account 
	^accounts anySatisfy: [:anAccount| (anAccount = account )or:[anAccount isComposedBy: account] ].! !

!testRun: #PortfolioTest #test14PortfolioCanNotIncludeAnyOfTheComposedAccountOfPortfolioToAdd stamp: 'I 5/26/2024 11:31:42'!
FAILURE!

!testRun: #PortfolioTest #test13ComposedPortfolioCanNotHaveAccountOfAnyRootParentRecursively stamp: 'I 5/26/2024 11:31:57'!
PASSED!

!testRun: #PortfolioTest #test12ComposedPortfolioCanNotHaveParentPortfolioAccount stamp: 'I 5/26/2024 11:31:58'!
PASSED!

!testRun: #PortfolioTest #test11PortfolioCanNotIncludeItself stamp: 'I 5/26/2024 11:31:59'!
FAILURE!

!testRun: #PortfolioTest #test11PortfolioCanNotIncludeItself stamp: 'I 5/26/2024 11:31:59'!
FAILURE!

!testRun: #PortfolioTest #test11PortfolioCanNotIncludeItself stamp: 'I 5/26/2024 11:32:08'!
FAILURE!
!Portfolio methodsFor: 'adding' stamp: 'I 5/26/2024 11:33:02' prior: 50607917!
isComposedBy: account 
	^accounts anySatisfy: [:anAccount| (anAccount = account )or:[anAccount isComposedBy: account] or: [account isComposedBy: anAccount ]].! !

!testRun: #PortfolioTest #test01 stamp: 'I 5/26/2024 11:33:05'!
PASSED!

!testRun: #PortfolioTest #test02 stamp: 'I 5/26/2024 11:33:05'!
PASSED!

!testRun: #PortfolioTest #test03 stamp: 'I 5/26/2024 11:33:05'!
PASSED!

!testRun: #PortfolioTest #test04 stamp: 'I 5/26/2024 11:33:05'!
PASSED!

!testRun: #PortfolioTest #test05 stamp: 'I 5/26/2024 11:33:05'!
PASSED!

!testRun: #PortfolioTest #test06 stamp: 'I 5/26/2024 11:33:05'!
PASSED!

!testRun: #PortfolioTest #test07 stamp: 'I 5/26/2024 11:33:05'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioTransactionsAreCalculatedRecursively stamp: 'I 5/26/2024 11:33:05'!
PASSED!

!testRun: #PortfolioTest #test09PortfolioCanNotIncludeTheSameAccountMoreThanOnce stamp: 'I 5/26/2024 11:33:05'!
PASSED!

!testRun: #PortfolioTest #test10PortfolioCanNotIncludeAccountOfItsPortfolios stamp: 'I 5/26/2024 11:33:05'!
PASSED!

!testRun: #PortfolioTest #test11PortfolioCanNotIncludeItself stamp: 'I 5/26/2024 11:33:05'!
PASSED!

!testRun: #PortfolioTest #test12ComposedPortfolioCanNotHaveParentPortfolioAccount stamp: 'I 5/26/2024 11:33:05'!
PASSED!

!testRun: #PortfolioTest #test13ComposedPortfolioCanNotHaveAccountOfAnyRootParentRecursively stamp: 'I 5/26/2024 11:33:05'!
PASSED!

!testRun: #PortfolioTest #test14PortfolioCanNotIncludeAnyOfTheComposedAccountOfPortfolioToAdd stamp: 'I 5/26/2024 11:33:05'!
PASSED!

Object subclass: #Transfer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Transfer category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 12:20:24'!
Object subclass: #Transfer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Transfer subclass: #TransferLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #TransferLeg category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 12:21:27'!
Transfer subclass: #TransferLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

TransferLeg subclass: #TransferLegLeft
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #TransferLegLeft category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 12:21:50'!
TransferLeg subclass: #TransferLegLeft
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

TransferLeg subclass: #TransferLegRight
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #TransferLegRight category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 12:21:53'!
TransferLeg subclass: #TransferLegRight
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'I 5/26/2024 12:23:54'!
test08AccountTransferMoneyToAnotherAccount
	| account1 deposit1 |
	
	account1 := ReceptiveAccount new.
	
	deposit1 := Deposit register: 50 on: account1.
		
	self assert: 1 equals: account1 transactions size.
	self assert: (account1 transactions includes: deposit1).
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'I 5/26/2024 12:30:53' prior: 50608044!
test08AccountTransferMoneyToAnotherAccount
	| account1 deposit1 account2|
	
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	
	deposit1 := Deposit register: 50 on: account1.
	Transfer from: account1 to: account2 transferAmountOfMonet: 20.
		
	self assert: 1 equals: account1 transactions size.
	self assert: (account1 transactions includes: deposit1).
! !

!testRun: #ReceptiveAccountTest #test08AccountTransferMoneyToAnotherAccount stamp: 'I 5/26/2024 12:31:07'!
ERROR!
!Transfer class methodsFor: 'instance creation' stamp: 'I 5/26/2024 12:31:18'!
from: account1 to: account2 transferAmountOfMonet: aRenameMe1 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeFrom: account1 to: account2 transferAmountOfMonet: aRenameMe1 ! !
!Transfer class methodsFor: 'instance creation' stamp: 'I 5/26/2024 12:46:44' prior: 50608074!
from: account1 to: account2 transferAmountOfMonet: money

	^self new initializeAmountOfMoney: money from: account1 to: account2 ! !

!testRun: #ReceptiveAccountTest #test08AccountTransferMoneyToAnotherAccount stamp: 'I 5/26/2024 12:46:49'!
ERROR!

!classDefinition: #Transfer category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 12:46:59'!
Object subclass: #Transfer
	instanceVariableNames: 'money_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Transfer category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 12:46:59'!
Object subclass: #Transfer
	instanceVariableNames: 'money_CHANGE_ME account1_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Transfer category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 12:47:00'!
Object subclass: #Transfer
	instanceVariableNames: 'money_CHANGE_ME account1_CHANGE_ME account2_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Transfer methodsFor: 'initialization' stamp: 'I 5/26/2024 12:47:00'!
initializeAmountOfMoney: money from: account1 to: account2 
	self shouldBeImplemented.
	money_CHANGE_ME := money.
	account1_CHANGE_ME := account1.
	account2_CHANGE_ME := account2.! !
!Transfer methodsFor: 'initialization' stamp: 'I 5/26/2024 12:47:41' prior: 50608120!
initializeAmountOfMoney: money from: account1 to: account2 
! !

Object subclass: #Transfer
	instanceVariableNames: ' transferValue '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Transfer category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 12:48:12'!
Object subclass: #Transfer
	instanceVariableNames: 'transferValue'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Transfer methodsFor: 'initialization' stamp: 'I 5/26/2024 12:49:09' prior: 50608129!
initializeAmountOfMoney: money from: account1 to: account2 
	transferValue := money.
	
	TransferLeg from: account1 trasnferTo: account2 .! !
!Transfer methodsFor: 'initialization' stamp: 'I 5/26/2024 12:52:03' prior: 50608146!
initializeAmountOfMoney: money from: account1 to: account2 
	transferValue := money.
	
	TransferLeg new from: account1 trasnferTo: account2 .! !
!TransferLeg methodsFor: 'nil' stamp: 'I 5/26/2024 12:57:14'!
from: account1 transferTo: account2
	TransferLegLeft new doOn: account1.
	TransferLegRight new doOn:account2.! !
!TransferLegLeft methodsFor: 'nil' stamp: 'I 5/26/2024 12:58:47'!
doOn: anAccount
	Withdraw register: transferValue  on: anAccount 
	! !
!TransferLegRight methodsFor: 'nil' stamp: 'I 5/26/2024 12:58:58'!
doOn: anAccount
	Deposit register: transferValue  on: anAccount 
	! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'I 5/26/2024 12:59:13' prior: 50608056!
test08AccountTransferMoneyToAnotherAccount
	| account1 deposit1 account2|
	
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	
	deposit1 := Deposit register: 50 on: account1.
	Transfer from: account1 to: account2 transferAmountOfMonet: 20.
		
	self assert: 2 equals: account1 transactions size.
	self assert: (account1 transactions includes: deposit1).
! !

!testRun: #ReceptiveAccountTest #test08AccountTransferMoneyToAnotherAccount stamp: 'I 5/26/2024 12:59:14'!
ERROR!
!TransferLeg methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 12:59:44'!
from: account1 trasnferTo: account2 .
	TransferLegLeft new doOn: account1.
	TransferLegRight new doOn:account2.! !

!testRun: #ReceptiveAccountTest #test08AccountTransferMoneyToAnotherAccount stamp: 'I 5/26/2024 12:59:47'!
PASSED!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'I 5/26/2024 12:59:47'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'I 5/26/2024 12:59:47'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'I 5/26/2024 12:59:47'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'I 5/26/2024 12:59:47'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'I 5/26/2024 12:59:47'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'I 5/26/2024 12:59:47'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'I 5/26/2024 12:59:47'!
PASSED!

!testRun: #ReceptiveAccountTest #test08AccountTransferMoneyToAnotherAccount stamp: 'I 5/26/2024 12:59:47'!
PASSED!
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'I 5/26/2024 13:00:07' prior: 50608177!
test08AccountTransferMoneyToAnotherAccount
	| account1 deposit1 account2|
	
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	
	deposit1 := Deposit register: 50 on: account1.
	Transfer from: account1 to: account2 transferAmountOfMonet: 20.
		
	self assert: 2 equals: account1 transactions size.
	self assert: (account1 transactions includes: deposit1).
	self assert: 30 equals: (account1 balance )
! !

!testRun: #ReceptiveAccountTest #test08AccountTransferMoneyToAnotherAccount stamp: 'I 5/26/2024 13:00:09'!
ERROR!

!testRun: #ReceptiveAccountTest #test08AccountTransferMoneyToAnotherAccount stamp: 'I 5/26/2024 13:00:22'!
ERROR!

!testRun: #ReceptiveAccountTest #test08AccountTransferMoneyToAnotherAccount stamp: 'I 5/26/2024 13:01:15'!
ERROR!
!Transfer methodsFor: 'nil' stamp: 'I 5/26/2024 13:03:27'!
from: account1 trasnferTo: account2
	self subclassResponsibility .! !
!Transfer methodsFor: 'initialization' stamp: 'I 5/26/2024 13:03:36' prior: 50608154!
initializeAmountOfMoney: money from: account1 to: account2 
	transferValue := money.
	
	self from: account1 trasnferTo: account2 .! !

!testRun: #ReceptiveAccountTest #test08AccountTransferMoneyToAnotherAccount stamp: 'I 5/26/2024 13:05:59'!
ERROR!

!testRun: #ReceptiveAccountTest #test08AccountTransferMoneyToAnotherAccount stamp: 'I 5/26/2024 13:06:38'!
ERROR!
!Transfer methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 13:07:26'!
from: account1 transferTo: account2
	self subclassResponsibility .! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'I 5/26/2024 13:07:28'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'I 5/26/2024 13:07:28'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'I 5/26/2024 13:07:28'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'I 5/26/2024 13:07:28'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'I 5/26/2024 13:07:28'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'I 5/26/2024 13:07:28'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'I 5/26/2024 13:07:28'!
PASSED!

!testRun: #ReceptiveAccountTest #test08AccountTransferMoneyToAnotherAccount stamp: 'I 5/26/2024 13:07:28'!
ERROR!

!testRun: #ReceptiveAccountTest #test08AccountTransferMoneyToAnotherAccount stamp: 'I 5/26/2024 13:07:28'!
ERROR!

!methodRemoval: Transfer #from:trasnferTo: stamp: 'I 5/26/2024 13:07:37'!
from: account1 trasnferTo: account2
	self subclassResponsibility .!

!methodRemoval: TransferLeg #from:trasnferTo: stamp: 'I 5/26/2024 13:07:42'!
from: account1 trasnferTo: account2 .
	TransferLegLeft new doOn: account1.
	TransferLegRight new doOn:account2.!
!Transfer methodsFor: 'initialization' stamp: 'I 5/26/2024 13:07:58' prior: 50608266!
initializeAmountOfMoney: money from: account1 to: account2 
	transferValue := money.
	
	self from: account1 transferTo: account2 .! !
!Transfer methodsFor: 'initialization' stamp: 'I 5/26/2024 14:01:31' prior: 50608329!
initializeAmountOfMoney: money from: account1 to: account2 
	transferValue := money.
	
	TransferLeg from: account1 transferTo: account2 .! !

----SNAPSHOT----(26 May 2024 14:06:10) CuisUniversity-6169.image priorSource: 8671790!
!Transfer methodsFor: 'initialization' stamp: 'I 5/26/2024 14:15:32' prior: 50608336!
initializeAmountOfMoney: money from: account1 to: account2 
	transferValue := money.
	
	self from: account1 transferTo: account2 .! !
!TransferLeg methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 14:15:39' prior: 50608161 overrides: 50608280!
from: account1 transferTo: account2
	self subclassResponsibility ! !
!TransferLegLeft methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 14:16:18' overrides: 50608354!
from: account1 transferTo: account2
	Withdraw register: transferValue on: account1 ! !

!methodRemoval: TransferLegLeft #doOn: stamp: 'I 5/26/2024 14:16:22'!
doOn: anAccount
	Withdraw register: transferValue  on: anAccount 
	!
!TransferLegRight methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 14:16:31' overrides: 50608354!
from: account1 transferTo: account2
	Deposit register: transferValue on: account2! !

!testRun: #ReceptiveAccountTest #test08AccountTransferMoneyToAnotherAccount stamp: 'I 5/26/2024 14:16:47'!
ERROR!

!methodRemoval: TransferLeg #from:transferTo: stamp: 'I 5/26/2024 14:19:45'!
from: account1 transferTo: account2
	self subclassResponsibility !

self subclasses!

self subclass!

self subclasses !

Number subclasses !

self class subclasses !
!Transfer methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 14:24:51' prior: 50608280!
from: account1 transferTo: account2
	TransferLeg new from: account1 transferTo: account2! !
!TransferLeg methodsFor: 'no messages' stamp: 'I 5/26/2024 14:25:10' overrides: 50608388!
from: account1 transferTo: account2
	self subclassResponsibility ! !

!testRun: #ReceptiveAccountTest #test08AccountTransferMoneyToAnotherAccount stamp: 'I 5/26/2024 14:25:22'!
ERROR!

self class subclasses !
!Transfer methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 14:27:26' prior: 50608388!
from: account1 transferTo: account2
	self subclassResponsibility ! !
!TransferLeg methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 14:27:33' prior: 50608394 overrides: 50608404!
from: account1 transferTo: account2
	self subclassResponsibility ! !

self subclassResponsibility !

self subclassResponsibility !

self subclasses first!

self class subclasses first!

self class subclasses !

!classRemoval: #TransferLegLeft stamp: 'I 5/26/2024 15:09:02'!
TransferLeg subclass: #TransferLegLeft
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #TransferLegRight stamp: 'I 5/26/2024 15:09:03'!
TransferLeg subclass: #TransferLegRight
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #TransferLeg stamp: 'I 5/26/2024 15:09:03'!
Transfer subclass: #TransferLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Object subclass: #Transfer
	instanceVariableNames: 'transferValue leftLeg rightLeg'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Object subclass: #Transfer
	instanceVariableNames: 'transferValue leftLeg rightLeg'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Transfer methodsFor: 'initialization' stamp: 'I 5/26/2024 15:09:40' prior: 50608346!
initializeAmountOfMoney: money from: account1 to: account2 
! !

Object subclass: #Transfer
	instanceVariableNames: 'transferValue leftLeg'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Object subclass: #Transfer
	instanceVariableNames: ' leftLeg'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Object subclass: #Transfer
	instanceVariableNames: ' left right'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'I 5/26/2024 15:11:22' prior: 50608235!
test08AccountTransferMoneyToAnotherAccount
	| account1 deposit1 account2|
	
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	
	deposit1 := Deposit register: 50 on: account1.
		
	self assert: 2 equals: account1 transactions size.
	self assert: (account1 transactions includes: deposit1).
	self assert: 30 equals: (account1 balance )
! !

!classRemoval: #Transfer stamp: 'I 5/26/2024 15:11:28'!
Object subclass: #Transfer
	instanceVariableNames: 'transferValue'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Object subclass: #Transfer
	instanceVariableNames: 'leftLeg rightLeg'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Transfer category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 15:11:44'!
Object subclass: #Transfer
	instanceVariableNames: 'leftLeg rightLeg'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'I 5/26/2024 15:12:28' prior: 50608468!
test08AccountTransferMoneyToAnotherAccount
	| account1 deposit1 account2|
	
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	
	deposit1 := Deposit register: 50 on: account1.
	Transfer from: account1 to: account2 transferAmountOfMoney: 20.
		
	self assert: 2 equals: account1 transactions size.
	self assert: (account1 transactions includes: deposit1).
	self assert: 30 equals: (account1 balance )
! !
!Transfer class methodsFor: 'no messages' stamp: 'I 5/26/2024 15:13:13'!
from: account1 to: account2 transferAmountOfMoney: money
	self new initializeFrom: account1 to: account2 transfer: money! !
!Transfer methodsFor: 'nil' stamp: 'I 5/26/2024 15:14:37'!
initializeFrom: account1 to: account2 transfer: money
	leftLeg := Withdraw register: money on: account1 .
	rightLeg := Deposit register: money on: account2 ! !

Object subclass: #Transfer
	instanceVariableNames: 'sourceLeg destinationLeg value '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Transfer category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 15:31:49'!
Object subclass: #Transfer
	instanceVariableNames: 'sourceLeg destinationLeg value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #WithdrawLeg category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 15:32:41'!
Object subclass: #WithdrawLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #DepositLeg category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 15:32:45'!
Object subclass: #DepositLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Transfer methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 15:32:33' prior: 50608523!
initializeFrom: account1 to: account2 transfer: money
	sourceLeg := WithdrawLeg register: money on: account1 .
        destinationLeg := DepositLeg register: money on: account2.

	value := money.! !

Object subclass: #TransferLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #TransferLeg category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 15:33:14'!
Object subclass: #TransferLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

TransferLeg subclass: #DepositLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #DepositLeg category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 15:33:20'!
TransferLeg subclass: #DepositLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

TransferLeg subclass: #WithdrawLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #WithdrawLeg category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 15:33:27'!
TransferLeg subclass: #WithdrawLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Transfer methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 15:35:34' prior: 50608559!
initializeFrom: account1 to: account2 transfer: money
	sourceLeg := WithdrawLeg for: self onAccount: account1 .
        destinationLeg := DepositLeg for: self onAccount: account2.

	value := money.! !
!DepositLeg class methodsFor: 'nil' stamp: 'I 5/26/2024 15:36:30'!
for: transfer onAccount: account
	^self new initializeFor: transfer onAccount: account .! !
!DepositLeg methodsFor: 'no messages' stamp: 'I 5/26/2024 15:36:43'!
initializeFor: transfer onAccount: account
	! !

Object subclass: #TransferLeg
	instanceVariableNames: 'transfer account'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Object subclass: #TransferLeg
	instanceVariableNames: 'transfer account'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Object subclass: #DepositLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #DepositLeg category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 15:38:19'!
Object subclass: #DepositLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Object subclass: #WithdrawLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #WithdrawLeg category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 15:38:25'!
Object subclass: #WithdrawLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #TransferLeg stamp: 'I 5/26/2024 15:38:28'!
Object subclass: #TransferLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Object subclass: #TransferLeg
	instanceVariableNames: 'transfer account'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #TransferLeg category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 15:38:39'!
Object subclass: #TransferLeg
	instanceVariableNames: 'transfer account'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

TransferLeg subclass: #WithdrawLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #WithdrawLeg category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 15:38:44'!
TransferLeg subclass: #WithdrawLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

TransferLeg subclass: #DepositLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

TransferLeg subclass: #DepositLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!DepositLeg methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 15:39:12' prior: 50608619!
initializeFor: transfer onAccount: anAccount
	! !

TransferLeg subclass: #DepositLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

TransferLeg subclass: #DepositLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!DepositLeg methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 15:39:25' prior: 50608696!
initializeFor: atransfer onAccount: anAccount
	! !

TransferLeg subclass: #DepositLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #DepositLeg category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 15:39:31'!
TransferLeg subclass: #DepositLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!methodRemoval: DepositLeg #initializeFor:onAccount: stamp: 'I 5/26/2024 15:39:53'!
initializeFor: atransfer onAccount: anAccount
	!
!TransferLeg methodsFor: 'nil' stamp: 'I 5/26/2024 15:41:11'!
initializeFor: aTransfer onAccount: anAccount 
	transfer := aTransfer .
	account := anAccount .
	
	! !
!TransferLeg methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 15:41:32' prior: 50608730!
initializeFor: aTransfer onAccount: anAccount 
	transfer := aTransfer .
	account := anAccount .
	
	anAccount register: self.! !

TestCase subclass: #TransferTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #TransferTest category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 15:51:00'!
TestCase subclass: #TransferTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!methodRemoval: ReceptiveAccountTest #test08AccountTransferMoneyToAnotherAccount stamp: 'I 5/26/2024 15:51:13'!
test08AccountTransferMoneyToAnotherAccount
	| account1 deposit1 account2|
	
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	
	deposit1 := Deposit register: 50 on: account1.
	Transfer from: account1 to: account2 transferAmountOfMoney: 20.
		
	self assert: 2 equals: account1 transactions size.
	self assert: (account1 transactions includes: deposit1).
	self assert: 30 equals: (account1 balance )
!
!TransferTest methodsFor: 'no messages' stamp: 'I 5/26/2024 15:51:19'!
test08AccountTransferMoneyToAnotherAccount
	| account1 deposit1 account2|
	
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	
	deposit1 := Deposit register: 50 on: account1.
	Transfer from: account1 to: account2 transferAmountOfMoney: 20.
		
	self assert: 2 equals: account1 transactions size.
	self assert: (account1 transactions includes: deposit1).
	self assert: 30 equals: (account1 balance )
! !
!TransferTest methodsFor: 'tests' stamp: 'I 5/26/2024 15:51:30'!
test01AccountTransferMoneyToAnotherAccount
	| account1 deposit1 account2|
	
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	
	deposit1 := Deposit register: 50 on: account1.
	Transfer from: account1 to: account2 transferAmountOfMoney: 20.
		
	self assert: 2 equals: account1 transactions size.
	self assert: (account1 transactions includes: deposit1).
	self assert: 30 equals: (account1 balance )
! !

!testRun: #TransferTest #test01AccountTransferMoneyToAnotherAccount stamp: 'I 5/26/2024 15:51:41'!
ERROR!
!WithdrawLeg class methodsFor: 'nil' stamp: 'I 5/26/2024 15:51:59'!
for: transfer onAccount: account
	^self new initializeFor: transfer onAccount: account .! !

!methodRemoval: TransferTest #test08AccountTransferMoneyToAnotherAccount stamp: 'I 5/26/2024 15:52:05'!
test08AccountTransferMoneyToAnotherAccount
	| account1 deposit1 account2|
	
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	
	deposit1 := Deposit register: 50 on: account1.
	Transfer from: account1 to: account2 transferAmountOfMoney: 20.
		
	self assert: 2 equals: account1 transactions size.
	self assert: (account1 transactions includes: deposit1).
	self assert: 30 equals: (account1 balance )
!

!testRun: #TransferTest #test01AccountTransferMoneyToAnotherAccount stamp: 'I 5/26/2024 15:52:06'!
ERROR!

!testRun: #TransferTest #test01AccountTransferMoneyToAnotherAccount stamp: 'I 5/26/2024 15:52:06'!
ERROR!
!Transfer methodsFor: 'nil' stamp: 'I 5/26/2024 15:57:42' overrides: 16914075!
value
	^value! !
!DepositLeg methodsFor: 'nil' stamp: 'I 5/26/2024 15:57:48'!
addTo: balanceAffected
	^ balanceAffected + transfer value! !
!WithdrawLeg methodsFor: 'nil' stamp: 'I 5/26/2024 15:57:59'!
addTo: balanceAffected
	^ balanceAffected - transfer value! !

!testRun: #TransferTest #test01AccountTransferMoneyToAnotherAccount stamp: 'I 5/26/2024 15:58:24'!
PASSED!

!testRun: #TransferTest #test01AccountTransferMoneyToAnotherAccount stamp: 'I 5/26/2024 15:58:24'!
PASSED!
!Transfer class methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 16:13:36' prior: 50608517!
from: account1 to: account2 transferAmountOfMoney: money
	self validTransferFrom: account1 to: account2.
	self new initializeFrom: account1 to: account2 transfer: money! !
!Transfer class methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 16:14:22'!
validTransferFrom: account1 to: account2.
	(account1 = 	account2 ) ifTrue: 	[self error: self sameAccountError].! !
!Transfer class methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 16:14:28' prior: 50608863!
validTransferFrom: account1 to: account2.
	(account1 = 	account2 ) ifTrue: 	[^self error: self sameAccountError].! !
!Transfer class methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 16:14:50'!
sameAccountError
	^'Cannot transfer to himself'.! !
!TransferTest methodsFor: 'tests' stamp: 'I 5/26/2024 16:17:35'!
test02AccountTransfersToItself
	|account1 deposit1 |
	
	account1 := ReceptiveAccount new.

	deposit1 := Deposit register: 50 on: account1.
	self should: [Transfer from: account1 to: account1 transferAmountOfMoney: 20] 
	raise: Error - MessageNotUnderstood 
	description: [:anError | self assert: Transfer sameAccountError equals: anError messageText ]! !

!testRun: #TransferTest #test02AccountTransfersToItself stamp: 'I 5/26/2024 16:17:39'!
PASSED!

!testRun: #TransferTest #test01AccountTransferMoneyToAnotherAccount stamp: 'I 5/26/2024 16:17:39'!
PASSED!

!testRun: #TransferTest #test02AccountTransfersToItself stamp: 'I 5/26/2024 16:17:39'!
PASSED!

Object subclass: #Report
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Report category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 16:17:50'!
Object subclass: #Report
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Object subclass: #Report
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #Report category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 19:00:50'!
Object subclass: #Report
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Report subclass: #AccountSummary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #AccountSummary category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 19:01:11'!
Report subclass: #AccountSummary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Report subclass: #TransferNet
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #TransferNet category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 19:01:21'!
Report subclass: #TransferNet
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

TestCase subclass: #ReportTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReportTest category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 19:01:31'!
TestCase subclass: #ReportTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ReportTest methodsFor: 'no messages' stamp: 'I 5/26/2024 19:05:12'!
test02
	|account deposit summaryReport|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	
	summaryReport := AccountSummary for: account.
	
	self assert: 'Deposito por 100.'.
	
! !

Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 20:10:40'!
Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions parents reports'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 23:11:39'!
Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions parents reports'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions parents reportsList'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #ReceptiveAccount category: #'Portfolio-Ejercicio' stamp: 'I 5/26/2024 23:11:48'!
Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions parents reportsList'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!ReportTest methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 23:12:53'!
test01
	|account deposit |
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	
	
	self assert: 'Deposito por 100.'equals: (account reports).
	
! !

!testRun: #ReportTest #test01 stamp: 'I 5/26/2024 23:12:58'!
ERROR!

!testRun: #ReportTest #test01 stamp: 'I 5/26/2024 23:13:21'!
ERROR!
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 23:13:31'!
reports
	self shouldBeImplemented.! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 23:14:24' prior: 50609025!
reports
	|text|
	
	text := ''.
	
	reportsList do: [:report | text , report].
	
	^text! !

!testRun: #ReportTest #test01 stamp: 'I 5/26/2024 23:14:28'!
ERROR!
!ReceptiveAccount methodsFor: 'initialization' stamp: 'I 5/26/2024 23:14:52' prior: 50606932 overrides: 16932297!
initialize

	transactions := OrderedCollection new.
	parents := OrderedCollection new.
	reportsList := OrderedCollection new.! !

!testRun: #ReportTest #test01 stamp: 'I 5/26/2024 23:14:55'!
FAILURE!
!ReceptiveAccount methodsFor: 'transactions' stamp: 'I 5/26/2024 23:16:09' prior: 50606712!
register: aTransaction

	transactions add: aTransaction .
	aTransaction defineReportOn: reportsList.
! !

!testRun: #ReportTest #test01 stamp: 'I 5/26/2024 23:16:12'!
ERROR!
!AccountTransaction methodsFor: 'transaction' stamp: 'I 5/26/2024 23:16:29'!
defineReportOn: aReportsList 
	self shouldBeImplemented.! !
!AccountTransaction methodsFor: 'transaction' stamp: 'I 5/26/2024 23:17:52' prior: 50609057!
defineReportOn: aReportsList 
	^aReportsList add: 'Deposito por' , (self value asString )! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'I 5/26/2024 23:18:27' prior: 50609049!
register: aTransaction

	transactions add: aTransaction .
	aTransaction defineReportOn: reportsList onAccount: self .
! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'I 5/26/2024 23:19:18' prior: 50609068!
register: aTransaction

	transactions add: aTransaction .
	aTransaction defineReportOnAccount: self .
! !

!testRun: #ReportTest #test01 stamp: 'I 5/26/2024 23:23:33'!
ERROR!

!testRun: #ReportTest #test01 stamp: 'I 5/26/2024 23:23:48'!
ERROR!
!Deposit methodsFor: 'transaction' stamp: 'I 5/26/2024 23:23:59'!
defineReportOnAccount: aReceptiveAccount 
	self shouldBeImplemented.! !
!Deposit methodsFor: 'transaction' stamp: 'I 5/26/2024 23:24:30' prior: 50609085!
defineReportOnAccount: aReceptiveAccount 
	aReceptiveAccount defineDepositReport.! !

!testRun: #ReportTest #test01 stamp: 'I 5/26/2024 23:24:33'!
ERROR!
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 23:24:42'!
defineDepositReport
	self shouldBeImplemented.! !
!Deposit methodsFor: 'transaction' stamp: 'I 5/26/2024 23:25:13' prior: 50609090!
defineReportOnAccount: aReceptiveAccount 
	aReceptiveAccount defineDepositReport withValue: self value.! !

!testRun: #ReportTest #test01 stamp: 'I 5/26/2024 23:26:50'!
ERROR!
!Deposit methodsFor: 'transaction' stamp: 'I 5/26/2024 23:27:23' prior: 50609103!
defineReportOnAccount: aReceptiveAccount 
	aReceptiveAccount defineDepositReportwithValue: self value.! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 23:28:05'!
defineDepositReportWithValue: amount
	reportsList add: ('Deposito por ' , amount asString)! !

!methodRemoval: ReportTest #test02 stamp: 'I 5/26/2024 23:28:27'!
test02
	|account deposit summaryReport|
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	
	summaryReport := AccountSummary for: account.
	
	self assert: 'Deposito por 100.'.
	
!

!classRemoval: #AccountSummary stamp: 'I 5/26/2024 23:28:34'!
Report subclass: #AccountSummary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #TransferNet stamp: 'I 5/26/2024 23:28:34'!
Report subclass: #TransferNet
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Report stamp: 'I 5/26/2024 23:28:34'!
Object subclass: #Report
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!
!Deposit methodsFor: 'transaction' stamp: 'I 5/26/2024 23:29:15' prior: 50609112!
defineReportOnAccount: aReceptiveAccount 
	aReceptiveAccount defineDepositReportwithValue: (self value).! !
!Deposit methodsFor: 'transaction' stamp: 'I 5/26/2024 23:29:19' prior: 50609151!
defineReportOnAccount: aReceptiveAccount 
	aReceptiveAccount defineDepositReportWithValue: (self value).! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 23:31:38' prior: 50609030!
reports
	|text|
	
	text := ''.
	
	reportsList do: [:report | text , report, Character lf asString].
	
	^text! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 23:33:03' prior: 50609164!
reports
	|text|
	
	text := ''.
	
	reportsList do: [:report |text := text , report, Character lf asString].
	
	^text! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 23:35:04' prior: 50609171!
reports
	|text|
	
	text := ''.
	
	reportsList do: [:report |text := text , report, Character lf asString].
	text := text, (self balance asString ).
	^text! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 23:35:23' prior: 50609012!
test01
	|account deposit |
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	
	
	self assert: 'Deposito por 100.
			   Balance = 100'equals: (account reports).
	
! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 23:35:34' prior: 50609178!
reports
	|text|
	
	text := ''.
	
	reportsList do: [:report |text := text , report, Character lf asString].
	text := text, ' = ',(self balance asString ).
	^text! !

!testRun: #ReportTest #test01 stamp: 'I 5/26/2024 23:35:36'!
FAILURE!
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 23:36:14' prior: 50609196!
reports
	|text|
	
	text := ''.
	
	reportsList do: [:report |text := text , report, Character lf asString].
	text := text, 'Balance = ',(self balance asString ).
	^text! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'I 5/26/2024 23:36:15'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'I 5/26/2024 23:36:15'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'I 5/26/2024 23:36:15'!
ERROR!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'I 5/26/2024 23:36:15'!
ERROR!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'I 5/26/2024 23:36:15'!
ERROR!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'I 5/26/2024 23:36:15'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'I 5/26/2024 23:36:15'!
PASSED!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'I 5/26/2024 23:36:25'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'I 5/26/2024 23:36:25'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'I 5/26/2024 23:36:25'!
ERROR!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'I 5/26/2024 23:36:25'!
ERROR!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'I 5/26/2024 23:36:25'!
ERROR!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'I 5/26/2024 23:36:25'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'I 5/26/2024 23:36:25'!
PASSED!

!testRun: #ReportTest #test01 stamp: 'I 5/26/2024 23:36:31'!
FAILURE!

!testRun: #ReportTest #test01 stamp: 'I 5/26/2024 23:36:31'!
FAILURE!
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 23:41:18' prior: 50609207!
reports
	|text|
	
	text := ''.
	
	reportsList do: [:report |text := text , report , '.', Character lf asString].
	text := text, 'Balance = ',(self balance asString ).
	^text! !

!testRun: #ReportTest #test01 stamp: 'I 5/26/2024 23:41:24'!
FAILURE!

!testRun: #ReportTest #test01 stamp: 'I 5/26/2024 23:41:24'!
FAILURE!
!ReportTest methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 23:43:52' prior: 50609186!
test01
	|account deposit |
	
	account := ReceptiveAccount new.
	deposit  := Deposit register: 100 on: account .
	
	
	self assert: 'Deposito por 100.', Character lf asString , 'Balance = 100' equals: (account reports).
	
! !

!testRun: #ReportTest #test01 stamp: 'I 5/26/2024 23:43:54'!
PASSED!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'I 5/26/2024 23:44:00'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'I 5/26/2024 23:44:00'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'I 5/26/2024 23:44:00'!
ERROR!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'I 5/26/2024 23:44:00'!
ERROR!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'I 5/26/2024 23:44:00'!
ERROR!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'I 5/26/2024 23:44:00'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'I 5/26/2024 23:44:00'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'I 5/26/2024 23:44:08'!
ERROR!
!Withdraw methodsFor: 'transaction' stamp: 'I 5/26/2024 23:44:20'!
defineReportOnAccount: aReceptiveAccount 
	self shouldBeImplemented.! !
!Withdraw methodsFor: 'transaction' stamp: 'I 5/26/2024 23:44:49' prior: 50609327!
defineReportOnAccount: aReceptiveAccount 
	aReceptiveAccount defineWithdrawWithAmount: (self value)! !

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'I 5/26/2024 23:44:59'!
ERROR!
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 23:45:03'!
defineWithdrawWithAmount: aRenameMe1 
	self shouldBeImplemented.! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 23:45:41' prior: 50609342!
defineWithdrawWithAmount: amount
	reportsList add: ('Extraccion por', amount asString )! !

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'I 5/26/2024 23:45:43'!
PASSED!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'I 5/26/2024 23:45:43'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'I 5/26/2024 23:45:43'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'I 5/26/2024 23:45:43'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'I 5/26/2024 23:45:43'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'I 5/26/2024 23:45:43'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'I 5/26/2024 23:45:43'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'I 5/26/2024 23:45:43'!
PASSED!
!ReportTest methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 23:47:12'!
test02TwoTransactions

	| account |
	
	account := ReceptiveAccount new.
	Deposit register: 100 on: account.
	Withdraw register: 50 on: account.
		
	self assert: 'Deposito por 100.' , Character lf asString , 'Extraccion por 50',
	Character lf asString, 'Balance = 50' equals:(account reports ).

! !

!testRun: #ReportTest #test02TwoTransactions stamp: 'I 5/26/2024 23:47:13'!
FAILURE!
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 23:47:44' prior: 50609348!
defineWithdrawWithAmount: amount
	reportsList add: ('Extraccion por ', amount asString )! !

!testRun: #ReportTest #test02TwoTransactions stamp: 'I 5/26/2024 23:47:46'!
FAILURE!
!ReportTest methodsFor: 'as yet unclassified' stamp: 'I 5/26/2024 23:49:37' prior: 50609384!
test02TwoTransactions

	| account |
	
	account := ReceptiveAccount new.
	Deposit register: 100 on: account.
	Withdraw register: 50 on: account.
		
	self assert: 'Deposito por 100.' , Character lf asString , 'Extraccion por 50.',
	Character lf asString, 'Balance = 50' equals:(account reports ).

! !

!testRun: #ReportTest #test02TwoTransactions stamp: 'I 5/26/2024 23:51:06'!
PASSED!

!testRun: #ReportTest #test02TwoTransactions stamp: 'I 5/26/2024 23:51:11'!
PASSED!

!testRun: #ReportTest #test01 stamp: 'I 5/26/2024 23:51:13'!
PASSED!

!testRun: #ReportTest #test01 stamp: 'I 5/26/2024 23:51:14'!
PASSED!

!testRun: #ReportTest #test02TwoTransactions stamp: 'I 5/26/2024 23:51:14'!
PASSED!

!testRun: #ReportTest #test01 stamp: 'I 5/26/2024 23:51:17'!
PASSED!

!testRun: #ReportTest #test02TwoTransactions stamp: 'I 5/26/2024 23:51:17'!
PASSED!

----SNAPSHOT----(26 May 2024 23:56:48) CuisUniversity-6169.image priorSource: 8854156!

----STARTUP---- (27 May 2024 15:51:31) as /home/ivan/Documents/Facu/Inge 1/linux64/linux64/CuisUniversity-6169.image!


!classRemoval: #WithdrawLeg stamp: 'I 5/27/2024 15:51:35'!
TransferLeg subclass: #WithdrawLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #DepositLeg stamp: 'I 5/27/2024 15:51:35'!
TransferLeg subclass: #DepositLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #TransferLeg stamp: 'I 5/27/2024 15:51:36'!
Object subclass: #TransferLeg
	instanceVariableNames: 'transfer account'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Transfer stamp: 'I 5/27/2024 15:51:36'!
Object subclass: #Transfer
	instanceVariableNames: 'sourceLeg destinationLeg value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Withdraw stamp: 'I 5/27/2024 15:51:36'!
AccountTransaction subclass: #Withdraw
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Deposit stamp: 'I 5/27/2024 15:51:36'!
AccountTransaction subclass: #Deposit
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #AccountTransaction stamp: 'I 5/27/2024 15:51:37'!
Object subclass: #AccountTransaction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #ReceptiveAccount stamp: 'I 5/27/2024 15:51:37'!
Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions parents reportsList'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Portfolio stamp: 'I 5/27/2024 15:51:37'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Account stamp: 'I 5/27/2024 15:51:38'!
Object subclass: #Account
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #TransferTest stamp: 'I 5/27/2024 15:51:38'!
TestCase subclass: #TransferTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #ReportTest stamp: 'I 5/27/2024 15:51:39'!
TestCase subclass: #ReportTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #ReceptiveAccountTest stamp: 'I 5/27/2024 15:51:39'!
TestCase subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #PortfolioTest stamp: 'I 5/27/2024 15:51:39'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

----End fileIn of /home/ivan/Downloads/Portfolio-Ejercicio(2).st----!

!testRun: #ReportTest #test01 stamp: 'I 5/27/2024 16:04:31'!
PASSED!

!testRun: #ReportTest #test02TwoTransactions stamp: 'I 5/27/2024 16:04:31'!
PASSED!

!testRun: #ReportTest #test03TransferHasToBeInTheReport stamp: 'I 5/27/2024 16:04:31'!
PASSED!

!testRun: #ReportTest #test03TransferNet stamp: 'I 5/27/2024 16:04:31'!
PASSED!

!testRun: #ReportTest #test04TransferNet stamp: 'I 5/27/2024 16:04:31'!
PASSED!

!methodRemoval: ReportTest #test03TransferNet stamp: 'I 5/27/2024 16:04:36'!
test03TransferNet

	| account accountToTransfer |
	
	account := ReceptiveAccount new.
	accountToTransfer := ReceptiveAccount new.
	Deposit register: 100 on: account.
	Transfer from: account to: 	accountToTransfer  transferAmountOfMoney: 50.
	
	self assert: -50 equals:(TransferNet for: account)
!

----STARTUP---- (28 May 2024 16:27:45) as /home/ivan/Documents/Facu/Inge 1/linux64/linux64/CuisUniversity-6169.image!


!classRemoval: #WithdrawLeg stamp: 'I 5/28/2024 16:27:56'!
TransferLeg subclass: #WithdrawLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #DepositLeg stamp: 'I 5/28/2024 16:27:56'!
TransferLeg subclass: #DepositLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #TransferLeg stamp: 'I 5/28/2024 16:27:56'!
Object subclass: #TransferLeg
	instanceVariableNames: 'transfer account'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Transfer stamp: 'I 5/28/2024 16:27:57'!
Object subclass: #Transfer
	instanceVariableNames: 'sourceLeg destinationLeg value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Withdraw stamp: 'I 5/28/2024 16:27:57'!
AccountTransaction subclass: #Withdraw
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Deposit stamp: 'I 5/28/2024 16:27:57'!
AccountTransaction subclass: #Deposit
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #AccountTransaction stamp: 'I 5/28/2024 16:27:58'!
Object subclass: #AccountTransaction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #ReceptiveAccount stamp: 'I 5/28/2024 16:27:58'!
Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions parents reportsList'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Portfolio stamp: 'I 5/28/2024 16:27:58'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Account stamp: 'I 5/28/2024 16:27:59'!
Object subclass: #Account
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #TransferTest stamp: 'I 5/28/2024 16:27:59'!
TestCase subclass: #TransferTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #ReportTest stamp: 'I 5/28/2024 16:27:59'!
TestCase subclass: #ReportTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #ReceptiveAccountTest stamp: 'I 5/28/2024 16:28:00'!
TestCase subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #PortfolioTest stamp: 'I 5/28/2024 16:28:00'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

----End fileIn of /home/ivan/Downloads/Portfolio-Ejercicio(3).st----!
!AccountSummaryTest methodsFor: 'tests' stamp: 'I 5/28/2024 16:33:12'!
test05aSummaryOnPortfolio

	|sourceAccount destinationAccount sourceAccountSummary  destinationAccountSummary deposit transfer|
	
	sourceAccount := ReceptiveAccount new.
	destinationAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 50 on: sourceAccount.
	
	transfer := Transfer from: sourceAccount to: destinationAccount  transferAmountOfMoney: 20.
	
	sourceAccountSummary := AccountSummaryVisitor for: sourceAccount.
	destinationAccountSummary := AccountSummaryVisitor for: destinationAccount .
	
	self assert: 'Deposito por 50. Salida por transferencia de 20. Balance = 30 ' equals: (sourceAccountSummary lines).
	self assert: 'Entrada por transferencia de 20. Balance = 20 ' equals: (destinationAccountSummary lines)! !
!AccountSummaryTest methodsFor: 'tests' stamp: 'I 5/28/2024 16:41:04' prior: 50612186!
test05aSummaryOnPortfolio

	|sourceAccount destinationAccount portfolio portfolioSummary deposit transfer|
	
	sourceAccount := ReceptiveAccount new.
	destinationAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 50 on: sourceAccount.
	
	transfer := Transfer from: sourceAccount to: destinationAccount  transferAmountOfMoney: 20.
	
	portfolio := Portfolio with: sourceAccount with: destinationAccount .
	
	portfolioSummary := AccountSummaryVisitor for: portfolioSummary .
	
	
	self assert: 'Deposito por 50. Salida por transferencia de 20. Balance = 30 Entrada por transferencia de 20. Balance = 20 ' equals: (portfolioSummary lines)! !

!testRun: #AccountSummaryTest #test05aSummaryOnPortfolio stamp: 'I 5/28/2024 16:41:09'!
ERROR!

!testRun: #AccountSummaryTest #test05aSummaryOnPortfolio stamp: 'I 5/28/2024 16:41:21'!
ERROR!
!Portfolio methodsFor: 'adding' stamp: 'I 5/28/2024 16:41:48' prior: 50611383!
add: account 

	self canAddAnAccount: account.
	
	accounts add: account.

	
	account addRootParent: self.
	! !

!testRun: #AccountSummaryTest #test05aSummaryOnPortfolio stamp: 'I 5/28/2024 16:41:51'!
ERROR!
!AccountSummaryTest methodsFor: 'tests' stamp: 'I 5/28/2024 16:42:39' prior: 50612212!
test05aSummaryOnPortfolio

	|sourceAccount destinationAccount portfolio portfolioSummary deposit transfer|
	
	sourceAccount := ReceptiveAccount new.
	destinationAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 50 on: sourceAccount.
	
	transfer := Transfer from: sourceAccount to: destinationAccount  transferAmountOfMoney: 20.
	
	portfolio := Portfolio with: sourceAccount with: destinationAccount .
	
	portfolioSummary := AccountSummaryVisitor for: portfolio .
	
	
	self assert: 'Deposito por 50. Salida por transferencia de 20. Balance = 30 Entrada por transferencia de 20. Balance = 20 ' equals: (portfolioSummary lines)! !

!testRun: #AccountSummaryTest #test05aSummaryOnPortfolio stamp: 'I 5/28/2024 16:42:44'!
ERROR!
!AccountSummaryVisitor methodsFor: 'nil' stamp: 'I 5/28/2024 16:46:36'!
lines
	|text|
	
	text := ''.
	
	summary do: [:aSummary | text := text , aSummary ,' '].
	
	text := text , 'Balance = ',(account balance printString ).
	
	^text.! !

!testRun: #AccountSummaryTest #test05aSummaryOnPortfolio stamp: 'I 5/28/2024 16:46:46'!
FAILURE!

!testRun: #AccountSummaryTest #test05aSummaryOnPortfolio stamp: 'I 5/28/2024 16:46:46'!
FAILURE!
!AccountSummaryVisitor methodsFor: 'as yet unclassified' stamp: 'I 5/28/2024 16:47:20' prior: 50612277!
lines
	|text|
	
	account accept: self. 
	text := ''.
	
	summary do: [:aSummary | text := text , aSummary ,' '].
	
	text := text , 'Balance = ',(account balance printString ).
	
	^text.! !

!testRun: #AccountSummaryTest #test05aSummaryOnPortfolio stamp: 'I 5/28/2024 16:47:23'!
ERROR!
!Portfolio methodsFor: 'transactions' stamp: 'I 5/28/2024 16:47:29'!
accept: anAccountSummaryVisitor 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'transactions' stamp: 'I 5/28/2024 16:48:04' prior: 50612304!
accept: anAccountSummaryVisitor 
	accounts do:[:anAccount | anAccount accept: anAccountSummaryVisitor ].! !
!AccountSummaryTest methodsFor: 'tests' stamp: 'I 5/28/2024 16:48:28' prior: 50612251!
test05aSummaryOnPortfolio

	|sourceAccount destinationAccount portfolio portfolioSummary deposit transfer|
	
	sourceAccount := ReceptiveAccount new.
	destinationAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 50 on: sourceAccount.
	
	transfer := Transfer from: sourceAccount to: destinationAccount  transferAmountOfMoney: 20.
	
	portfolio := Portfolio with: sourceAccount with: destinationAccount .
	
	portfolioSummary := AccountSummaryVisitor for: portfolio .
	
	
	self assert: 'Deposito por 50. Salida por transferencia de 20. Balance = 30 Entrada por transferencia de 20. Balance = 20 Balance = 50' equals: (portfolioSummary lines)! !

----SNAPSHOT----(28 May 2024 16:50:28) CuisUniversity-6169.image priorSource: 8889201!

!testRun: #AccountSummaryTest #test05aSummaryOnPortfolio stamp: 'I 5/28/2024 23:46:01'!
FAILURE!
!AccountSummaryTest methodsFor: 'tests' stamp: 'I 5/28/2024 23:46:54' prior: 50612316!
test05aSummaryOnPortfolio

	|sourceAccount destinationAccount portfolio portfolioSummary deposit transfer|
	
	sourceAccount := ReceptiveAccount new.
	destinationAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 50 on: sourceAccount.
	
	transfer := Transfer from: sourceAccount to: destinationAccount  transferAmountOfMoney: 20.
	
	portfolio := Portfolio with: sourceAccount with: destinationAccount .
	
	portfolioSummary := AccountSummaryVisitor for: portfolio .
	
	
	self assert: 'Deposito por 50. Salida por transferencia de 20. Entrada por transferencia de 20. Balance = 50' equals: (portfolioSummary lines)! !

!testRun: #AccountSummaryTest #test05aSummaryOnPortfolio stamp: 'I 5/28/2024 23:46:57'!
PASSED!

!testRun: #AccountSummaryTest #test01CreateAndDepositOnAccount stamp: 'I 5/28/2024 23:46:57'!
FAILURE!

!testRun: #AccountSummaryTest #test02CreateAndDoNothingExpectBalanceZero stamp: 'I 5/28/2024 23:46:57'!
FAILURE!

!testRun: #AccountSummaryTest #test03anAccountHasAWithdrawTransaction stamp: 'I 5/28/2024 23:46:57'!
FAILURE!

!testRun: #AccountSummaryTest #test04anAccountTransfersToAnotherAccount stamp: 'I 5/28/2024 23:46:57'!
FAILURE!

!testRun: #AccountSummaryTest #test05aSummaryOnPortfolio stamp: 'I 5/28/2024 23:46:57'!
PASSED!

!testRun: #AccountSummaryTest #test01CreateAndDepositOnAccount stamp: 'I 5/28/2024 23:47:02'!
FAILURE!

!testRun: #AccountSummaryTest #test01CreateAndDepositOnAccount stamp: 'I 5/28/2024 23:47:02'!
FAILURE!
!AccountSummaryTest methodsFor: 'tests' stamp: 'I 5/28/2024 23:47:45' prior: 50610804!
test01CreateAndDepositOnAccount

	|account deposit accountSummary|
	
	account := ReceptiveAccount new.
	
	deposit := Deposit register: 100 on: account.
	
	accountSummary := AccountSummaryVisitor for: account.
	
	self assert: 'Deposito por 100. Balance = 100' equals: (accountSummary lines)! !
!AccountSummaryTest methodsFor: 'tests' stamp: 'I 5/28/2024 23:47:49' prior: 50610816!
test02CreateAndDoNothingExpectBalanceZero

	|account accountSummary|
	
	account := ReceptiveAccount new.
	
	accountSummary := AccountSummaryVisitor for: account.
	
	self assert: 'Balance = 0' equals: (accountSummary lines)! !
!AccountSummaryTest methodsFor: 'tests' stamp: 'I 5/28/2024 23:47:53' prior: 50610826!
test03anAccountHasAWithdrawTransaction

	|account accountSummary withdraw|
	
	account := ReceptiveAccount new.
	
	withdraw := Withdraw register: 50 on: account.
	
	accountSummary := AccountSummaryVisitor for: account.
	
	self assert: 'Extraccion por 50. Balance = -50' equals: (accountSummary lines)! !
!AccountSummaryTest methodsFor: 'tests' stamp: 'I 5/28/2024 23:48:00' prior: 50610838!
test04anAccountTransfersToAnotherAccount

	|sourceAccount destinationAccount sourceAccountSummary  destinationAccountSummary deposit transfer|
	
	sourceAccount := ReceptiveAccount new.
	destinationAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 50 on: sourceAccount.
	
	transfer := Transfer from: sourceAccount to: destinationAccount  transferAmountOfMoney: 20.
	
	sourceAccountSummary := AccountSummaryVisitor for: sourceAccount.
	destinationAccountSummary := AccountSummaryVisitor for: destinationAccount .
	
	self assert: 'Deposito por 50. Salida por transferencia de 20. Balance = 30' equals: (sourceAccountSummary lines).
	self assert: 'Entrada por transferencia de 20. Balance = 20 ' equals: (destinationAccountSummary lines)! !
!AccountSummaryTest methodsFor: 'tests' stamp: 'I 5/28/2024 23:48:03' prior: 50612429!
test04anAccountTransfersToAnotherAccount

	|sourceAccount destinationAccount sourceAccountSummary  destinationAccountSummary deposit transfer|
	
	sourceAccount := ReceptiveAccount new.
	destinationAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 50 on: sourceAccount.
	
	transfer := Transfer from: sourceAccount to: destinationAccount  transferAmountOfMoney: 20.
	
	sourceAccountSummary := AccountSummaryVisitor for: sourceAccount.
	destinationAccountSummary := AccountSummaryVisitor for: destinationAccount .
	
	self assert: 'Deposito por 50. Salida por transferencia de 20. Balance = 30' equals: (sourceAccountSummary lines).
	self assert: 'Entrada por transferencia de 20. Balance = 20' equals: (destinationAccountSummary lines)! !

!testRun: #AccountSummaryTest #test01CreateAndDepositOnAccount stamp: 'I 5/28/2024 23:48:08'!
PASSED!

!testRun: #AccountSummaryTest #test02CreateAndDoNothingExpectBalanceZero stamp: 'I 5/28/2024 23:48:08'!
PASSED!

!testRun: #AccountSummaryTest #test03anAccountHasAWithdrawTransaction stamp: 'I 5/28/2024 23:48:08'!
PASSED!

!testRun: #AccountSummaryTest #test04anAccountTransfersToAnotherAccount stamp: 'I 5/28/2024 23:48:08'!
PASSED!

!testRun: #AccountSummaryTest #test05aSummaryOnPortfolio stamp: 'I 5/28/2024 23:48:08'!
PASSED!
!AccountSummaryTest methodsFor: 'tests' stamp: 'I 5/28/2024 23:53:57'!
test05aSummaryOnCompoundPortfolio

	|sourceAccount destinationAccount portfolio portfolioSummary deposit transfer compoundPortfolio anotherAccount|
	
	sourceAccount := ReceptiveAccount new.
	destinationAccount := ReceptiveAccount new.
	anotherAccount := ReceptiveAccount new register: (Deposit for: 50).
	
	deposit := Deposit register: 50 on: sourceAccount.
	
	transfer := Transfer from: sourceAccount to: destinationAccount  transferAmountOfMoney: 20.
	
	portfolio := Portfolio with: sourceAccount with: destinationAccount .
	
	compoundPortfolio := Portfolio with: portfolio with: anotherAccount .
	
	portfolioSummary := AccountSummaryVisitor for: compoundPortfolio .
	
	
	self assert: 'Deposito por 50. Salida por transferencia de 20. Entrada por transferencia de 20. Balance = 50' equals: (portfolioSummary lines)! !
!AccountSummaryTest methodsFor: 'tests' stamp: 'I 5/28/2024 23:54:29' prior: 50612499!
test05aSummaryOnCompoundPortfolio

	|sourceAccount destinationAccount portfolio portfolioSummary deposit transfer compoundPortfolio anotherAccount|
	
	sourceAccount := ReceptiveAccount new.
	destinationAccount := ReceptiveAccount new.
	anotherAccount := ReceptiveAccount new register: (Deposit for: 50).
	
	deposit := Deposit register: 50 on: sourceAccount.
	
	transfer := Transfer from: sourceAccount to: destinationAccount  transferAmountOfMoney: 20.
	
	portfolio := Portfolio with: sourceAccount with: destinationAccount .
	
	compoundPortfolio := Portfolio with: portfolio with: anotherAccount .
	
	portfolioSummary := AccountSummaryVisitor for: compoundPortfolio .
	
	
	self assert: 'Deposito por 50. Salida por transferencia de 20. Entrada por transferencia de 20. Deposito por 50 . Balance = 100' equals: (portfolioSummary lines)! !

!testRun: #AccountSummaryTest #test05aSummaryOnCompoundPortfolio stamp: 'I 5/28/2024 23:54:31'!
FAILURE!
!AccountSummaryTest methodsFor: 'tests' stamp: 'I 5/28/2024 23:54:38'!
test06aSummaryOnCompoundPortfolio

	|sourceAccount destinationAccount portfolio portfolioSummary deposit transfer compoundPortfolio anotherAccount|
	
	sourceAccount := ReceptiveAccount new.
	destinationAccount := ReceptiveAccount new.
	anotherAccount := ReceptiveAccount new register: (Deposit for: 50).
	
	deposit := Deposit register: 50 on: sourceAccount.
	
	transfer := Transfer from: sourceAccount to: destinationAccount  transferAmountOfMoney: 20.
	
	portfolio := Portfolio with: sourceAccount with: destinationAccount .
	
	compoundPortfolio := Portfolio with: portfolio with: anotherAccount .
	
	portfolioSummary := AccountSummaryVisitor for: compoundPortfolio .
	
	
	self assert: 'Deposito por 50. Salida por transferencia de 20. Entrada por transferencia de 20. Deposito por 50 . Balance = 100' equals: (portfolioSummary lines)! !
!AccountSummaryTest methodsFor: 'tests' stamp: 'I 5/28/2024 23:55:36' prior: 50612560!
test06aSummaryOnCompoundPortfolio

	|sourceAccount destinationAccount portfolio portfolioSummary deposit transfer compoundPortfolio anotherAccount|
	
	sourceAccount := ReceptiveAccount new.
	destinationAccount := ReceptiveAccount new.
	anotherAccount := ReceptiveAccount new register: (Deposit for: 50).
	
	deposit := Deposit register: 50 on: sourceAccount.
	
	transfer := Transfer from: sourceAccount to: destinationAccount  transferAmountOfMoney: 20.
	
	portfolio := Portfolio with: sourceAccount with: destinationAccount .
	
	compoundPortfolio := Portfolio with: portfolio with: anotherAccount .
	
	portfolioSummary := AccountSummaryVisitor for: compoundPortfolio .
	
	
	self assert: 'Deposito por 50. Salida por transferencia de 20. Entrada por transferencia de 20. Deposito por 50. Balance = 100' equals: (portfolioSummary lines)! !

!testRun: #AccountSummaryTest #test06aSummaryOnCompoundPortfolio stamp: 'I 5/28/2024 23:55:39'!
PASSED!

!testRun: #AccountSummaryTest #test01CreateAndDepositOnAccount stamp: 'I 5/28/2024 23:55:39'!
PASSED!

!testRun: #AccountSummaryTest #test02CreateAndDoNothingExpectBalanceZero stamp: 'I 5/28/2024 23:55:39'!
PASSED!

!testRun: #AccountSummaryTest #test03anAccountHasAWithdrawTransaction stamp: 'I 5/28/2024 23:55:39'!
PASSED!

!testRun: #AccountSummaryTest #test04anAccountTransfersToAnotherAccount stamp: 'I 5/28/2024 23:55:39'!
PASSED!

!testRun: #AccountSummaryTest #test05aSummaryOnCompoundPortfolio stamp: 'I 5/28/2024 23:55:39'!
FAILURE!

!testRun: #AccountSummaryTest #test05aSummaryOnPortfolio stamp: 'I 5/28/2024 23:55:39'!
PASSED!

!testRun: #AccountSummaryTest #test06aSummaryOnCompoundPortfolio stamp: 'I 5/28/2024 23:55:39'!
PASSED!

!testRun: #AccountSummaryTest #test05aSummaryOnCompoundPortfolio stamp: 'I 5/28/2024 23:55:39'!
FAILURE!

!testRun: #AccountSummaryTest #test06aSummaryOnCompoundPortfolio stamp: 'I 5/28/2024 23:55:42'!
PASSED!

!testRun: #AccountSummaryTest #test01CreateAndDepositOnAccount stamp: 'I 5/28/2024 23:55:43'!
PASSED!

!testRun: #AccountSummaryTest #test02CreateAndDoNothingExpectBalanceZero stamp: 'I 5/28/2024 23:55:43'!
PASSED!

!testRun: #AccountSummaryTest #test03anAccountHasAWithdrawTransaction stamp: 'I 5/28/2024 23:55:43'!
PASSED!

!testRun: #AccountSummaryTest #test04anAccountTransfersToAnotherAccount stamp: 'I 5/28/2024 23:55:43'!
PASSED!

!testRun: #AccountSummaryTest #test05aSummaryOnCompoundPortfolio stamp: 'I 5/28/2024 23:55:43'!
FAILURE!

!testRun: #AccountSummaryTest #test05aSummaryOnPortfolio stamp: 'I 5/28/2024 23:55:43'!
PASSED!

!testRun: #AccountSummaryTest #test06aSummaryOnCompoundPortfolio stamp: 'I 5/28/2024 23:55:43'!
PASSED!

!testRun: #AccountSummaryTest #test05aSummaryOnCompoundPortfolio stamp: 'I 5/28/2024 23:55:43'!
FAILURE!

!methodRemoval: AccountSummaryTest #test05aSummaryOnCompoundPortfolio stamp: 'I 5/28/2024 23:55:47'!
test05aSummaryOnCompoundPortfolio

	|sourceAccount destinationAccount portfolio portfolioSummary deposit transfer compoundPortfolio anotherAccount|
	
	sourceAccount := ReceptiveAccount new.
	destinationAccount := ReceptiveAccount new.
	anotherAccount := ReceptiveAccount new register: (Deposit for: 50).
	
	deposit := Deposit register: 50 on: sourceAccount.
	
	transfer := Transfer from: sourceAccount to: destinationAccount  transferAmountOfMoney: 20.
	
	portfolio := Portfolio with: sourceAccount with: destinationAccount .
	
	compoundPortfolio := Portfolio with: portfolio with: anotherAccount .
	
	portfolioSummary := AccountSummaryVisitor for: compoundPortfolio .
	
	
	self assert: 'Deposito por 50. Salida por transferencia de 20. Entrada por transferencia de 20. Deposito por 50 . Balance = 100' equals: (portfolioSummary lines)!
!AccountSummaryVisitor methodsFor: 'as yet unclassified' stamp: 'I 5/28/2024 23:57:21' prior: 50612292!
lines
	|text|
	
	account accept: self. 
	text := ''.
	
	summary do: [:aSummary | text := text , aSummary ,' '].
	
	text := text , ' Balance = ',(account balance printString ).
	
	^text.! !

!testRun: #AccountSummaryTest #test06aSummaryOnCompoundPortfolio stamp: 'I 5/28/2024 23:57:40'!
FAILURE!

!testRun: #AccountSummaryTest #test06aSummaryOnCompoundPortfolio stamp: 'I 5/28/2024 23:59:02'!
FAILURE!

!testRun: #AccountSummaryTest #test06aSummaryOnCompoundPortfolio stamp: 'I 5/28/2024 23:59:02'!
FAILURE!

!testRun: #AccountSummaryTest #test05aSummaryOnPortfolio stamp: 'I 5/28/2024 23:59:07'!
FAILURE!

!testRun: #AccountSummaryTest #test05aSummaryOnPortfolio stamp: 'I 5/28/2024 23:59:07'!
FAILURE!

!testRun: #AccountSummaryTest #test04anAccountTransfersToAnotherAccount stamp: 'I 5/28/2024 23:59:11'!
FAILURE!

!testRun: #AccountSummaryTest #test04anAccountTransfersToAnotherAccount stamp: 'I 5/28/2024 23:59:11'!
FAILURE!

!testRun: #AccountSummaryTest #test01CreateAndDepositOnAccount stamp: 'I 5/28/2024 23:59:18'!
FAILURE!

!testRun: #AccountSummaryTest #test01CreateAndDepositOnAccount stamp: 'I 5/28/2024 23:59:18'!
FAILURE!
!AccountSummaryTest methodsFor: 'tests' stamp: 'I 5/28/2024 23:59:52' prior: 50612406!
test02CreateAndDoNothingExpectBalanceZero

	|account accountSummary|
	
	account := ReceptiveAccount new.
	
	accountSummary := AccountSummaryVisitor for: account.
	
	self assert: ' Balance = 0' equals: (accountSummary lines)! !

!testRun: #AccountSummaryTest #test02CreateAndDoNothingExpectBalanceZero stamp: 'I 5/29/2024 00:00:05'!
PASSED!

!testRun: #AccountSummaryTest #test01CreateAndDepositOnAccount stamp: 'I 5/29/2024 00:00:06'!
FAILURE!

!testRun: #AccountSummaryTest #test01CreateAndDepositOnAccount stamp: 'I 5/29/2024 00:00:06'!
FAILURE!
!AccountSummaryVisitor methodsFor: 'as yet unclassified' stamp: 'I 5/29/2024 00:00:38' prior: 50612708!
lines
	|text|
	
	account accept: self. 
	text := ''.
	
	summary do: [:aSummary | text := text , aSummary ,' '].
	
	text := text , 'Balance = ',(account balance printString ).
	
	^text.! !
!AccountSummaryTest methodsFor: 'tests' stamp: 'I 5/29/2024 00:00:49' prior: 50612747!
test02CreateAndDoNothingExpectBalanceZero

	|account accountSummary|
	
	account := ReceptiveAccount new.
	
	accountSummary := AccountSummaryVisitor for: account.
	
	self assert: 'Balance = 0' equals: (accountSummary lines)! !

!testRun: #AccountSummaryTest #test01CreateAndDepositOnAccount stamp: 'I 5/29/2024 00:00:53'!
PASSED!

!testRun: #AccountSummaryTest #test02CreateAndDoNothingExpectBalanceZero stamp: 'I 5/29/2024 00:00:55'!
PASSED!

!testRun: #AccountSummaryTest #test03anAccountHasAWithdrawTransaction stamp: 'I 5/29/2024 00:00:56'!
PASSED!

!testRun: #AccountSummaryTest #test04anAccountTransfersToAnotherAccount stamp: 'I 5/29/2024 00:00:57'!
PASSED!

!testRun: #AccountSummaryTest #test05aSummaryOnPortfolio stamp: 'I 5/29/2024 00:00:59'!
PASSED!

!testRun: #AccountSummaryTest #test06aSummaryOnCompoundPortfolio stamp: 'I 5/29/2024 00:01:00'!
PASSED!

!testRun: #AccountSummaryTest #test01CreateAndDepositOnAccount stamp: 'I 5/29/2024 00:01:02'!
PASSED!

!testRun: #AccountSummaryTest #test02CreateAndDoNothingExpectBalanceZero stamp: 'I 5/29/2024 00:01:02'!
PASSED!

!testRun: #AccountSummaryTest #test03anAccountHasAWithdrawTransaction stamp: 'I 5/29/2024 00:01:02'!
PASSED!

!testRun: #AccountSummaryTest #test04anAccountTransfersToAnotherAccount stamp: 'I 5/29/2024 00:01:02'!
PASSED!

!testRun: #AccountSummaryTest #test05aSummaryOnPortfolio stamp: 'I 5/29/2024 00:01:02'!
PASSED!

!testRun: #AccountSummaryTest #test06aSummaryOnCompoundPortfolio stamp: 'I 5/29/2024 00:01:02'!
PASSED!
!TransferNetTest methodsFor: 'as yet unclassified' stamp: 'I 5/29/2024 00:12:47'!
test04AccountTranferInPortfolio
	|sourceAccount destinationAccount portfolio deposit transfer transferNet|
	
	sourceAccount := ReceptiveAccount new.
	destinationAccount := ReceptiveAccount new.
	
	deposit := Deposit register: 50 on: sourceAccount.
	
	transfer := Transfer from: sourceAccount to: destinationAccount  transferAmountOfMoney: 20.
	
	portfolio := Portfolio with: sourceAccount with: destinationAccount .
	
	transferNet := TransferNetVisitor for: portfolio.
	
	self assert: 0 equals: (transferNet netValue ).
	! !

!testRun: #TransferNetTest #test04AccountTranferInPortfolio stamp: 'I 5/29/2024 00:12:53'!
PASSED!

!testRun: #TransferNetTest #test01DepositExpectsTransferNetZero stamp: 'I 5/29/2024 00:12:53'!
PASSED!

!testRun: #TransferNetTest #test02WithdrawExpectsTransferNetZero stamp: 'I 5/29/2024 00:12:53'!
PASSED!

!testRun: #TransferNetTest #test03AccountTransferAndGetDeposit stamp: 'I 5/29/2024 00:12:53'!
PASSED!

!testRun: #TransferNetTest #test04AccountTranferInPortfolio stamp: 'I 5/29/2024 00:12:53'!
PASSED!

!testRun: #TransferNetTest #test04AccountTranferInPortfolio stamp: 'I 5/29/2024 00:12:55'!
PASSED!

!testRun: #TransferNetTest #test01DepositExpectsTransferNetZero stamp: 'I 5/29/2024 00:12:55'!
PASSED!

!testRun: #TransferNetTest #test02WithdrawExpectsTransferNetZero stamp: 'I 5/29/2024 00:12:55'!
PASSED!

!testRun: #TransferNetTest #test03AccountTransferAndGetDeposit stamp: 'I 5/29/2024 00:12:55'!
PASSED!

!testRun: #TransferNetTest #test04AccountTranferInPortfolio stamp: 'I 5/29/2024 00:12:55'!
PASSED!
!Portfolio methodsFor: 'transactions' stamp: 'I 5/29/2024 00:13:32' prior: 50612309!
accept: aVisitor 
	accounts do:[:anAccount | anAccount accept: aVisitor ].! !

----QUIT----(29 May 2024 00:26:23) CuisUniversity-6169.image priorSource: 8982030!

----STARTUP---- (29 May 2024 16:40:14) as /home/ivan/Documents/Facu/Inge 1/linux64/linux64/CuisUniversity-6169.image!


!classRemoval: #MarsRoverHeadingWest stamp: 'I 5/29/2024 16:41:12'!
MarsRoverHeading subclass: #MarsRoverHeadingWest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classRemoval: #MarsRoverHeadingSouth stamp: 'I 5/29/2024 16:41:12'!
MarsRoverHeading subclass: #MarsRoverHeadingSouth
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classRemoval: #MarsRoverHeadingNorth stamp: 'I 5/29/2024 16:41:12'!
MarsRoverHeading subclass: #MarsRoverHeadingNorth
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classRemoval: #MarsRoverHeadingEast stamp: 'I 5/29/2024 16:41:13'!
MarsRoverHeading subclass: #MarsRoverHeadingEast
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classRemoval: #MarsRoverHeading stamp: 'I 5/29/2024 16:41:13'!
Object subclass: #MarsRoverHeading
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classRemoval: #MarsRover stamp: 'I 5/29/2024 16:41:13'!
Object subclass: #MarsRover
	instanceVariableNames: 'position head'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classRemoval: #MarsRoverTest stamp: 'I 5/29/2024 16:41:14'!
TestCase subclass: #MarsRoverTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

----End fileIn of /home/ivan/Downloads/MarsRover-WithHeading.st----!
!MarsRoverObserverTest methodsFor: 'tests' stamp: 'I 5/29/2024 16:49:38'!
test05MarsRoverCheckActualPosition
	|marsRover windowObserver|
	
	marsRover := MarsRover at: (1@2) heading: self north.
	
	windowObserver := LogObserver for: marsRover.
	
	marsRover process: 'ff'.

	
	self assert: (windowObserver assertPosition: (1@4) andHeading: '').
	! !

!testRun: #MarsRoverObserverTest #test05MarsRoverCheckActualPosition stamp: 'I 5/29/2024 16:49:41'!
ERROR!
!MarsRoverObserverTest methodsFor: 'tests' stamp: 'I 5/29/2024 16:49:58' prior: 50613613!
test05MarsRoverCheckActualPosition
	|marsRover windowObserver|
	
	marsRover := MarsRover at: (1@2) heading: self north.
	
	windowObserver := WindowObserver for: marsRover.
	
	marsRover process: 'ff'.

	
	self assert: (windowObserver assertPosition: (1@4) andHeading: '').
	! !

!testRun: #MarsRoverObserverTest #test05MarsRoverCheckActualPosition stamp: 'I 5/29/2024 16:49:59'!
ERROR!

!testRun: #MarsRoverObserverTest #test05MarsRoverCheckActualPosition stamp: 'I 5/29/2024 16:50:06'!
ERROR!
!Object class methodsFor: 'instance creation' stamp: 'I 5/29/2024 16:50:57' prior: 50599915!
for: marsRover
	^self new initializeFor: marsRover .
	! !

!testRun: #MarsRoverObserverTest #test05MarsRoverCheckActualPosition stamp: 'I 5/29/2024 16:51:00'!
ERROR!

!classDefinition: #WindowObserver category: #'MarsRover-WithHeading' stamp: 'I 5/29/2024 16:51:07'!
MarsRoverObserver subclass: #WindowObserver
	instanceVariableNames: 'marsRover_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!
!WindowObserver methodsFor: 'initialization' stamp: 'I 5/29/2024 16:51:07'!
initializeFor: marsRover 
	self shouldBeImplemented.
	marsRover_CHANGE_ME := marsRover.! !
!WindowObserver methodsFor: 'initialization' stamp: 'I 5/29/2024 16:51:14' prior: 50613664!
initializeFor: marsRover 
	marsRover_CHANGE_ME := marsRover.
	! !

!classDefinition: #WindowObserver category: #'MarsRover-WithHeading' stamp: 'I 5/29/2024 16:51:48'!
MarsRoverObserver subclass: #WindowObserver
	instanceVariableNames: 'marsRoverSubject'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!
!WindowObserver methodsFor: 'as yet unclassified' stamp: 'I 5/29/2024 16:51:48' prior: 50613670!
initializeFor: marsRover 
	marsRoverSubject := marsRover.
	! !
!MarsRover methodsFor: 'heading' stamp: 'I 5/29/2024 16:56:02' prior: 50613236!
headEast
	
	head := MarsRoverHeadingEast for: self.
	
	observers do:[:observer| observer update: 'East' ]! !

'i' isKindOf: Point  !

1@2 isKindOf: Point  !

MarsRoverObserver subclass: #WindowObserver
	instanceVariableNames: 'marsRoverSubject actaulPosition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classDefinition: #WindowObserver category: #'MarsRover-WithHeading' stamp: 'I 5/29/2024 17:13:45'!
MarsRoverObserver subclass: #WindowObserver
	instanceVariableNames: 'marsRoverSubject actaulPosition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

MarsRoverObserver subclass: #WindowObserver
	instanceVariableNames: 'marsRoverSubject actaulPosition actualHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classDefinition: #WindowObserver category: #'MarsRover-WithHeading' stamp: 'I 5/29/2024 17:13:54'!
MarsRoverObserver subclass: #WindowObserver
	instanceVariableNames: 'marsRoverSubject actaulPosition actualHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!
!WindowObserver methodsFor: 'initialization' stamp: 'I 5/29/2024 17:14:10' prior: 50613684!
initializeFor: marsRover 
	marsRoverSubject := marsRover.
	actaulPosition := nil.
	! !

!classDefinition: #WindowObserver category: #'MarsRover-WithHeading' stamp: 'I 5/29/2024 17:14:17'!
MarsRoverObserver subclass: #WindowObserver
	instanceVariableNames: 'marsRoverSubject actualPosition actualHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!
!WindowObserver methodsFor: 'as yet unclassified' stamp: 'I 5/29/2024 17:14:17' prior: 50613728!
initializeFor: marsRover 
	marsRoverSubject := marsRover.
	actualPosition := nil.
	! !
!WindowObserver methodsFor: 'initialization' stamp: 'I 5/29/2024 17:14:26' prior: 50613744!
initializeFor: marsRover 
	marsRoverSubject := marsRover.
	actualPosition := nil.
	actualHeading := ''.
	! !

Point new!

x := Point new!
!WindowObserver methodsFor: 'initialization' stamp: 'I 5/29/2024 17:15:36' prior: 50613750!
initializeFor: marsRover 
	marsRoverSubject := marsRover.
	actualPosition := Point new.
	actualHeading := ''.
	! !

Point new = (Point new)!

MarsRoverObserver subclass: #WindowObserver
	instanceVariableNames: 'marsRoverSubject actualPosition heading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classDefinition: #WindowObserver category: #'MarsRover-WithHeading' stamp: 'I 5/29/2024 17:16:08'!
MarsRoverObserver subclass: #WindowObserver
	instanceVariableNames: 'marsRoverSubject actualPosition heading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classDefinition: #WindowObserver category: #'MarsRover-WithHeading' stamp: 'I 5/29/2024 17:16:31'!
MarsRoverObserver subclass: #WindowObserver
	instanceVariableNames: 'marsRoverSubject actualPosition actualHeading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!
!MarsRoverObserverTest methodsFor: 'tests' stamp: 'I 5/29/2024 17:16:43'!
test06MarsRoverMoveToAllSides
	|marsRover logObserver|
	
	marsRover := MarsRover at: (1@2) heading: self north.
	
	logObserver := LogObserver for: marsRover.
	
	marsRover process: 'rffrl'.

	
	self assert: (OrderedCollection with: 'East' with: (2@2) with: (3@2) with:'South' with: 'East') equals:(logObserver lines).
	! !

!methodRemoval: MarsRoverObserverTest #test05MarsRoverMoveToAllSides stamp: 'I 5/29/2024 17:16:43'!
test05MarsRoverMoveToAllSides
	|marsRover logObserver|
	
	marsRover := MarsRover at: (1@2) heading: self north.
	
	logObserver := LogObserver for: marsRover.
	
	marsRover process: 'rffrl'.

	
	self assert: (OrderedCollection with: 'East' with: (2@2) with: (3@2) with:'South' with: 'East') equals:(logObserver lines).
	!
!MarsRoverObserverTest methodsFor: 'tests' stamp: 'I 5/29/2024 17:16:55'!
test05MarsRoverMoveToAllSides
	|marsRover logObserver|
	
	marsRover := MarsRover at: (1@2) heading: self north.
	
	logObserver := LogObserver for: marsRover.
	
	marsRover process: 'rffrl'.

	
	self assert: (OrderedCollection with: 'East' with: (2@2) with: (3@2) with:'South' with: 'East') equals:(logObserver lines).
	! !

!methodRemoval: MarsRoverObserverTest #test06MarsRoverMoveToAllSides stamp: 'I 5/29/2024 17:16:56'!
test06MarsRoverMoveToAllSides
	|marsRover logObserver|
	
	marsRover := MarsRover at: (1@2) heading: self north.
	
	logObserver := LogObserver for: marsRover.
	
	marsRover process: 'rffrl'.

	
	self assert: (OrderedCollection with: 'East' with: (2@2) with: (3@2) with:'South' with: 'East') equals:(logObserver lines).
	!
!MarsRoverObserverTest methodsFor: 'tests' stamp: 'I 5/29/2024 17:17:01'!
test06MarsRoverCheckActualPosition
	|marsRover windowObserver|
	
	marsRover := MarsRover at: (1@2) heading: self north.
	
	windowObserver := WindowObserver for: marsRover.
	
	marsRover process: 'ff'.

	
	self assert: (windowObserver assertPosition: (1@4) andHeading: '').
	! !

!methodRemoval: MarsRoverObserverTest #test05MarsRoverCheckActualPosition stamp: 'I 5/29/2024 17:17:01'!
test05MarsRoverCheckActualPosition
	|marsRover windowObserver|
	
	marsRover := MarsRover at: (1@2) heading: self north.
	
	windowObserver := WindowObserver for: marsRover.
	
	marsRover process: 'ff'.

	
	self assert: (windowObserver assertPosition: (1@4) andHeading: '').
	!

!testRun: #MarsRoverObserverTest #test06MarsRoverCheckActualPosition stamp: 'I 5/29/2024 17:17:04'!
ERROR!
!WindowObserver methodsFor: 'assertion' stamp: 'I 5/29/2024 17:17:16'!
assertPosition: aRenameMe1 andHeading: aRenameMe2 
	self shouldBeImplemented.! !
!WindowObserver methodsFor: 'assertion' stamp: 'I 5/29/2024 17:17:22' prior: 50613869!
assertPosition: aPosition andHeading: aRenameMe2 
	self shouldBeImplemented.! !
!WindowObserver methodsFor: 'assertion' stamp: 'I 5/29/2024 17:17:27' prior: 50613875!
assertPosition: aPosition andHeading: aHeading 
	self shouldBeImplemented.! !
!WindowObserver methodsFor: 'assertion' stamp: 'I 5/29/2024 17:18:01' prior: 50613881!
assertPosition: aPosition andHeading: aHeading 
	^actualPosition = aPosition and:[actualHeading = aHeading ]! !

!testRun: #MarsRoverObserverTest #test01MoveForwardOneAndLogObservedThis stamp: 'I 5/29/2024 17:18:04'!
PASSED!

!testRun: #MarsRoverObserverTest #test02DoMoreProccessAndExpectsALogWithMoreMovements stamp: 'I 5/29/2024 17:18:04'!
PASSED!

!testRun: #MarsRoverObserverTest #test03MarsRoverDoesntMove stamp: 'I 5/29/2024 17:18:04'!
PASSED!

!testRun: #MarsRoverObserverTest #test04MarsRoverMoveToTheRight stamp: 'I 5/29/2024 17:18:04'!
PASSED!

!testRun: #MarsRoverObserverTest #test05MarsRoverMoveToAllSides stamp: 'I 5/29/2024 17:18:04'!
PASSED!

!testRun: #MarsRoverObserverTest #test06MarsRoverCheckActualPosition stamp: 'I 5/29/2024 17:18:04'!
FAILURE!

!testRun: #MarsRoverObserverTest #test06MarsRoverCheckActualPosition stamp: 'I 5/29/2024 17:18:04'!
FAILURE!

!testRun: #MarsRoverObserverTest #test06MarsRoverCheckActualPosition stamp: 'I 5/29/2024 17:18:08'!
FAILURE!
!WindowObserver methodsFor: 'initialization' stamp: 'I 5/29/2024 17:20:18' prior: 50613758!
initializeFor: marsRover 
	marsRoverSubject := marsRover.
	marsRover addObserver: self.
	actualPosition := Point new.
	actualHeading := ''.
	! !

!testRun: #MarsRoverObserverTest #test06MarsRoverCheckActualPosition stamp: 'I 5/29/2024 17:20:23'!
FAILURE!
!WindowObserver methodsFor: 'nil' stamp: 'I 5/29/2024 17:21:15'!
update! !
!WindowObserver methodsFor: 'notify' stamp: 'I 5/29/2024 17:21:26' overrides: 16915792!
update: a! !
!WindowObserver methodsFor: 'notify' stamp: 'I 5/29/2024 17:28:41' prior: 50613935 overrides: 16915792!
update: actionRealized
	(actionRealized isKindOf: Point) ifTrue: [actualPosition := actionRealized ]
	ifFalse: [('North' = actionRealized) ifTrue:[actualHeading := 'Apuntando al Norte'].
		('West' = actionRealized) ifTrue:[actualHeading := 'Apuntando al Oeste'].
		('East' = actionRealized) ifTrue:[actualHeading := 'Apuntando al Este'].
		('South' = actionRealized) ifTrue:[actualHeading := 'Apuntando al Sur'].]! !

!testRun: #MarsRoverObserverTest #test06MarsRoverCheckActualPosition stamp: 'I 5/29/2024 17:28:46'!
PASSED!

!testRun: #MarsRoverObserverTest #test06MarsRoverCheckActualPosition stamp: 'I 5/29/2024 17:28:50'!
PASSED!
!MarsRoverObserverTest methodsFor: 'tests' stamp: 'I 5/29/2024 17:29:18'!
test06MarsRoverCheckActualPositionAndHeading
	|marsRover windowObserver|
	
	marsRover := MarsRover at: (1@2) heading: self north.
	
	windowObserver := WindowObserver for: marsRover.
	
	marsRover process: 'ffrf'.

	
	self assert: (windowObserver assertPosition: (2@4) andHeading: 'Apuntando al Este').
	! !

!testRun: #MarsRoverObserverTest #test06MarsRoverCheckActualPositionAndHeading stamp: 'I 5/29/2024 17:29:21'!
PASSED!

!testRun: #MarsRoverObserverTest #test01MoveForwardOneAndLogObservedThis stamp: 'I 5/29/2024 17:29:21'!
PASSED!

!testRun: #MarsRoverObserverTest #test02DoMoreProccessAndExpectsALogWithMoreMovements stamp: 'I 5/29/2024 17:29:21'!
PASSED!

!testRun: #MarsRoverObserverTest #test03MarsRoverDoesntMove stamp: 'I 5/29/2024 17:29:21'!
PASSED!

!testRun: #MarsRoverObserverTest #test04MarsRoverMoveToTheRight stamp: 'I 5/29/2024 17:29:21'!
PASSED!

!testRun: #MarsRoverObserverTest #test05MarsRoverMoveToAllSides stamp: 'I 5/29/2024 17:29:21'!
PASSED!

!testRun: #MarsRoverObserverTest #test06MarsRoverCheckActualPosition stamp: 'I 5/29/2024 17:29:21'!
PASSED!

!testRun: #MarsRoverObserverTest #test06MarsRoverCheckActualPositionAndHeading stamp: 'I 5/29/2024 17:29:21'!
PASSED!
!MarsRoverObserverTest methodsFor: 'tests' stamp: 'I 5/29/2024 17:29:28'!
test07MarsRoverCheckActualPositionAndHeading
	|marsRover windowObserver|
	
	marsRover := MarsRover at: (1@2) heading: self north.
	
	windowObserver := WindowObserver for: marsRover.
	
	marsRover process: 'ffrf'.

	
	self assert: (windowObserver assertPosition: (2@4) andHeading: 'Apuntando al Este').
	! !

!methodRemoval: MarsRoverObserverTest #test06MarsRoverCheckActualPositionAndHeading stamp: 'I 5/29/2024 17:29:29'!
test06MarsRoverCheckActualPositionAndHeading
	|marsRover windowObserver|
	
	marsRover := MarsRover at: (1@2) heading: self north.
	
	windowObserver := WindowObserver for: marsRover.
	
	marsRover process: 'ffrf'.

	
	self assert: (windowObserver assertPosition: (2@4) andHeading: 'Apuntando al Este').
	!

!testRun: #MarsRoverObserverTest #test07MarsRoverCheckActualPositionAndHeading stamp: 'I 5/29/2024 17:42:36'!
PASSED!

!testRun: #MarsRoverObserverTest #test01MoveForwardOneAndLogObservedThis stamp: 'I 5/29/2024 17:42:36'!
PASSED!

!testRun: #MarsRoverObserverTest #test02DoMoreProccessAndExpectsALogWithMoreMovements stamp: 'I 5/29/2024 17:42:36'!
PASSED!

!testRun: #MarsRoverObserverTest #test03MarsRoverDoesntMove stamp: 'I 5/29/2024 17:42:36'!
PASSED!

!testRun: #MarsRoverObserverTest #test04MarsRoverMoveToTheRight stamp: 'I 5/29/2024 17:42:36'!
PASSED!

!testRun: #MarsRoverObserverTest #test05MarsRoverMoveToAllSides stamp: 'I 5/29/2024 17:42:36'!
PASSED!

!testRun: #MarsRoverObserverTest #test06MarsRoverCheckActualPosition stamp: 'I 5/29/2024 17:42:36'!
PASSED!

!testRun: #MarsRoverObserverTest #test07MarsRoverCheckActualPositionAndHeading stamp: 'I 5/29/2024 17:42:36'!
PASSED!
!MarsRoverObserverTest methodsFor: 'tests' stamp: 'I 5/29/2024 17:42:48'!
test08MarsRoverCheckActualPositionAndHeading
	|marsRover windowObserver|
	
	marsRover := MarsRover at: (1@2) heading: self north.
	
	windowObserver := WindowObserver for: marsRover.
	
	marsRover process: 'ffrfr'.

	
	self assert: (windowObserver assertPosition: (2@4) andHeading: 'Apuntando al Sur').
	! !

!testRun: #MarsRoverObserverTest #test08MarsRoverCheckActualPositionAndHeading stamp: 'I 5/29/2024 17:42:50'!
PASSED!

!testRun: #MarsRoverObserverTest #test01MoveForwardOneAndLogObservedThis stamp: 'I 5/29/2024 17:42:50'!
PASSED!

!testRun: #MarsRoverObserverTest #test02DoMoreProccessAndExpectsALogWithMoreMovements stamp: 'I 5/29/2024 17:42:50'!
PASSED!

!testRun: #MarsRoverObserverTest #test03MarsRoverDoesntMove stamp: 'I 5/29/2024 17:42:50'!
PASSED!

!testRun: #MarsRoverObserverTest #test04MarsRoverMoveToTheRight stamp: 'I 5/29/2024 17:42:50'!
PASSED!

!testRun: #MarsRoverObserverTest #test05MarsRoverMoveToAllSides stamp: 'I 5/29/2024 17:42:50'!
PASSED!

!testRun: #MarsRoverObserverTest #test06MarsRoverCheckActualPosition stamp: 'I 5/29/2024 17:42:50'!
PASSED!

!testRun: #MarsRoverObserverTest #test07MarsRoverCheckActualPositionAndHeading stamp: 'I 5/29/2024 17:42:50'!
PASSED!

!testRun: #MarsRoverObserverTest #test08MarsRoverCheckActualPositionAndHeading stamp: 'I 5/29/2024 17:42:50'!
PASSED!

----STARTUP---- (1 June 2024 22:14:39) as /home/ivan/Documents/Facu/Inge 1/linux64/linux64/CuisUniversity-6169.image!


Object subclass: #Cart
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classDefinition: #Cart category: #'TusLibros.com' stamp: 'I 6/1/2024 22:15:48'!
Object subclass: #Cart
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

TestCase subclass: #CartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classDefinition: #CartTest category: #'TusLibros.com' stamp: 'I 6/1/2024 22:33:29'!
TestCase subclass: #CartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!
!CartTest methodsFor: 'no messages' stamp: 'I 6/1/2024 22:33:45'!
test01CreateCartExpectsEmptyCart
! !

----STARTUP---- (2 June 2024 12:32:52) as /home/ivan/Documents/Facu/Inge 1/linux64/linux64/CuisUniversity-6169.image!


Metaclass class !

Metaclass !

Metaclass super!

Metaclass class super!

Metaclass new super!

Object super!

Object superclass !

ProtoObject superclass !

ProtoObject class superclass !

ProtoObject class superclass !

Class class superclass  !

ClassDescription class superclass   !

 Behavior class superclass     !

Object class superclass      !

ProtoObject class superclass       !

Class class superclass      !

Class class class superclass     !

Class class class class superclass    !

ClassDescription  class class class superclass     !

Object subclass: #Cart
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classDefinition: #Cart category: #'TusLibros.com' stamp: 'I 6/2/2024 12:42:28'!
Object subclass: #Cart
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

TestCase subclass: #CartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classDefinition: #CartTest category: #'TusLibros.com' stamp: 'I 6/2/2024 12:46:43'!
TestCase subclass: #CartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

Object subclass: #Client
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classDefinition: #Client category: #'TusLibros.com' stamp: 'I 6/2/2024 12:50:56'!
Object subclass: #Client
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

Object subclass: #MerchantProcessor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classDefinition: #MerchantProcessor category: #'TusLibros.com' stamp: 'I 6/2/2024 12:51:03'!
Object subclass: #MerchantProcessor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!
!CartTest methodsFor: 'nil' stamp: 'I 6/2/2024 12:51:18'!
test01! !
!CartTest methodsFor: 'tests' stamp: 'I 6/2/2024 12:57:02' prior: 50612980!
test01
	|cart|
	
	cart := Cart new.
! !
!CartTest methodsFor: 'tests' stamp: 'I 6/2/2024 13:01:50' prior: 50612983!
test01
	|cart|
	
	cart := Cart new.
	
	self assert: (OrderedCollection new) equals: (cart listOfBooks).
! !

!classRemoval: #Client stamp: 'I 6/2/2024 13:02:03'!
Object subclass: #Client
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classRemoval: #MerchantProcessor stamp: 'I 6/2/2024 13:02:06'!
Object subclass: #MerchantProcessor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!testRun: #CartTest #test01 stamp: 'I 6/2/2024 13:02:09'!
ERROR!

Object subclass: #Cart
	instanceVariableNames: 'listOfBooks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classDefinition: #Cart category: #'TusLibros.com' stamp: 'I 6/2/2024 13:02:42'!
Object subclass: #Cart
	instanceVariableNames: 'listOfBooks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!
!Cart methodsFor: 'nil' stamp: 'I 6/2/2024 13:02:57' overrides: 16932297!
initialize 
	listOfBooks := OrderedCollection new.! !
!Cart methodsFor: 'as yet unclassified' stamp: 'I 6/2/2024 13:02:59' prior: 50613018 overrides: 16932297!
initialize 
	listOfBooks := OrderedCollection new.
	! !

!testRun: #CartTest #test01 stamp: 'I 6/2/2024 13:03:30'!
ERROR!
!Cart methodsFor: 'Purchases' stamp: 'I 6/2/2024 13:03:46'!
listOfBooks
	self shouldBeImplemented.
	^listOfBooks! !
!Cart methodsFor: 'Purchases' stamp: 'I 6/2/2024 13:03:51' prior: 50613029!
listOfBooks

	^listOfBooks! !

!testRun: #CartTest #test01 stamp: 'I 6/2/2024 13:03:54'!
PASSED!

!testRun: #CartTest #test01 stamp: 'I 6/2/2024 13:03:54'!
PASSED!

String class!

String class class!

String class class class!

String class class class class!

Metaclass class!

Behavior class!

Behavior class class!

Behavior superclass!

Behavior superclass superclass !

Behavior superclass superclass superclass !

Behavior superclass superclass class!

Behavior superclass superclass class class!

Class class!

Class class class!

Object new self!

Object new !

self superclass!

self superclass!

self class superclass!

self class superclass = ProtoObject !

self class superclass = self class!

self super = self !

!testRun: #CartTest #test01 stamp: 'I 6/2/2024 13:30:57'!
PASSED!

!testRun: #CartTest #test01 stamp: 'I 6/2/2024 13:30:57'!
PASSED!
!CartTest methodsFor: 'tests' stamp: 'I 6/2/2024 13:31:40' prior: 50612987!
test01
	|cart|
	
	cart := Cart new.
	
	self assert: (Dictionary new) equals: (cart listOfBooks).
! !
!Cart methodsFor: 'as yet unclassified' stamp: 'I 6/2/2024 13:31:46' prior: 50613023 overrides: 16932297!
initialize 
	listOfBooks := Dictionary new.
	! !
!Cart methodsFor: 'Purchases' stamp: 'I 6/2/2024 13:47:07'!
listCart

	^listOfBooks! !
!CartTest methodsFor: 'as yet unclassified' stamp: 'I 6/2/2024 13:47:07' prior: 50613064!
test01
	|cart|
	
	cart := Cart new.
	
	self assert: (Dictionary new) equals: (cart listCart).
! !

!methodRemoval: Cart #listOfBooks stamp: 'I 6/2/2024 13:47:07'!
listOfBooks

	^listOfBooks!
!CartTest methodsFor: 'tests' stamp: 'I 6/2/2024 13:47:15'!
test02AddABookToACart
	|cart book expectedDictionary|
	
	expectedDictionary := (Dictionary new) at: 1928374617 put: 2.
	
	book := 1928374617.
	
	cart := Cart new.
	
	cart addToCart: book withQuantity: 2.
	
	
	self assert: (expectedDictionary ) equals: (cart listCart).
! !
!CartTest methodsFor: 'tests' stamp: 'I 6/2/2024 13:47:39' prior: 50613087!
test02AddABookToACart
	|cart book |
	
	
	book := 1928374617.
	
	cart := Cart new.
	
	cart addToCart: book withQuantity: 2.
	
	
	self assert: (OrderedCollection with: 1928374617 with: 2 ) equals: (cart listCart).
! !
!CartTest methodsFor: 'tests' stamp: 'I 6/2/2024 13:56:28' prior: 50613098!
test02AddABookToACart
	|cart book catalog|
	
	
	book := 1928374617.
	
	catalog := Catalog with: book.
	cart := Cart withCatalog: catalog .
	
	cart addToCart: book withQuantity: 2.
	
	
	self assert: (OrderedCollection with: 1928374617 with: 2 ) equals: (cart listCart).
! !
!CartTest methodsFor: 'tests' stamp: 'I 6/2/2024 14:28:43' prior: 50613108!
test02AddABookToACart
	|cart book catalog|
	
	
	book := 1928374617.
	
	catalog := Catalog with: book.
	cart := Cart withCatalog: catalog .
	
	
	cart addToCart: book withQuantity: 2.
	
	
	self assert: (OrderedCollection with: 1928374617 with: 2 ) equals: (cart listCart).
! !

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/2/2024 14:28:44'!
ERROR!
!Catalog class methodsFor: 'instance creation' stamp: 'I 6/2/2024 14:28:52'!
with: book 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeWith: book ! !
!Catalog class methodsFor: 'instance creation' stamp: 'I 6/2/2024 14:29:08' prior: 50613133!
with: bookISBN
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	^self new initializeWith: bookISBN ! !

!classDefinition: #Catalog category: #'Tools-Finder-Model' stamp: 'I 6/2/2024 14:29:36'!
Object subclass: #Catalog
	instanceVariableNames: 'bookISBN_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Finder-Model'!
!Catalog methodsFor: 'initialization' stamp: 'I 6/2/2024 14:29:36'!
initializeWith: bookISBN 
	self shouldBeImplemented.
	bookISBN_CHANGE_ME := bookISBN.! !

!classDefinition: #CatalogBook category: #'TusLibros.com' stamp: 'I 6/2/2024 14:30:00'!
Object subclass: #CatalogBook
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!
!CartTest methodsFor: 'tests' stamp: 'I 6/2/2024 14:29:56' prior: 50613119!
test02AddABookToACart
	|cart book catalog|
	
	
	book := 1928374617.
	
	catalog := CatalogBook with: book.
	cart := Cart withCatalog: catalog .
	
	
	cart addToCart: book withQuantity: 2.
	
	
	self assert: (OrderedCollection with: 1928374617 with: 2 ) equals: (cart listCart).
! !

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/2/2024 14:30:02'!
ERROR!
!CatalogBook class methodsFor: 'instance creation' stamp: 'I 6/2/2024 14:30:07'!
with: book 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeWith: book ! !
!CatalogBook class methodsFor: 'instance creation' stamp: 'I 6/2/2024 14:30:14' prior: 50613182!
with: book 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	^self new initializeWith: book ! !
!CatalogBook class methodsFor: 'instance creation' stamp: 'I 6/2/2024 14:30:21' prior: 50613190!
with: bookISBN 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	^self new initializeWith: bookISBN ! !

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/2/2024 14:30:25'!
ERROR!

!classDefinition: #CatalogBook category: #'TusLibros.com' stamp: 'I 6/2/2024 14:30:34'!
Object subclass: #CatalogBook
	instanceVariableNames: 'bookISBN_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!
!CatalogBook methodsFor: 'initialization' stamp: 'I 6/2/2024 14:30:34'!
initializeWith: bookISBN 
	self shouldBeImplemented.
	bookISBN_CHANGE_ME := bookISBN.! !
!CatalogBook methodsFor: 'initialization' stamp: 'I 6/2/2024 14:31:40' prior: 50613214!
initializeWith: bookISBN 

	bookISBN_CHANGE_ME := Dictionary new.
	
	bookISBN_CHANGE_ME at: bookISBN put: 2.! !

!classDefinition: #CatalogBook category: #'TusLibros.com' stamp: 'I 6/2/2024 14:31:52'!
Object subclass: #CatalogBook
	instanceVariableNames: 'catalogs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!
!CatalogBook methodsFor: 'as yet unclassified' stamp: 'I 6/2/2024 14:31:52' prior: 50613220!
initializeWith: bookISBN 

	catalogs := Dictionary new.
	
	catalogs at: bookISBN put: 2.! !

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/2/2024 14:31:59'!
ERROR!
!Cart class methodsFor: 'instance creation' stamp: 'I 6/2/2024 14:32:04'!
withCatalog: catalog 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeWithCatalog: catalog ! !
!Cart class methodsFor: 'instance creation' stamp: 'I 6/2/2024 14:32:09' prior: 50613242!
withCatalog: catalog 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	^self new initializeWithCatalog: catalog ! !

Object subclass: #Cart
	instanceVariableNames: 'listOfBooks catalogs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classDefinition: #Cart category: #'TusLibros.com' stamp: 'I 6/2/2024 14:32:22'!
Object subclass: #Cart
	instanceVariableNames: 'listOfBooks catalogs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/2/2024 14:32:29'!
ERROR!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/2/2024 14:32:29'!
ERROR!

!classDefinition: #Cart category: #'TusLibros.com' stamp: 'I 6/2/2024 14:32:37'!
Object subclass: #Cart
	instanceVariableNames: 'listOfBooks catalogs catalog_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!
!Cart methodsFor: 'initialization' stamp: 'I 6/2/2024 14:32:37'!
initializeWithCatalog: catalog 
	self shouldBeImplemented.
	catalog_CHANGE_ME := catalog.! !
!Cart methodsFor: 'initialization' stamp: 'I 6/2/2024 14:32:49' prior: 50613071 overrides: 16932297!
initialize 
	listOfBooks := Dictionary new.
	! !
!Cart methodsFor: 'initialization' stamp: 'I 6/2/2024 14:33:07' prior: 50613281!
initializeWithCatalog: catalog 

	catalog_CHANGE_ME := catalog.! !
!Cart methodsFor: 'initialization' stamp: 'I 6/2/2024 14:33:16' prior: 50613293!
initializeWithCatalog: catalog 

	catalogs := catalog.! !

Object subclass: #Cart
	instanceVariableNames: 'listOfBooks catalogs '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classDefinition: #Cart category: #'TusLibros.com' stamp: 'I 6/2/2024 14:33:20'!
Object subclass: #Cart
	instanceVariableNames: 'listOfBooks catalogs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/2/2024 14:33:25'!
ERROR!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/2/2024 14:33:25'!
ERROR!
!Cart methodsFor: 'adding' stamp: 'I 6/2/2024 14:33:41'!
addToCart: book withQuantity: aRenameMe1 
	self shouldBeImplemented.! !
!Cart methodsFor: 'adding' stamp: 'I 6/2/2024 14:56:09' prior: 50613319!
addToCart: book withQuantity: quantity
	self validQuantity: quantity .
	
	listOfBooks at: book put: quantity .
	! !

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/2/2024 14:56:17'!
ERROR!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/2/2024 14:56:17'!
ERROR!
!Cart methodsFor: 'testing' stamp: 'I 6/2/2024 14:56:29'!
validQuantity: quantity 
	self shouldBeImplemented.! !
!Cart methodsFor: 'testing' stamp: 'I 6/2/2024 14:57:38' prior: 50613335!
validQuantity: quantity 
	(quantity > 0) ifFalse:[^self error: 'Invalid number']! !

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/2/2024 14:57:41'!
FAILURE!
!Cart methodsFor: 'Purchases' stamp: 'I 6/2/2024 15:09:42' prior: 50613075!
listCart
	
	|list|
	
	list := OrderedCollection new.
	
	listOfBooks keysAndValuesDo:[:book :quant | (list add: book ) add: quant].
	
	^list! !

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/2/2024 15:09:45'!
ERROR!

(list add: book ) !
!Cart methodsFor: 'Purchases' stamp: 'I 6/2/2024 15:11:11' prior: 50613348!
listCart
	
	|list|
	
	list := OrderedCollection new.
	
	listOfBooks keysAndValuesDo:[:book :quant | list add: book  . list add: quant].
	
	^list! !

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/2/2024 15:11:17'!
PASSED!

!testRun: #CartTest #test01 stamp: 'I 6/2/2024 15:11:17'!
FAILURE!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/2/2024 15:11:17'!
PASSED!

!testRun: #CartTest #test01 stamp: 'I 6/2/2024 15:11:17'!
FAILURE!

!testRun: #CartTest #test01 stamp: 'I 6/2/2024 15:11:21'!
FAILURE!

!testRun: #CartTest #test01 stamp: 'I 6/2/2024 15:11:21'!
FAILURE!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/2/2024 15:11:23'!
PASSED!
!CartTest methodsFor: 'tests' stamp: 'I 6/2/2024 15:11:35' prior: 50613079!
test01
	|cart|
	
	cart := Cart new.
	
	self assert: (OrderedCollection new) equals: (cart listCart).
! !

!testRun: #CartTest #test01 stamp: 'I 6/2/2024 15:11:36'!
PASSED!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/2/2024 15:11:36'!
PASSED!
!CartTest methodsFor: 'tests' stamp: 'I 6/2/2024 15:21:17' prior: 50613168!
test02AddABookToACart
	|cart book catalog bookOutOfPrint|
	
	bookOutOfPrint := 1928374614.
	book := 1928374617.
	
	catalog := CatalogBook with: book.
	cart := Cart withCatalog: catalog .
	
	
	cart addToCart: book withQuantity: 2.
	
	
	self assert: (OrderedCollection with: 1928374617 with: 2 ) equals: (cart listCart).
! !
!CartTest methodsFor: 'tests' stamp: 'I 6/2/2024 15:23:52' prior: 50613394!
test02AddABookToACart
	|cart book catalog bookOutOfPrint|
	
	bookOutOfPrint := 1928374614.
	book := 1928374617.
	
	catalog := CatalogBook with: book.
	cart := Cart withCatalog: catalog .
	
	
	self should: [cart addToCart: bookOutOfPrint withQuantity: 2] 
	raise:  Error
	description: [:errorMessage | self assert: errorMessage equals: (catalog error: catalog outOfPrint) ]! !

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/2/2024 15:23:55'!
FAILURE!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/2/2024 15:23:55'!
ERROR!
!Cart methodsFor: 'adding' stamp: 'I 6/2/2024 15:24:28' prior: 50613324!
addToCart: book withQuantity: quantity
	self validQuantity: quantity .
	catalogs assertISBNOfBook: book.
	
	listOfBooks at: book put: quantity .
	! !

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/2/2024 15:24:33'!
PASSED!

!testRun: #CartTest #test01 stamp: 'I 6/2/2024 15:24:33'!
PASSED!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/2/2024 15:24:33'!
PASSED!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/2/2024 15:24:35'!
PASSED!

!testRun: #CartTest #test01 stamp: 'I 6/2/2024 15:24:35'!
PASSED!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/2/2024 15:24:35'!
PASSED!
!CartTest methodsFor: 'tests' stamp: 'I 6/2/2024 15:24:41'!
test03AddABookToACart
	|cart book catalog bookOutOfPrint|
	
	bookOutOfPrint := 1928374614.
	book := 1928374617.
	
	catalog := CatalogBook with: book.
	cart := Cart withCatalog: catalog .
	
	
	self should: [cart addToCart: bookOutOfPrint withQuantity: 2] 
	raise:  Error
	description: [:errorMessage | self assert: errorMessage equals: (catalog error: catalog outOfPrint) ]! !
!CartTest methodsFor: 'tests' stamp: 'I 6/2/2024 15:24:52'!
test03BookOutOfPrint
	|cart book catalog bookOutOfPrint|
	
	bookOutOfPrint := 1928374614.
	book := 1928374617.
	
	catalog := CatalogBook with: book.
	cart := Cart withCatalog: catalog .
	
	
	self should: [cart addToCart: bookOutOfPrint withQuantity: 2] 
	raise:  Error
	description: [:errorMessage | self assert: errorMessage equals: (catalog error: catalog outOfPrint) ]! !

!methodRemoval: CartTest #test03AddABookToACart stamp: 'I 6/2/2024 15:24:54'!
test03AddABookToACart
	|cart book catalog bookOutOfPrint|
	
	bookOutOfPrint := 1928374614.
	book := 1928374617.
	
	catalog := CatalogBook with: book.
	cart := Cart withCatalog: catalog .
	
	
	self should: [cart addToCart: bookOutOfPrint withQuantity: 2] 
	raise:  Error
	description: [:errorMessage | self assert: errorMessage equals: (catalog error: catalog outOfPrint) ]!

!testRun: #CartTest #test03BookOutOfPrint stamp: 'I 6/2/2024 15:24:57'!
PASSED!

!testRun: #CartTest #test01 stamp: 'I 6/2/2024 15:24:57'!
PASSED!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/2/2024 15:24:57'!
PASSED!

!testRun: #CartTest #test03BookOutOfPrint stamp: 'I 6/2/2024 15:24:57'!
PASSED!

!testRun: #CartTest #test03BookOutOfPrint stamp: 'I 6/2/2024 15:24:59'!
PASSED!

!testRun: #CartTest #test01 stamp: 'I 6/2/2024 15:24:59'!
PASSED!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/2/2024 15:24:59'!
PASSED!

!testRun: #CartTest #test03BookOutOfPrint stamp: 'I 6/2/2024 15:24:59'!
PASSED!

!testRun: #CartTest #test03BookOutOfPrint stamp: 'I 6/2/2024 15:25:19'!
PASSED!
!CartTest methodsFor: 'tests' stamp: 'I 6/2/2024 15:25:53' prior: 50613462!
test03BookOutOfPrint
	|cart book catalog bookOutOfPrint|
	
	bookOutOfPrint := 1928374614.
	book := 1928374617.
	
	catalog := CatalogBook with: book.
	cart := Cart withCatalog: catalog .
	
	
	self should: [cart addToCart: bookOutOfPrint withQuantity: 2] 
	raise:  Error - MessageNotUnderstood 
	description: [:anError | self assert: anError equals: (catalog error: catalog outOfPrint) ]! !

!testRun: #CartTest #test03BookOutOfPrint stamp: 'I 6/2/2024 15:25:55'!
ERROR!
!CatalogBook methodsFor: 'testing' stamp: 'I 6/2/2024 15:26:06'!
assertISBNOfBook: book 
	self shouldBeImplemented.! !
!CatalogBook methodsFor: 'testing' stamp: 'I 6/2/2024 15:28:13' prior: 50613530!
assertISBNOfBook: book 
	catalogs at: book ifAbsent: [self class OutOfPrint].
	! !
!CatalogBook methodsFor: 'testing' stamp: 'I 6/2/2024 15:29:08' prior: 50613535!
assertISBNOfBook: book 
	catalogs at: book ifAbsent: [self class error: (self class OutOfPrint)].
	! !

!testRun: #CartTest #test03BookOutOfPrint stamp: 'I 6/2/2024 15:29:19'!
ERROR!
!CatalogBook class methodsFor: 'error' stamp: 'I 6/2/2024 15:29:27'!
OutOfPrint
	self shouldBeImplemented.! !
!CatalogBook class methodsFor: 'error' stamp: 'I 6/2/2024 15:29:52' prior: 50613549!
OutOfPrint
	^'Book out of print'! !

!testRun: #CartTest #test03BookOutOfPrint stamp: 'I 6/2/2024 15:29:55'!
PASSED!

!testRun: #CartTest #test01 stamp: 'I 6/2/2024 15:29:55'!
PASSED!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/2/2024 15:29:55'!
PASSED!

!testRun: #CartTest #test03BookOutOfPrint stamp: 'I 6/2/2024 15:29:55'!
PASSED!

!testRun: #CartTest #test03BookOutOfPrint stamp: 'I 6/2/2024 15:30:04'!
PASSED!

!testRun: #CartTest #test01 stamp: 'I 6/2/2024 15:30:04'!
PASSED!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/2/2024 15:30:04'!
PASSED!

!testRun: #CartTest #test03BookOutOfPrint stamp: 'I 6/2/2024 15:30:04'!
PASSED!

!testRun: #CartTest #test03BookOutOfPrint stamp: 'I 6/2/2024 15:30:09'!
PASSED!

!testRun: #CartTest #test01 stamp: 'I 6/2/2024 15:30:09'!
PASSED!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/2/2024 15:30:09'!
PASSED!

!testRun: #CartTest #test03BookOutOfPrint stamp: 'I 6/2/2024 15:30:09'!
PASSED!

self value!

!testRun: #CartTest #test03BookOutOfPrint stamp: 'I 6/2/2024 15:31:46'!
PASSED!

----STARTUP---- (2 June 2024 15:34:33) as /home/ivan/Documents/Facu/Inge 1/linux64/linux64/CuisUniversity-6169.image!


!classDefinition: #Cart category: #'TusLibros.com' stamp: 'I 6/2/2024 15:34:35'!
Object subclass: #Cart
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classDefinition: #Cart category: #'TusLibros.com' stamp: 'I 6/2/2024 15:34:35'!
Object subclass: #Cart
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classDefinition: #CartTest category: #'TusLibros.com' stamp: 'I 6/2/2024 15:34:35'!
TestCase subclass: #CartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classDefinition: #CartTest category: #'TusLibros.com' stamp: 'I 6/2/2024 15:34:35'!
TestCase subclass: #CartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!
!CartTest methodsFor: 'no messages' stamp: 'I 6/1/2024 22:33:45'!
test01CreateCartExpectsEmptyCart
! !

!classDefinition: #Cart category: #'TusLibros.com' stamp: 'I 6/2/2024 15:34:35'!
Object subclass: #Cart
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classDefinition: #Cart category: #'TusLibros.com' stamp: 'I 6/2/2024 15:34:35'!
Object subclass: #Cart
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classDefinition: #CartTest category: #'TusLibros.com' stamp: 'I 6/2/2024 15:34:35'!
TestCase subclass: #CartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classDefinition: #CartTest category: #'TusLibros.com' stamp: 'I 6/2/2024 15:34:35'!
TestCase subclass: #CartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classDefinition: #Client category: #'TusLibros.com' stamp: 'I 6/2/2024 15:34:35'!
Object subclass: #Client
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classDefinition: #Client category: #'TusLibros.com' stamp: 'I 6/2/2024 15:34:35'!
Object subclass: #Client
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classDefinition: #MerchantProcessor category: #'TusLibros.com' stamp: 'I 6/2/2024 15:34:35'!
Object subclass: #MerchantProcessor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classDefinition: #MerchantProcessor category: #'TusLibros.com' stamp: 'I 6/2/2024 15:34:35'!
Object subclass: #MerchantProcessor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!
!CartTest methodsFor: 'nil' stamp: 'I 6/2/2024 12:51:18'!
test01! !
!CartTest methodsFor: 'tests' stamp: 'I 6/2/2024 12:57:02' prior: 50613676!
test01
	|cart|
	
	cart := Cart new.
! !
!CartTest methodsFor: 'tests' stamp: 'I 6/2/2024 13:01:50' prior: 50613679!
test01
	|cart|
	
	cart := Cart new.
	
	self assert: (OrderedCollection new) equals: (cart listOfBooks).
! !

!classRemoval: #Client stamp: 'I 6/2/2024 15:34:36'!
Object subclass: #Client
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classRemoval: #MerchantProcessor stamp: 'I 6/2/2024 15:34:36'!
Object subclass: #MerchantProcessor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classDefinition: #Cart category: #'TusLibros.com' stamp: 'I 6/2/2024 15:34:36'!
Object subclass: #Cart
	instanceVariableNames: 'listOfBooks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classDefinition: #Cart category: #'TusLibros.com' stamp: 'I 6/2/2024 15:34:36'!
Object subclass: #Cart
	instanceVariableNames: 'listOfBooks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!
!Cart methodsFor: 'nil' stamp: 'I 6/2/2024 13:02:57' overrides: 16932297!
initialize 
	listOfBooks := OrderedCollection new.! !
!Cart methodsFor: 'as yet unclassified' stamp: 'I 6/2/2024 13:02:59' prior: 50613715 overrides: 16932297!
initialize 
	listOfBooks := OrderedCollection new.
	! !
!Cart methodsFor: 'Purchases' stamp: 'I 6/2/2024 13:03:46'!
listOfBooks
	self shouldBeImplemented.
	^listOfBooks! !
!Cart methodsFor: 'Purchases' stamp: 'I 6/2/2024 13:03:51' prior: 50613724!
listOfBooks

	^listOfBooks! !
!CartTest methodsFor: 'tests' stamp: 'I 6/2/2024 13:31:40' prior: 50613683!
test01
	|cart|
	
	cart := Cart new.
	
	self assert: (Dictionary new) equals: (cart listOfBooks).
! !
!Cart methodsFor: 'as yet unclassified' stamp: 'I 6/2/2024 13:31:46' prior: 50613720 overrides: 16932297!
initialize 
	listOfBooks := Dictionary new.
	! !
!Cart methodsFor: 'Purchases' stamp: 'I 6/2/2024 13:47:07'!
listCart

	^listOfBooks! !
!CartTest methodsFor: 'as yet unclassified' stamp: 'I 6/2/2024 13:47:07' prior: 50613733!
test01
	|cart|
	
	cart := Cart new.
	
	self assert: (Dictionary new) equals: (cart listCart).
! !

!methodRemoval: Cart #listOfBooks stamp: 'I 6/2/2024 15:34:36'!
listOfBooks

	^listOfBooks!
!CartTest methodsFor: 'tests' stamp: 'I 6/2/2024 13:47:15'!
test02AddABookToACart
	|cart book expectedDictionary|
	
	expectedDictionary := (Dictionary new) at: 1928374617 put: 2.
	
	book := 1928374617.
	
	cart := Cart new.
	
	cart addToCart: book withQuantity: 2.
	
	
	self assert: (expectedDictionary ) equals: (cart listCart).
! !
!CartTest methodsFor: 'tests' stamp: 'I 6/2/2024 13:47:39' prior: 50613756!
test02AddABookToACart
	|cart book |
	
	
	book := 1928374617.
	
	cart := Cart new.
	
	cart addToCart: book withQuantity: 2.
	
	
	self assert: (OrderedCollection with: 1928374617 with: 2 ) equals: (cart listCart).
! !
!CartTest methodsFor: 'tests' stamp: 'I 6/2/2024 13:56:28' prior: 50613767!
test02AddABookToACart
	|cart book catalog|
	
	
	book := 1928374617.
	
	catalog := Catalog with: book.
	cart := Cart withCatalog: catalog .
	
	cart addToCart: book withQuantity: 2.
	
	
	self assert: (OrderedCollection with: 1928374617 with: 2 ) equals: (cart listCart).
! !
!CartTest methodsFor: 'tests' stamp: 'I 6/2/2024 14:28:43' prior: 50613777!
test02AddABookToACart
	|cart book catalog|
	
	
	book := 1928374617.
	
	catalog := Catalog with: book.
	cart := Cart withCatalog: catalog .
	
	
	cart addToCart: book withQuantity: 2.
	
	
	self assert: (OrderedCollection with: 1928374617 with: 2 ) equals: (cart listCart).
! !
!Catalog class methodsFor: 'instance creation' stamp: 'I 6/2/2024 14:28:52'!
with: book 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeWith: book ! !
!Catalog class methodsFor: 'instance creation' stamp: 'I 6/2/2024 14:29:08' prior: 50613799!
with: bookISBN
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	^self new initializeWith: bookISBN ! !

!classDefinition: #Catalog category: #'Tools-Finder-Model' stamp: 'I 6/2/2024 15:34:36'!
Object subclass: #Catalog
	instanceVariableNames: 'bookISBN_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Finder-Model'!
!Catalog methodsFor: 'initialization' stamp: 'I 6/2/2024 14:29:36'!
initializeWith: bookISBN 
	self shouldBeImplemented.
	bookISBN_CHANGE_ME := bookISBN.! !

!classDefinition: #CatalogBook category: #'TusLibros.com' stamp: 'I 6/2/2024 15:34:36'!
Object subclass: #CatalogBook
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!
!CartTest methodsFor: 'tests' stamp: 'I 6/2/2024 14:29:56' prior: 50613788!
test02AddABookToACart
	|cart book catalog|
	
	
	book := 1928374617.
	
	catalog := CatalogBook with: book.
	cart := Cart withCatalog: catalog .
	
	
	cart addToCart: book withQuantity: 2.
	
	
	self assert: (OrderedCollection with: 1928374617 with: 2 ) equals: (cart listCart).
! !
!CatalogBook class methodsFor: 'instance creation' stamp: 'I 6/2/2024 14:30:07'!
with: book 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeWith: book ! !
!CatalogBook class methodsFor: 'instance creation' stamp: 'I 6/2/2024 14:30:14' prior: 50613846!
with: book 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	^self new initializeWith: book ! !
!CatalogBook class methodsFor: 'instance creation' stamp: 'I 6/2/2024 14:30:21' prior: 50613854!
with: bookISBN 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	^self new initializeWith: bookISBN ! !

!classDefinition: #CatalogBook category: #'TusLibros.com' stamp: 'I 6/2/2024 15:34:36'!
Object subclass: #CatalogBook
	instanceVariableNames: 'bookISBN_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!
!CatalogBook methodsFor: 'initialization' stamp: 'I 6/2/2024 14:30:34'!
initializeWith: bookISBN 
	self shouldBeImplemented.
	bookISBN_CHANGE_ME := bookISBN.! !
!CatalogBook methodsFor: 'initialization' stamp: 'I 6/2/2024 14:31:40' prior: 50613875!
initializeWith: bookISBN 

	bookISBN_CHANGE_ME := Dictionary new.
	
	bookISBN_CHANGE_ME at: bookISBN put: 2.! !

!classDefinition: #CatalogBook category: #'TusLibros.com' stamp: 'I 6/2/2024 15:34:36'!
Object subclass: #CatalogBook
	instanceVariableNames: 'catalogs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!
!CatalogBook methodsFor: 'as yet unclassified' stamp: 'I 6/2/2024 14:31:52' prior: 50613881!
initializeWith: bookISBN 

	catalogs := Dictionary new.
	
	catalogs at: bookISBN put: 2.! !
!Cart class methodsFor: 'instance creation' stamp: 'I 6/2/2024 14:32:04'!
withCatalog: catalog 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeWithCatalog: catalog ! !
!Cart class methodsFor: 'instance creation' stamp: 'I 6/2/2024 14:32:09' prior: 50613901!
withCatalog: catalog 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	^self new initializeWithCatalog: catalog ! !

!classDefinition: #Cart category: #'TusLibros.com' stamp: 'I 6/2/2024 15:34:37'!
Object subclass: #Cart
	instanceVariableNames: 'listOfBooks catalogs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classDefinition: #Cart category: #'TusLibros.com' stamp: 'I 6/2/2024 15:34:37'!
Object subclass: #Cart
	instanceVariableNames: 'listOfBooks catalogs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classDefinition: #Cart category: #'TusLibros.com' stamp: 'I 6/2/2024 15:34:37'!
Object subclass: #Cart
	instanceVariableNames: 'listOfBooks catalogs catalog_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!
!Cart methodsFor: 'initialization' stamp: 'I 6/2/2024 14:32:37'!
initializeWithCatalog: catalog 
	self shouldBeImplemented.
	catalog_CHANGE_ME := catalog.! !
!Cart methodsFor: 'initialization' stamp: 'I 6/2/2024 14:32:49' prior: 50613740 overrides: 16932297!
initialize 
	listOfBooks := Dictionary new.
	! !
!Cart methodsFor: 'initialization' stamp: 'I 6/2/2024 14:33:07' prior: 50613938!
initializeWithCatalog: catalog 

	catalog_CHANGE_ME := catalog.! !
!Cart methodsFor: 'initialization' stamp: 'I 6/2/2024 14:33:16' prior: 50613950!
initializeWithCatalog: catalog 

	catalogs := catalog.! !

!classDefinition: #Cart category: #'TusLibros.com' stamp: 'I 6/2/2024 15:34:37'!
Object subclass: #Cart
	instanceVariableNames: 'listOfBooks catalogs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classDefinition: #Cart category: #'TusLibros.com' stamp: 'I 6/2/2024 15:34:37'!
Object subclass: #Cart
	instanceVariableNames: 'listOfBooks catalogs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!
!Cart methodsFor: 'adding' stamp: 'I 6/2/2024 14:33:41'!
addToCart: book withQuantity: aRenameMe1 
	self shouldBeImplemented.! !
!Cart methodsFor: 'adding' stamp: 'I 6/2/2024 14:56:09' prior: 50613973!
addToCart: book withQuantity: quantity
	self validQuantity: quantity .
	
	listOfBooks at: book put: quantity .
	! !
!Cart methodsFor: 'testing' stamp: 'I 6/2/2024 14:56:29'!
validQuantity: quantity 
	self shouldBeImplemented.! !
!Cart methodsFor: 'testing' stamp: 'I 6/2/2024 14:57:38' prior: 50613984!
validQuantity: quantity 
	(quantity > 0) ifFalse:[^self error: 'Invalid number']! !
!Cart methodsFor: 'Purchases' stamp: 'I 6/2/2024 15:09:42' prior: 50613744!
listCart
	
	|list|
	
	list := OrderedCollection new.
	
	listOfBooks keysAndValuesDo:[:book :quant | (list add: book ) add: quant].
	
	^list! !
!Cart methodsFor: 'Purchases' stamp: 'I 6/2/2024 15:11:11' prior: 50613994!
listCart
	
	|list|
	
	list := OrderedCollection new.
	
	listOfBooks keysAndValuesDo:[:book :quant | list add: book  . list add: quant].
	
	^list! !
!CartTest methodsFor: 'tests' stamp: 'I 6/2/2024 15:11:35' prior: 50613748!
test01
	|cart|
	
	cart := Cart new.
	
	self assert: (OrderedCollection new) equals: (cart listCart).
! !
!CartTest methodsFor: 'tests' stamp: 'I 6/2/2024 15:21:17' prior: 50613834!
test02AddABookToACart
	|cart book catalog bookOutOfPrint|
	
	bookOutOfPrint := 1928374614.
	book := 1928374617.
	
	catalog := CatalogBook with: book.
	cart := Cart withCatalog: catalog .
	
	
	cart addToCart: book withQuantity: 2.
	
	
	self assert: (OrderedCollection with: 1928374617 with: 2 ) equals: (cart listCart).
! !
!CartTest methodsFor: 'tests' stamp: 'I 6/2/2024 15:23:52' prior: 50614014!
test02AddABookToACart
	|cart book catalog bookOutOfPrint|
	
	bookOutOfPrint := 1928374614.
	book := 1928374617.
	
	catalog := CatalogBook with: book.
	cart := Cart withCatalog: catalog .
	
	
	self should: [cart addToCart: bookOutOfPrint withQuantity: 2] 
	raise:  Error
	description: [:errorMessage | self assert: errorMessage equals: (catalog error: catalog outOfPrint) ]! !
!Cart methodsFor: 'adding' stamp: 'I 6/2/2024 15:24:28' prior: 50613978!
addToCart: book withQuantity: quantity
	self validQuantity: quantity .
	catalogs assertISBNOfBook: book.
	
	listOfBooks at: book put: quantity .
	! !
!CartTest methodsFor: 'tests' stamp: 'I 6/2/2024 15:24:41'!
test03AddABookToACart
	|cart book catalog bookOutOfPrint|
	
	bookOutOfPrint := 1928374614.
	book := 1928374617.
	
	catalog := CatalogBook with: book.
	cart := Cart withCatalog: catalog .
	
	
	self should: [cart addToCart: bookOutOfPrint withQuantity: 2] 
	raise:  Error
	description: [:errorMessage | self assert: errorMessage equals: (catalog error: catalog outOfPrint) ]! !
!CartTest methodsFor: 'tests' stamp: 'I 6/2/2024 15:24:52'!
test03BookOutOfPrint
	|cart book catalog bookOutOfPrint|
	
	bookOutOfPrint := 1928374614.
	book := 1928374617.
	
	catalog := CatalogBook with: book.
	cart := Cart withCatalog: catalog .
	
	
	self should: [cart addToCart: bookOutOfPrint withQuantity: 2] 
	raise:  Error
	description: [:errorMessage | self assert: errorMessage equals: (catalog error: catalog outOfPrint) ]! !

!methodRemoval: CartTest #test03AddABookToACart stamp: 'I 6/2/2024 15:34:37'!
test03AddABookToACart
	|cart book catalog bookOutOfPrint|
	
	bookOutOfPrint := 1928374614.
	book := 1928374617.
	
	catalog := CatalogBook with: book.
	cart := Cart withCatalog: catalog .
	
	
	self should: [cart addToCart: bookOutOfPrint withQuantity: 2] 
	raise:  Error
	description: [:errorMessage | self assert: errorMessage equals: (catalog error: catalog outOfPrint) ]!
!CartTest methodsFor: 'tests' stamp: 'I 6/2/2024 15:25:53' prior: 50614063!
test03BookOutOfPrint
	|cart book catalog bookOutOfPrint|
	
	bookOutOfPrint := 1928374614.
	book := 1928374617.
	
	catalog := CatalogBook with: book.
	cart := Cart withCatalog: catalog .
	
	
	self should: [cart addToCart: bookOutOfPrint withQuantity: 2] 
	raise:  Error - MessageNotUnderstood 
	description: [:anError | self assert: anError equals: (catalog error: catalog outOfPrint) ]! !
!CatalogBook methodsFor: 'testing' stamp: 'I 6/2/2024 15:26:06'!
assertISBNOfBook: book 
	self shouldBeImplemented.! !
!CatalogBook methodsFor: 'testing' stamp: 'I 6/2/2024 15:28:13' prior: 50614107!
assertISBNOfBook: book 
	catalogs at: book ifAbsent: [self class OutOfPrint].
	! !
!CatalogBook methodsFor: 'testing' stamp: 'I 6/2/2024 15:29:08' prior: 50614112!
assertISBNOfBook: book 
	catalogs at: book ifAbsent: [self class error: (self class OutOfPrint)].
	! !
!CatalogBook class methodsFor: 'error' stamp: 'I 6/2/2024 15:29:27'!
OutOfPrint
	self shouldBeImplemented.! !
!CatalogBook class methodsFor: 'error' stamp: 'I 6/2/2024 15:29:52' prior: 50614124!
OutOfPrint
	^'Book out of print'! !

!methodRemoval: CartTest #test01CreateCartExpectsEmptyCart stamp: 'I 6/2/2024 15:34:45'!
test01CreateCartExpectsEmptyCart
!
!CartTest methodsFor: 'tests' stamp: 'I 6/2/2024 15:35:49' prior: 50614027!
test02AddABookToACart
	|cart book catalog |
	

	book := 1928374617.
	
	catalog := CatalogBook with: book.
	cart := Cart withCatalog: catalog .
	
	
	cart addToCart: book withQuantity: 2.
	
	self assert: (OrderedCollection with: book with: 2) equals: (cart listCart ).! !

!testRun: #CartTest #test01 stamp: 'I 6/2/2024 15:35:51'!
PASSED!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/2/2024 15:35:51'!
PASSED!

!testRun: #CartTest #test03BookOutOfPrint stamp: 'I 6/2/2024 15:35:51'!
PASSED!
!Cart methodsFor: 'testing' stamp: 'I 6/2/2024 16:00:37' prior: 50613989!
validQuantity: quantity 
	(quantity > 0) ifFalse:[^self class error: (self class invalidNumber)].! !
!CartTest methodsFor: 'tests' stamp: 'I 6/2/2024 16:01:11'!
test04InvalidQuantity
	|cart book catalog bookOutOfPrint|
	
	bookOutOfPrint := 1928374614.
	book := 1928374617.
	
	catalog := CatalogBook with: book.
	cart := Cart withCatalog: catalog .
	
	
	self should: [cart addToCart: bookOutOfPrint withQuantity: -1] 
	raise:  Error - MessageNotUnderstood 
	description: [:anError | self assert: anError equals: (Cart class error: (Cart invalidNumber)) ]! !

!testRun: #CartTest #test04InvalidQuantity stamp: 'I 6/2/2024 16:01:14'!
ERROR!
!Cart class methodsFor: 'error' stamp: 'I 6/2/2024 16:01:22'!
invalidNumber
	self shouldBeImplemented.! !
!Cart class methodsFor: 'error' stamp: 'I 6/2/2024 16:01:33' prior: 50614177!
invalidNumber
	^'Invalid Number'! !

!testRun: #CartTest #test04InvalidQuantity stamp: 'I 6/2/2024 16:01:35'!
PASSED!

!testRun: #CartTest #test01 stamp: 'I 6/2/2024 16:01:35'!
PASSED!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/2/2024 16:01:35'!
PASSED!

!testRun: #CartTest #test03BookOutOfPrint stamp: 'I 6/2/2024 16:01:35'!
PASSED!

!testRun: #CartTest #test04InvalidQuantity stamp: 'I 6/2/2024 16:01:35'!
PASSED!

----QUIT----(3 June 2024 00:19:15) CuisUniversity-6169.image priorSource: 8999469!

----STARTUP---- (5 June 2024 17:46:39) as /home/ivan/Documents/Facu/Inge 1/linux64/linux64/CuisUniversity-6169.image!


!classRemoval: #CatalogBook stamp: 'I 6/5/2024 17:46:43'!
Object subclass: #CatalogBook
	instanceVariableNames: 'catalogs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classRemoval: #Cart stamp: 'I 6/5/2024 17:46:44'!
Object subclass: #Cart
	instanceVariableNames: 'listOfBooks catalogs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classRemoval: #CartTest stamp: 'I 6/5/2024 17:46:44'!
TestCase subclass: #CartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

----End fileIn of /home/ivan/Downloads/TusLibros.com.st----!

!testRun: #CashierTest #test02CashierCheckOutACartWithOneBook stamp: 'I 6/5/2024 18:16:22'!
FAILURE!

!testRun: #CashierTest #test01CashierCantCheckOutAnEmptyCart stamp: 'I 6/5/2024 18:16:45'!
PASSED!

!testRun: #CashierTest #test02CashierCheckOutACartWithOneBook stamp: 'I 6/5/2024 18:16:45'!
FAILURE!

!testRun: #CashierTest #test02CashierCheckOutACartWithOneBook stamp: 'I 6/5/2024 18:16:45'!
FAILURE!
!Cashier methodsFor: 'checking' stamp: 'I 6/5/2024 18:28:02' prior: 50614418!
checkOut: cart 
	|total|
	
	total := 0.
	
	self assertIsNotEmpty: cart. 

	
	(cart listCart) do: [:aBook :aQuant| total := total + (cart priceFor: aBook)* aQuant ].
	
	^total! !

!testRun: #CartTest #test01CreateCartMeansIsEmpty stamp: 'I 6/5/2024 18:28:06'!
PASSED!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/5/2024 18:28:06'!
FAILURE!

!testRun: #CartTest #test03BookOutOfPrint stamp: 'I 6/5/2024 18:28:06'!
PASSED!

!testRun: #CartTest #test04InvalidQuantity stamp: 'I 6/5/2024 18:28:06'!
PASSED!

!testRun: #CartTest #test05RememberBookInCart stamp: 'I 6/5/2024 18:28:06'!
ERROR!

!testRun: #CashierTest #test02CashierCheckOutACartWithOneBook stamp: 'I 6/5/2024 18:28:15'!
ERROR!

!testRun: #CashierTest #test02CashierCheckOutACartWithOneBook stamp: 'I 6/5/2024 18:28:21'!
ERROR!
!Cashier methodsFor: 'checking' stamp: 'I 6/5/2024 18:29:45' prior: 50614450!
checkOut: cart 
	|total|
	
	total := 0.
	
	self assertIsNotEmpty: cart. 

	
	(cart listCart) keysAndValuesDo: [:aBook :aQuant| total := total + (cart priceFor: aBook)* aQuant ].
	
	^total! !

!testRun: #CashierTest #test02CashierCheckOutACartWithOneBook stamp: 'I 6/5/2024 18:29:48'!
ERROR!
!Cart methodsFor: 'as yet unclassified' stamp: 'I 6/5/2024 18:30:41'!
priceFor: aBook 
	self shouldBeImplemented.! !
!Cart methodsFor: 'as yet unclassified' stamp: 'I 6/5/2024 18:31:13' prior: 50614490!
priceFor: aBook 
	^catalogs at:aBook.! !
!CashierTest methodsFor: 'tests' stamp: 'I 6/5/2024 18:31:44' prior: 50614313!
test02CashierCheckOutACartWithOneBook
	|cashier cart book catalog total|
	
	book := 1928374617.
	
	catalog := Dictionary new.
	catalog at: book put: 10.
	cart := Cart withCatalog: catalog .
	
	cart add: book.
	cashier := Cashier new.
	
	total := cashier checkOut: cart.
	
	self assert: 10 equals: total.! !

!testRun: #CashierTest #test02CashierCheckOutACartWithOneBook stamp: 'I 6/5/2024 18:31:44'!
PASSED!

!testRun: #CashierTest #test01CashierCantCheckOutAnEmptyCart stamp: 'I 6/5/2024 18:31:44'!
PASSED!

!testRun: #CashierTest #test02CashierCheckOutACartWithOneBook stamp: 'I 6/5/2024 18:31:44'!
PASSED!
!CashierTest methodsFor: 'tests' stamp: 'I 6/5/2024 18:33:01'!
test03CashierCheckOutACartWithTwoBook
	|cashier cart book anotherBook catalog total|
	
	book := 1928374617.
	anotherBook := 1913374617.
	
	catalog := Dictionary new.
	catalog at: book put: 10.
	catalog at: anotherBook put: 20.
	cart := Cart withCatalog: catalog .
	
	cart add: book.
	cashier := Cashier new.
	
	total := cashier checkOut: cart.
	
	self assert: 30 equals: total.! !

!testRun: #CashierTest #test03CashierCheckOutACartWithTwoBook stamp: 'I 6/5/2024 18:33:03'!
FAILURE!
!CashierTest methodsFor: 'tests' stamp: 'I 6/5/2024 18:33:17' prior: 50614520!
test03CashierCheckOutACartWithTwoBook
	|cashier cart book anotherBook catalog total|
	
	book := 1928374617.
	anotherBook := 1913374617.
	
	catalog := Dictionary new.
	catalog at: book put: 10.
	catalog at: anotherBook put: 20.
	cart := Cart withCatalog: catalog .
	
	cart add: book.
	cart add: anotherBook .
	cashier := Cashier new.
	
	total := cashier checkOut: cart.
	
	self assert: 30 equals: total.! !

!testRun: #CashierTest #test03CashierCheckOutACartWithTwoBook stamp: 'I 6/5/2024 18:33:18'!
PASSED!

!testRun: #CashierTest #test01CashierCantCheckOutAnEmptyCart stamp: 'I 6/5/2024 18:33:18'!
PASSED!

!testRun: #CashierTest #test02CashierCheckOutACartWithOneBook stamp: 'I 6/5/2024 18:33:18'!
PASSED!

!testRun: #CashierTest #test03CashierCheckOutACartWithTwoBook stamp: 'I 6/5/2024 18:33:18'!
PASSED!
!CashierTest methodsFor: 'tests' stamp: 'I 6/5/2024 18:33:32'!
test04CashierCheckOutACartWithTwoBookAndMoreThanOne
	|cashier cart book anotherBook catalog total|
	
	book := 1928374617.
	anotherBook := 1913374617.
	
	catalog := Dictionary new.
	catalog at: book put: 10.
	catalog at: anotherBook put: 20.
	cart := Cart withCatalog: catalog .
	
	cart add: book.
	cart add: anotherBook .
	cashier := Cashier new.
	
	total := cashier checkOut: cart.
	
	self assert: 30 equals: total.! !
!CashierTest methodsFor: 'tests' stamp: 'I 6/5/2024 18:34:12' prior: 50614566!
test04CashierCheckOutACartWithTwoBookAndMoreThanOne
	|cashier cart book anotherBook catalog total|
	
	book := 1928374617.
	anotherBook := 1913374617.
	
	catalog := Dictionary new.
	catalog at: book put: 10.
	catalog at: anotherBook put: 20.
	cart := Cart withCatalog: catalog .
	
	cart add: book.
	cart addToCart: anotherBook withQuantity:2. 
	cashier := Cashier new.
	
	total := cashier checkOut: cart.
	
	self assert: 50 equals: total.! !

!testRun: #CashierTest #test04CashierCheckOutACartWithTwoBookAndMoreThanOne stamp: 'I 6/5/2024 18:34:14'!
ERROR!

!testRun: #CashierTest #test04CashierCheckOutACartWithTwoBookAndMoreThanOne stamp: 'I 6/5/2024 18:34:21'!
ERROR!

!testRun: #CashierTest #test04CashierCheckOutACartWithTwoBookAndMoreThanOne stamp: 'I 6/5/2024 18:34:34'!
ERROR!
!Cart methodsFor: 'adding' stamp: 'I 6/5/2024 18:35:02' prior: 50614367!
assertISBNOfBook: book
	(catalogs includesKey: book) ifFalse:[self class error: (self class OutOfPrint)]! !

!testRun: #CashierTest #test04CashierCheckOutACartWithTwoBookAndMoreThanOne stamp: 'I 6/5/2024 18:35:05'!
FAILURE!

catalogs at:aBook!
!Cart methodsFor: 'as yet unclassified' stamp: 'I 6/5/2024 18:37:16' prior: 50614495!
priceFor: aBook 
	^catalogs at:aBook.! !
!Cashier methodsFor: 'checking' stamp: 'I 6/5/2024 18:37:28' prior: 50614478!
checkOut: cart 
	|total|
	
	total := 0.
	
	self assertIsNotEmpty: cart. 

	
	(cart listCart) keysAndValuesDo: [:aBook :aQuant| total := total +( (cart priceFor: aBook)* aQuant) ].
	
	^total! !

!testRun: #CashierTest #test04CashierCheckOutACartWithTwoBookAndMoreThanOne stamp: 'I 6/5/2024 18:37:31'!
PASSED!

!testRun: #CashierTest #test01CashierCantCheckOutAnEmptyCart stamp: 'I 6/5/2024 18:37:31'!
PASSED!

!testRun: #CashierTest #test02CashierCheckOutACartWithOneBook stamp: 'I 6/5/2024 18:37:31'!
PASSED!

!testRun: #CashierTest #test03CashierCheckOutACartWithTwoBook stamp: 'I 6/5/2024 18:37:31'!
PASSED!

!testRun: #CashierTest #test04CashierCheckOutACartWithTwoBookAndMoreThanOne stamp: 'I 6/5/2024 18:37:31'!
PASSED!

!testRun: #CartTest #test01CreateCartMeansIsEmpty stamp: 'I 6/5/2024 18:39:48'!
PASSED!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/5/2024 18:39:48'!
ERROR!

!testRun: #CartTest #test03BookOutOfPrint stamp: 'I 6/5/2024 18:39:48'!
ERROR!

!testRun: #CartTest #test04InvalidQuantity stamp: 'I 6/5/2024 18:39:48'!
PASSED!

!testRun: #CartTest #test05RememberBookInCart stamp: 'I 6/5/2024 18:39:48'!
ERROR!
!CartTest methodsFor: 'tests' stamp: 'I 6/5/2024 18:40:34' prior: 50614237!
test02AddABookToACart
	|cart book catalog expectedListCart|
	
	expectedListCart:= Dictionary new.
	expectedListCart at: 1928374617 put:2.
	book := 1928374617.
	
	catalog := OrderedCollection with: book.
	cart := Cart withCatalog: catalog .
	
	
	cart addToCart: book withQuantity: 2.
	
	self assert: (OrderedCollection with: book with: 2) equals: (cart listCart ).! !

!testRun: #CartTest #test01CreateCartMeansIsEmpty stamp: 'I 6/5/2024 18:40:40'!
PASSED!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/5/2024 18:40:40'!
ERROR!

!testRun: #CartTest #test03BookOutOfPrint stamp: 'I 6/5/2024 18:40:40'!
ERROR!

!testRun: #CartTest #test04InvalidQuantity stamp: 'I 6/5/2024 18:40:40'!
PASSED!

!testRun: #CartTest #test05RememberBookInCart stamp: 'I 6/5/2024 18:40:40'!
ERROR!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/5/2024 18:40:43'!
ERROR!
!CartTest methodsFor: 'tests' stamp: 'I 6/5/2024 18:40:56' prior: 50614663!
test02AddABookToACart
	|cart book catalog expectedListCart|
	
	expectedListCart:= Dictionary new.
	expectedListCart at: 1928374617 put:2.
	book := 1928374617.
	
	catalog := OrderedCollection with: book.
	cart := Cart withCatalog: catalog .
	
	
	cart addToCart: book withQuantity: 2.
	
	self assert: expectedListCart equals: (cart listCart ).! !

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/5/2024 18:40:59'!
ERROR!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/5/2024 18:41:08'!
ERROR!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/5/2024 18:41:31'!
ERROR!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/5/2024 18:41:33'!
ERROR!
!Cart methodsFor: 'adding' stamp: 'I 6/5/2024 18:42:02' prior: 50614609!
assertISBNOfBook: book
	(catalogs includes: book) ifFalse:[self class error: (self class OutOfPrint)]! !

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/5/2024 18:42:07'!
PASSED!

!testRun: #CartTest #test01CreateCartMeansIsEmpty stamp: 'I 6/5/2024 18:42:08'!
PASSED!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/5/2024 18:42:08'!
PASSED!

!testRun: #CartTest #test03BookOutOfPrint stamp: 'I 6/5/2024 18:42:08'!
PASSED!

!testRun: #CartTest #test04InvalidQuantity stamp: 'I 6/5/2024 18:42:08'!
PASSED!

!testRun: #CartTest #test05RememberBookInCart stamp: 'I 6/5/2024 18:42:08'!
ERROR!

!testRun: #CartTest #test05RememberBookInCart stamp: 'I 6/5/2024 18:42:08'!
ERROR!

!testRun: #CartTest #test01CreateCartMeansIsEmpty stamp: 'I 6/5/2024 18:42:14'!
PASSED!

!testRun: #CartTest #test03BookOutOfPrint stamp: 'I 6/5/2024 18:42:15'!
PASSED!

!testRun: #CartTest #test04InvalidQuantity stamp: 'I 6/5/2024 18:42:16'!
PASSED!

!testRun: #CartTest #test05RememberBookInCart stamp: 'I 6/5/2024 18:42:18'!
ERROR!

!testRun: #CartTest #test05RememberBookInCart stamp: 'I 6/5/2024 18:42:18'!
ERROR!
!Cart methodsFor: 'testing' stamp: 'I 6/5/2024 18:43:03' prior: 50614373!
includes: book 
	^listOfBooks includes: book.! !

!testRun: #CartTest #test01CreateCartMeansIsEmpty stamp: 'I 6/5/2024 18:43:12'!
PASSED!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/5/2024 18:43:12'!
PASSED!

!testRun: #CartTest #test03BookOutOfPrint stamp: 'I 6/5/2024 18:43:12'!
PASSED!

!testRun: #CartTest #test04InvalidQuantity stamp: 'I 6/5/2024 18:43:12'!
PASSED!

!testRun: #CartTest #test05RememberBookInCart stamp: 'I 6/5/2024 18:43:12'!
PASSED!

!testRun: #CashierTest #test01CashierCantCheckOutAnEmptyCart stamp: 'I 6/5/2024 18:43:13'!
PASSED!

!testRun: #CashierTest #test02CashierCheckOutACartWithOneBook stamp: 'I 6/5/2024 18:43:13'!
PASSED!

!testRun: #CashierTest #test03CashierCheckOutACartWithTwoBook stamp: 'I 6/5/2024 18:43:13'!
PASSED!

!testRun: #CashierTest #test04CashierCheckOutACartWithTwoBookAndMoreThanOne stamp: 'I 6/5/2024 18:43:13'!
ERROR!

!testRun: #CashierTest #test04CashierCheckOutACartWithTwoBookAndMoreThanOne stamp: 'I 6/5/2024 18:43:13'!
ERROR!

!testRun: #CashierTest #test01CashierCantCheckOutAnEmptyCart stamp: 'I 6/5/2024 18:43:17'!
PASSED!

!testRun: #CashierTest #test02CashierCheckOutACartWithOneBook stamp: 'I 6/5/2024 18:43:18'!
PASSED!

!testRun: #CashierTest #test02CashierCheckOutACartWithOneBook stamp: 'I 6/5/2024 18:43:19'!
PASSED!

!testRun: #CashierTest #test03CashierCheckOutACartWithTwoBook stamp: 'I 6/5/2024 18:43:21'!
PASSED!

!testRun: #CashierTest #test04CashierCheckOutACartWithTwoBookAndMoreThanOne stamp: 'I 6/5/2024 18:43:32'!
ERROR!

!testRun: #CashierTest #test04CashierCheckOutACartWithTwoBookAndMoreThanOne stamp: 'I 6/5/2024 18:43:51'!
ERROR!
!Cart methodsFor: 'adding' stamp: 'I 6/5/2024 18:44:59' prior: 50614717!
assertISBNOfBook: book
	(catalogs includesKey: book) ifFalse:[self class error: (self class OutOfPrint)]! !

!testRun: #CashierTest #test01CashierCantCheckOutAnEmptyCart stamp: 'I 6/5/2024 18:45:03'!
PASSED!

!testRun: #CashierTest #test02CashierCheckOutACartWithOneBook stamp: 'I 6/5/2024 18:45:03'!
PASSED!

!testRun: #CashierTest #test03CashierCheckOutACartWithTwoBook stamp: 'I 6/5/2024 18:45:03'!
PASSED!

!testRun: #CashierTest #test04CashierCheckOutACartWithTwoBookAndMoreThanOne stamp: 'I 6/5/2024 18:45:03'!
PASSED!

!testRun: #CartTest #test01CreateCartMeansIsEmpty stamp: 'I 6/5/2024 18:45:05'!
PASSED!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/5/2024 18:45:05'!
ERROR!

!testRun: #CartTest #test03BookOutOfPrint stamp: 'I 6/5/2024 18:45:05'!
ERROR!

!testRun: #CartTest #test04InvalidQuantity stamp: 'I 6/5/2024 18:45:05'!
PASSED!

!testRun: #CartTest #test05RememberBookInCart stamp: 'I 6/5/2024 18:45:05'!
ERROR!
!CartTest methodsFor: 'tests' stamp: 'I 6/5/2024 18:45:44' prior: 50614693!
test02AddABookToACart
	|cart book catalog expectedListCart|
	
	expectedListCart:= Dictionary new.
	expectedListCart at: 1928374617 put:2.
	book := 1928374617.
	
	catalog := Dictionary new.
	catalog at: book put: 10.
	cart := Cart withCatalog: catalog .
	
	
	cart addToCart: book withQuantity: 2.
	
	self assert: expectedListCart equals: (cart listCart ).! !

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/5/2024 18:45:45'!
PASSED!

!testRun: #CartTest #test01CreateCartMeansIsEmpty stamp: 'I 6/5/2024 18:45:45'!
PASSED!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/5/2024 18:45:45'!
PASSED!

!testRun: #CartTest #test03BookOutOfPrint stamp: 'I 6/5/2024 18:45:45'!
ERROR!

!testRun: #CartTest #test04InvalidQuantity stamp: 'I 6/5/2024 18:45:45'!
PASSED!

!testRun: #CartTest #test05RememberBookInCart stamp: 'I 6/5/2024 18:45:45'!
ERROR!
!CartTest methodsFor: 'tests' stamp: 'I 6/5/2024 18:45:55' prior: 50614248!
test03BookOutOfPrint
	|cart book catalog bookOutOfPrint|
	
	bookOutOfPrint := 1928374614.
	book := 1928374617.
	
	catalog := Dictionary new.
	cart := Cart withCatalog: catalog .
	
	
	self should: [cart addToCart: bookOutOfPrint withQuantity: 2] 
	raise:  Error - MessageNotUnderstood 
	description: [:anError | self assert: anError equals: (catalog error: catalog outOfPrint) ]! !
!CartTest methodsFor: 'tests' stamp: 'I 6/5/2024 18:46:01' prior: 50614870!
test03BookOutOfPrint
	|cart book catalog bookOutOfPrint|
	
	bookOutOfPrint := 1928374614.
	book := 1928374617.
	
	catalog := Dictionary new.
		catalog at: book put: 10.
	cart := Cart withCatalog: catalog .
	
	
	self should: [cart addToCart: bookOutOfPrint withQuantity: 2] 
	raise:  Error - MessageNotUnderstood 
	description: [:anError | self assert: anError equals: (catalog error: catalog outOfPrint) ]! !
!CartTest methodsFor: 'tests' stamp: 'I 6/5/2024 18:46:04' prior: 50614885!
test03BookOutOfPrint
	|cart book catalog bookOutOfPrint|
	
	bookOutOfPrint := 1928374614.
	book := 1928374617.
	
	catalog := Dictionary new.
	catalog at: book put: 10.
	cart := Cart withCatalog: catalog .
	
	
	self should: [cart addToCart: bookOutOfPrint withQuantity: 2] 
	raise:  Error - MessageNotUnderstood 
	description: [:anError | self assert: anError equals: (catalog error: catalog outOfPrint) ]! !

!testRun: #CartTest #test03BookOutOfPrint stamp: 'I 6/5/2024 18:46:05'!
PASSED!

!testRun: #CartTest #test01CreateCartMeansIsEmpty stamp: 'I 6/5/2024 18:46:05'!
PASSED!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/5/2024 18:46:05'!
PASSED!

!testRun: #CartTest #test03BookOutOfPrint stamp: 'I 6/5/2024 18:46:05'!
PASSED!

!testRun: #CartTest #test04InvalidQuantity stamp: 'I 6/5/2024 18:46:05'!
PASSED!

!testRun: #CartTest #test05RememberBookInCart stamp: 'I 6/5/2024 18:46:05'!
ERROR!

!testRun: #CartTest #test05RememberBookInCart stamp: 'I 6/5/2024 18:46:05'!
ERROR!

!testRun: #CartTest #test03BookOutOfPrint stamp: 'I 6/5/2024 18:46:10'!
PASSED!

!testRun: #CartTest #test05RememberBookInCart stamp: 'I 6/5/2024 18:46:11'!
ERROR!

!testRun: #CartTest #test05RememberBookInCart stamp: 'I 6/5/2024 18:46:11'!
ERROR!
!CartTest methodsFor: 'tests' stamp: 'I 6/5/2024 18:46:24' prior: 50614263!
test04InvalidQuantity
	|cart book catalog bookOutOfPrint|
	
	bookOutOfPrint := 1928374614.
	book := 1928374617.
	
	catalog := Dictionary new.
	catalog at: book put: 10.
	cart := Cart withCatalog: catalog .
	
	
	self should: [cart addToCart: bookOutOfPrint withQuantity: -1] 
	raise:  Error - MessageNotUnderstood 
	description: [:anError | self assert: anError equals: (Cart class error: (Cart invalidNumber)) ]! !
!CartTest methodsFor: 'tests' stamp: 'I 6/5/2024 18:46:29' prior: 50614278!
test05RememberBookInCart
	|cart book catalog bookOutOfPrint|
	
	bookOutOfPrint := 1928374614.
	book := 1928374617.
	
	catalog := Dictionary new.
	catalog at: book put: 10.
	cart := Cart withCatalog: catalog .
	
	cart addToCart: book withQuantity: 1.
	
	self assert: (cart includes: book).
	self deny: (cart includes: bookOutOfPrint )! !

!testRun: #CartTest #test01CreateCartMeansIsEmpty stamp: 'I 6/5/2024 18:48:46'!
PASSED!

!testRun: #CartTest #test02AddABookToACart stamp: 'I 6/5/2024 18:48:46'!
PASSED!

!testRun: #CartTest #test03BookOutOfPrint stamp: 'I 6/5/2024 18:48:46'!
PASSED!

!testRun: #CartTest #test04InvalidQuantity stamp: 'I 6/5/2024 18:48:46'!
PASSED!

!testRun: #CartTest #test05RememberBookInCart stamp: 'I 6/5/2024 18:48:46'!
PASSED!

!testRun: #CashierTest #test01CashierCantCheckOutAnEmptyCart stamp: 'I 6/5/2024 18:48:48'!
PASSED!

!testRun: #CashierTest #test02CashierCheckOutACartWithOneBook stamp: 'I 6/5/2024 18:48:48'!
PASSED!

!testRun: #CashierTest #test03CashierCheckOutACartWithTwoBook stamp: 'I 6/5/2024 18:48:48'!
PASSED!

!testRun: #CashierTest #test04CashierCheckOutACartWithTwoBookAndMoreThanOne stamp: 'I 6/5/2024 18:48:48'!
PASSED!
!CashierTest methodsFor: 'tests' stamp: 'I 6/5/2024 18:49:04' prior: 50614538!
test03CashierCheckOutACartWithTwoBook
	|cashier cart book anotherBook catalog total |
	
	book := 1928374617.
	anotherBook := 1913374617.
	
	catalog := Dictionary new.
	catalog at: book put: 10.
	catalog at: anotherBook put: 20.
	cart := Cart withCatalog: catalog .
	
	cart add: book.
	cart add: anotherBook .
	cashier := Cashier new.
	
	total := cashier checkOut: cart.
	
	self assert: 30 equals: total.! !

05/21!

Date !

x := 06!

Date today !

Date dayOfWeek: 5!

Date dayOfWeek: 1!

Date daysInYear: 2!

Date daysInYear: 1!

Date daysInYear: 3!

Date dayOfWeek!

Date dayOfWeek!

Date new dayOfWeek !

x:= Date new
x dayOfWeek !

x month!

x month!

Year yearNumber: 2!

Year current !

Year new yearNumber !

!classDefinition: #CreditCar category: #'TusLibros.com' stamp: 'I 6/5/2024 19:02:58'!
Object subclass: #CreditCar
	instanceVariableNames: 'expitarionDate ownerName cardNumber'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!
!CashierTest methodsFor: 'tests' stamp: 'I 6/5/2024 19:02:32' prior: 50614999!
test03CashierCheckOutACartWithTwoBook
	|cashier cart book anotherBook catalog total creditCard|
	
	creditCard := CreditCar withNumber: 1003812903712037 withExpirationDate: 022030 withOwner: 'Jose'.
	
	book := 1928374617.
	anotherBook := 1913374617.
	
	catalog := Dictionary new.
	catalog at: book put: 10.
	catalog at: anotherBook put: 20.
	cart := Cart withCatalog: catalog .
	
	cart add: book.
	cart add: anotherBook .
	cashier := Cashier new.
	
	total := cashier checkOut: cart.
	
	self assert: 30 equals: total.! !
!CashierTest methodsFor: 'tests' stamp: 'I 6/5/2024 19:03:29'!
test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook
	|cashier cart book anotherBook catalog total creditCard|
	
	creditCard := CreditCar withNumber: 1003812903712037 withExpirationDate: 022030 withOwner: 'Jose'.
	
	book := 1928374617.
	anotherBook := 1913374617.
	
	catalog := Dictionary new.
	catalog at: book put: 10.
	catalog at: anotherBook put: 20.
	cart := Cart withCatalog: catalog .
	
	cart add: book.
	cart add: anotherBook .
	cashier := Cashier new.
	
	total := cashier checkOut: cart.
	
	self assert: 30 equals: total.! !

x := 023010!
!CashierTest methodsFor: 'tests' stamp: 'I 6/5/2024 19:06:19' prior: 50615051!
test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook
	|cashier cart book anotherBook catalog total creditCard|
	
	creditCard := CreditCar withNumber: 1003812903712037 withExpirationDate: '022030' withOwner: 'Jose'.
	
	book := 1928374617.
	anotherBook := 1913374617.
	
	catalog := Dictionary new.
	catalog at: book put: 10.
	catalog at: anotherBook put: 20.
	cart := Cart withCatalog: catalog .
	
	cart add: book.
	cart add: anotherBook .
	cashier := Cashier new.
	
	total := cashier checkOut: cart.
	
	self assert: 30 equals: total.! !

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/5/2024 19:06:23'!
ERROR!
!CreditCar class methodsFor: 'instance creation' stamp: 'I 6/5/2024 19:06:27'!
withNumber: aRenameMe1 withExpirationDate: aRenameMe2 withOwner: aRenameMe3 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeWithNumber: aRenameMe1 withExpirationDate: aRenameMe2 withOwner: aRenameMe3 ! !
!CreditCar class methodsFor: 'instance creation' stamp: 'I 6/5/2024 19:07:36' prior: 50615095!
withNumber: aCardNumber withExpirationDate: expirationDate withOwner: cardOwner 

	^self new initializeWithNumber: aCardNumber withExpirationDate: expirationDate withOwner: cardOwner ! !

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/5/2024 19:08:00'!
ERROR!

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/5/2024 19:08:00'!
ERROR!

!classDefinition: #CreditCar category: #'TusLibros.com' stamp: 'I 6/5/2024 19:08:07'!
Object subclass: #CreditCar
	instanceVariableNames: 'expitarionDate ownerName cardNumber expirationDate_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classDefinition: #CreditCar category: #'TusLibros.com' stamp: 'I 6/5/2024 19:08:07'!
Object subclass: #CreditCar
	instanceVariableNames: 'expitarionDate ownerName cardNumber expirationDate_CHANGE_ME cardOwner_CHANGE_ME'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!
!CreditCar methodsFor: 'initialization' stamp: 'I 6/5/2024 19:08:07'!
initializeWithNumber: aCardNumber withExpirationDate: expirationDate withOwner: cardOwner 
	self shouldBeImplemented.
	cardNumber := aCardNumber.
	expirationDate_CHANGE_ME := expirationDate.
	cardOwner_CHANGE_ME := cardOwner.! !
!CreditCar methodsFor: 'initialization' stamp: 'I 6/5/2024 19:08:43' prior: 50615141!
initializeWithNumber: aCardNumber withExpirationDate: expirationDateOfCard withOwner: cardOwnerOfCard
	
	cardNumber := aCardNumber.
	expirationDate_CHANGE_ME := expirationDateOfCard.
	cardOwner_CHANGE_ME := cardOwnerOfCard .! !

Object subclass: #CreditCar
	instanceVariableNames: 'expitarionDate ownerName cardNumber  '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classDefinition: #CreditCar category: #'TusLibros.com' stamp: 'I 6/5/2024 19:09:01'!
Object subclass: #CreditCar
	instanceVariableNames: 'expitarionDate ownerName cardNumber'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!
!CreditCar methodsFor: 'initialization' stamp: 'I 6/5/2024 19:09:40' prior: 50615151!
initializeWithNumber: aCardNumber withExpirationDate: expirationDateOfCard withOwner: cardOwnerOfCard
	
	cardNumber := aCardNumber.
	expitarionDate := expirationDateOfCard.
	ownerName := cardOwnerOfCard .! !

7 date !

Date today!

Date month!

Date monthOfYear !

	Date monthNumber !

	Date new monthNumber !

monthName := currentDate monthName!

monthName := currentDate monthNumber!

| currentDate monthNumber |
currentDate := Date today.
monthNumber := currentDate month.
Transcript show: 'El mes actual es: ', monthNumber printString.!

| currentDate monthNumber |
currentDate := Date today.
monthNumber := currentDate month.
Transcript show: 'El mes actual es: ', monthNumber printString.!

Date dateAndTimeNow !

Date today!

GregorianDate month!

GregorianDate april!

GregorianMonth april!

Date today month!

	Date today month monthIndex !
!CreditCar class methodsFor: 'instance creation' stamp: 'I 6/5/2024 23:40:51' prior: 50615107!
withNumber: aCardNumber withExpirationDate: expirationDate withOwner: cardOwner 
	(self subclasses detect:[:subclass| subclass canHandleNumber: aCardNumber anExpirationDate: expirationDate]) withNumber: aCardNumber withExpirationDate: expirationDate withOwner: cardOwner .
"
	^self new initializeWithNumber: aCardNumber withExpirationDate: expirationDate withOwner: cardOwner "! !
!CreditCar methodsFor: 'initialization' stamp: 'I 6/5/2024 23:41:14' prior: 50615174!
initializeWithNumber: aCardNumber withExpirationDate: expirationDateOfCard withOwner: cardOwnerOfCard
	
	self subclassResponsibility ! !

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/5/2024 23:41:22'!
ERROR!

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/5/2024 23:41:30'!
ERROR!

CreditCar subclass: #InvalidCreditCard
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classDefinition: #InvalidCreditCard category: #'TusLibros.com' stamp: 'I 6/5/2024 23:42:02'!
CreditCar subclass: #InvalidCreditCard
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classRenamed: #CreditCar as: #CreditCard stamp: 'I 6/5/2024 23:42:07'!
Smalltalk renameClassNamed: #CreditCar as: #CreditCard!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'I 6/5/2024 23:42:07' prior: 50615032!
test03CashierCheckOutACartWithTwoBook
	|cashier cart book anotherBook catalog total creditCard|
	
	creditCard := CreditCard withNumber: 1003812903712037 withExpirationDate: 022030 withOwner: 'Jose'.
	
	book := 1928374617.
	anotherBook := 1913374617.
	
	catalog := Dictionary new.
	catalog at: book put: 10.
	catalog at: anotherBook put: 20.
	cart := Cart withCatalog: catalog .
	
	cart add: book.
	cart add: anotherBook .
	cashier := Cashier new.
	
	total := cashier checkOut: cart.
	
	self assert: 30 equals: total.! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'I 6/5/2024 23:42:07' prior: 50615071!
test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook
	|cashier cart book anotherBook catalog total creditCard|
	
	creditCard := CreditCard withNumber: 1003812903712037 withExpirationDate: '022030' withOwner: 'Jose'.
	
	book := 1928374617.
	anotherBook := 1913374617.
	
	catalog := Dictionary new.
	catalog at: book put: 10.
	catalog at: anotherBook put: 20.
	cart := Cart withCatalog: catalog .
	
	cart add: book.
	cart add: anotherBook .
	cashier := Cashier new.
	
	total := cashier checkOut: cart.
	
	self assert: 30 equals: total.! !

CreditCard subclass: #ValidCreditCard
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!classDefinition: #ValidCreditCard category: #'TusLibros.com' stamp: 'I 6/5/2024 23:42:24'!
CreditCard subclass: #ValidCreditCard
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros.com'!

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/5/2024 23:42:39'!
ERROR!

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/5/2024 23:42:39'!
ERROR!
!InvalidCreditCard class methodsFor: 'assert' stamp: 'I 6/5/2024 23:42:51'!
canHandleNumber: aCardNumber anExpirationDate: expirationDate 
	self shouldBeImplemented.! !
!InvalidCreditCard class methodsFor: 'assert' stamp: 'I 6/5/2024 23:52:25' prior: 50615309!
canHandleNumber: aCardNumber anExpirationDate: expirationDate 
	((aCardNumber length = 16) not) or:[self assertDate: expirationDate].! !

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/5/2024 23:52:33'!
ERROR!

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/5/2024 23:52:48'!
ERROR!

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/5/2024 23:53:20'!
ERROR!
!InvalidCreditCard class methodsFor: 'assert' stamp: 'I 6/5/2024 23:53:28' prior: 50615315!
canHandleNumber: aCardNumber anExpirationDate: expirationDate 
	((aCardNumber size = 16) not) or:[self assertDate: expirationDate].! !

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/5/2024 23:53:32'!
ERROR!

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/5/2024 23:53:50'!
ERROR!

aCardNumber size!

'hola' size !
!InvalidCreditCard class methodsFor: 'assert' stamp: 'I 6/5/2024 23:54:36' prior: 50615334!
canHandleNumber: aCardNumber anExpirationDate: expirationDate 
	(((aCardNumber size) = 16) not) or:[self assertDate: expirationDate].! !

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/5/2024 23:54:41'!
ERROR!
!CashierTest methodsFor: 'tests' stamp: 'I 6/5/2024 23:55:00' prior: 50615270!
test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook
	|cashier cart book anotherBook catalog total creditCard|
	
	creditCard := CreditCard withNumber: '1003812903712037' withExpirationDate: '022030' withOwner: 'Jose'.
	
	book := 1928374617.
	anotherBook := 1913374617.
	
	catalog := Dictionary new.
	catalog at: book put: 10.
	catalog at: anotherBook put: 20.
	cart := Cart withCatalog: catalog .
	
	cart add: book.
	cart add: anotherBook .
	cashier := Cashier new.
	
	total := cashier checkOut: cart.
	
	self assert: 30 equals: total.! !

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/5/2024 23:55:03'!
ERROR!
!InvalidCreditCard class methodsFor: 'assert' stamp: 'I 6/5/2024 23:55:13'!
assertDate: expirationDate 
	self shouldBeImplemented.! !
!InvalidCreditCard class methodsFor: 'assert' stamp: 'I 6/5/2024 23:56:24' prior: 50615385!
assertDate: expirationDate 
	| month year currentYear currentMonth |
	
	month := expirationDate copyFrom: 1 to: 2.
	year := expirationDate copyFrom: 3 to: 6.

	"Convertir los valores a números"
	month := month asInteger.
	year := year asInteger.

	"Obtener el mes y año actual"
	currentYear := Date today year.
	currentMonth := Date today month.

	"Validar el formato y la validez de la fecha"
	(month between: 1 and: 12)
	    ifFalse: [^'Mes inválido'].
	(year < currentYear or: (year = currentYear and: month < currentMonth))
	    ifTrue: [^'Fecha de expiración ya pasada'].! !

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/5/2024 23:56:35'!
ERROR!
!InvalidCreditCard class methodsFor: 'assert' stamp: 'I 6/6/2024 00:03:58' prior: 50615390!
assertDate: expirationDate 
	| month year currentYear currentMonth |
	
	month := (expirationDate at: 1 , (expirationDate at: 2))asInteger .
	year := expirationDate copyFrom: 3 .

	"Convertir los valores a números"
	month := month asInteger.
	year := year asInteger.

	"Obtener el mes y año actual"
	currentYear := Date today year.
	currentMonth := Date today month.

	"Validar el formato y la validez de la fecha"
	(month between: 1 and: 12)
	    ifFalse: [^'Mes inválido'].
	(year < currentYear or: (year = currentYear and: month < currentMonth))
	    ifTrue: [^'Fecha de expiración ya pasada'].! !

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/6/2024 00:04:06'!
ERROR!

(expirationDate at: 2)!
!InvalidCreditCard class methodsFor: 'assert' stamp: 'I 6/6/2024 00:04:38' prior: 50615415!
assertDate: expirationDate 
	| month year currentYear currentMonth |
	
	month := ((expirationDate at: 1 asString) , (expirationDate at: 2)asString )asInteger .
	year := expirationDate copyFrom: 3 .

	"Convertir los valores a números"
	month := month asInteger.
	year := year asInteger.

	"Obtener el mes y año actual"
	currentYear := Date today year.
	currentMonth := Date today month.

	"Validar el formato y la validez de la fecha"
	(month between: 1 and: 12)
	    ifFalse: [^'Mes inválido'].
	(year < currentYear or: (year = currentYear and: month < currentMonth))
	    ifTrue: [^'Fecha de expiración ya pasada'].! !

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/6/2024 00:04:41'!
ERROR!
!InvalidCreditCard class methodsFor: 'assert' stamp: 'I 6/6/2024 00:04:57' prior: 50615442!
assertDate: expirationDate 
	| month year currentYear currentMonth |
	
	month := (((expirationDate at: 1) asString) , (expirationDate at: 2)asString )asInteger .
	year := expirationDate copyFrom: 3 .

	"Convertir los valores a números"
	month := month asInteger.
	year := year asInteger.

	"Obtener el mes y año actual"
	currentYear := Date today year.
	currentMonth := Date today month.

	"Validar el formato y la validez de la fecha"
	(month between: 1 and: 12)
	    ifFalse: [^'Mes inválido'].
	(year < currentYear or: (year = currentYear and: month < currentMonth))
	    ifTrue: [^'Fecha de expiración ya pasada'].! !

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/6/2024 00:05:03'!
ERROR!

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/6/2024 00:05:33'!
ERROR!
!InvalidCreditCard class methodsFor: 'assert' stamp: 'I 6/6/2024 00:06:29' prior: 50615469!
assertDate: expirationDate 
	| month year currentYear currentMonth |
	
	month := ((expirationDate at: 1) asInteger ) ,((expirationDate at: 2)asInteger) .
	year := expirationDate copyFrom: 3 .

	"Convertir los valores a números"
	month := month asInteger.
	year := year asInteger.

	"Obtener el mes y año actual"
	currentYear := Date today year.
	currentMonth := Date today month.

	"Validar el formato y la validez de la fecha"
	(month between: 1 and: 12)
	    ifFalse: [^'Mes inválido'].
	(year < currentYear or: (year = currentYear and: month < currentMonth))
	    ifTrue: [^'Fecha de expiración ya pasada'].! !

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/6/2024 00:06:34'!
ERROR!

$2 asInteger !

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/6/2024 00:08:01'!
ERROR!
!InvalidCreditCard class methodsFor: 'assert' stamp: 'I 6/6/2024 00:09:09' prior: 50615499!
assertDate: expirationDate 
	| month year currentYear currentMonth |
	
	month := (((expirationDate at: 1)asString )asInteger ) ,(((expirationDate at: 2)asString)asInteger) .
	year := expirationDate copyFrom: 3 .

	"Convertir los valores a números"
	month := month asInteger.
	year := year asInteger.

	"Obtener el mes y año actual"
	currentYear := Date today year.
	currentMonth := Date today month.

	"Validar el formato y la validez de la fecha"
	(month between: 1 and: 12)
	    ifFalse: [^'Mes inválido'].
	(year < currentYear or: (year = currentYear and: month < currentMonth))
	    ifTrue: [^'Fecha de expiración ya pasada'].! !

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/6/2024 00:09:14'!
ERROR!

'0' asIntegerArray !

x := 'Hola' copyFrom: 1 to: 2 !
!InvalidCreditCard class methodsFor: 'assert' stamp: 'I 6/6/2024 00:14:14' prior: 50615530!
assertDate: expirationDate 
	| month year currentYear currentMonth |
	
	month := expirationDate copyFrom: 1 to: 2. 
	year := expirationDate copyFrom: 3 to: 7.

	"Convertir los valores a números"
	month := month asInteger.
	year := year asInteger.

	"Obtener el mes y año actual"
	currentYear := Date today year.
	currentMonth := Date today month.

	"Validar el formato y la validez de la fecha"
	(month between: 1 and: 12)
	    ifFalse: [^'Mes inválido'].
	(year < currentYear or: (year = currentYear and: month < currentMonth))
	    ifTrue: [^'Fecha de expiración ya pasada'].! !

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/6/2024 00:14:53'!
ERROR!
!InvalidCreditCard class methodsFor: 'assert' stamp: 'I 6/6/2024 00:15:17' prior: 50615559!
assertDate: expirationDate 
	| month year currentYear currentMonth |
	
	month := expirationDate copyFrom: 1 to: 2. 
	year := expirationDate copyFrom: 3 to: 6.

	"Convertir los valores a números"
	month := month asInteger.
	year := year asInteger.

	"Obtener el mes y año actual"
	currentYear := Date today year.
	currentMonth := Date today month.

	"Validar el formato y la validez de la fecha"
	(month between: 1 and: 12)
	    ifFalse: [^'Mes inválido'].
	(year < currentYear or: (year = currentYear and: month < currentMonth))
	    ifTrue: [^'Fecha de expiración ya pasada'].! !

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/6/2024 00:15:27'!
ERROR!
!InvalidCreditCard class methodsFor: 'assert' stamp: 'I 6/6/2024 00:16:26' prior: 50615584!
assertDate: expirationDate 
	| month year currentYear currentMonth |
	
	month := expirationDate copyFrom: 1 to: 2. 
	year := expirationDate copyFrom: 3 to: 6.

	"Convertir los valores a números"
	month := month asNumber .
	year := year asNumber .

	"Obtener el mes y año actual"
	currentYear := Date today year.
	currentMonth := Date today month.

	"Validar el formato y la validez de la fecha"
	(month between: 1 and: 12)
	    ifFalse: [^'Mes inválido'].
	(year < currentYear or: (year = currentYear and: month < currentMonth))
	    ifTrue: [^'Fecha de expiración ya pasada'].! !
!InvalidCreditCard class methodsFor: 'assert' stamp: 'I 6/6/2024 00:17:35' prior: 50615609!
assertDate: expirationDate 
	| month year currentYear currentMonth |
	
	month := expirationDate copyFrom: 1 to: 2. 
	year := expirationDate copyFrom: 3 to: 6.

	"Convertir los valores a números"
	month := month asNumber .
	year := year asNumber .

	"Obtener el mes y año actual"
	currentYear := Date today year.
	currentMonth := Date today monthIndex .

	"Validar el formato y la validez de la fecha"
	(month between: 1 and: 12)
	    ifFalse: [^'Mes inválido'].
	(year < currentYear or: (year = currentYear and: month < currentMonth))
	    ifTrue: [^'Fecha de expiración ya pasada'].! !

Date today yearNumber !
!InvalidCreditCard class methodsFor: 'assert' stamp: 'I 6/6/2024 00:19:59' prior: 50615631!
assertDate: expirationDate 
	| month year currentYear currentMonth |
	
	month := expirationDate copyFrom: 1 to: 2. 
	year := expirationDate copyFrom: 3 to: 6.

	"Convertir los valores a números"
	month := month asNumber .
	year := year asNumber .

	"Obtener el mes y año actual"
	currentYear := Date today yearNumber .
	currentMonth := Date today monthIndex .

	"Validar el formato y la validez de la fecha"
	(month between: 1 and: 12)
	    ifFalse: [^'Mes inválido'].
	(year < currentYear or: (year = currentYear and: month < currentMonth))
	    ifTrue: [^'Fecha de expiración ya pasada'].! !
!InvalidCreditCard class methodsFor: 'assert' stamp: 'I 6/6/2024 00:20:56' prior: 50615654!
assertDate: expirationDate 
	| month year currentYear currentMonth |
	
	month := expirationDate copyFrom: 1 to: 2. 
	year := expirationDate copyFrom: 3 to: 6.

	"Convertir los valores a números"
	month := month asNumber .
	year := year asNumber .

	"Obtener el mes y año actual"
	currentYear := Date today yearNumber .
	currentMonth := Date today monthIndex .

	"Validar el formato y la validez de la fecha"
	(month between: 1 and: 12)
	    ifFalse: [^self error: self invalidMonth].
	(year < currentYear or: (year = currentYear and: month < currentMonth))
	    ifTrue: [^self error: self cardExpired].! !

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/6/2024 00:21:03'!
ERROR!
!InvalidCreditCard class methodsFor: 'assert' stamp: 'I 6/6/2024 00:21:37' prior: 50615676!
assertDate: expirationDate 
	| month year currentYear currentMonth |
	
	month := expirationDate copyFrom: 1 to: 2. 
	year := expirationDate copyFrom: 3 to: 6.

	"Convertir los valores a números"
	month := month asNumber .
	year := year asNumber .

	"Obtener el mes y año actual"
	currentYear := Date today yearNumber .
	currentMonth := Date today monthIndex .

	"Validar el formato y la validez de la fecha"
	(month between: 1 and: 12)
	   or:[
	(year < currentYear or: (year = currentYear and: month < currentMonth))
	    ]! !

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/6/2024 00:21:40'!
ERROR!
!InvalidCreditCard class methodsFor: 'assert' stamp: 'I 6/6/2024 00:21:49' prior: 50615702!
assertDate: expirationDate 
	| month year currentYear currentMonth |
	
	month := expirationDate copyFrom: 1 to: 2. 
	year := expirationDate copyFrom: 3 to: 6.

	"Convertir los valores a números"
	month := month asNumber .
	year := year asNumber .

	"Obtener el mes y año actual"
	currentYear := Date today yearNumber .
	currentMonth := Date today monthIndex .

	"Validar el formato y la validez de la fecha"
	^(month between: 1 and: 12)
	   or:[
	(year < currentYear or: (year = currentYear and: month < currentMonth))
	    ]! !

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/6/2024 00:21:51'!
ERROR!
!InvalidCreditCard class methodsFor: 'assert' stamp: 'I 6/6/2024 00:22:11' prior: 50615350!
canHandleNumber: aCardNumber anExpirationDate: expirationDate 
	^(((aCardNumber size) = 16) not) or:[self assertDate: expirationDate].! !

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/6/2024 00:22:13'!
ERROR!
!ValidCreditCard class methodsFor: 'nil' stamp: 'I 6/6/2024 00:30:35'!
canHandleNumber: aCardNumber anExpirationDate: expirationDate 
	^(((aCardNumber size) = 16) not) or:[self assertDate: expirationDate].! !
!ValidCreditCard class methodsFor: 'as yet unclassified' stamp: 'I 6/6/2024 00:30:45' prior: 50615761!
canHandleNumber: aCardNumber anExpirationDate: expirationDate 
	^(((aCardNumber size) = 16)) or:[self assertDate: expirationDate].! !
!CashierTest methodsFor: 'tests' stamp: 'I 6/6/2024 00:30:49' prior: 50615361!
test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook
	|cashier cart book anotherBook catalog total creditCard|
	
	creditCard := CreditCard withNumber: '1003812903712037' withExpirationDate: '022030' withOwner: 'Jose'.
	
	book := 1928374617.
	anotherBook := 1913374617.
	
	catalog := Dictionary new.
	catalog at: book put: 10.
	catalog at: anotherBook put: 20.
	cart := Cart withCatalog: catalog .
	
	cart add: book.
	cart add: anotherBook .
	cashier := Cashier new.
	
	total := cashier checkOut: cart.
	
	self assert: 30 equals: total.! !

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/6/2024 00:30:51'!
ERROR!

 subclasses
		ifNil: [#()]
		ifNotNil: [subclasses copy]!

 subclass canHandleNumber: aCardNumber anExpirationDate: expirationDate!

(((aCardNumber size) = 16) not)!
!InvalidCreditCard class methodsFor: 'assert' stamp: 'I 6/6/2024 00:36:05' prior: 50615726!
assertDate: expirationDate 
	| month year currentYear currentMonth |
	
	month := expirationDate copyFrom: 1 to: 2. 
	year := expirationDate copyFrom: 3 to: 6.

	"Convertir los valores a números"
	month := month asNumber .
	year := year asNumber .

	"Obtener el mes y año actual"
	currentYear := Date today yearNumber .
	currentMonth := Date today monthIndex .

	"Validar el formato y la validez de la fecha"
	^((month between: 1 and: 12)not)
	   or:[
	(year < currentYear or: (year = currentYear and: month < currentMonth))
	    ]! !
!InvalidCreditCard class methodsFor: 'assert' stamp: 'I 6/6/2024 00:38:42' prior: 50615805!
assertDate: expirationDate 
	| month year currentYear currentMonth |
	
	month := expirationDate copyFrom: 1 to: 2. 
	year := expirationDate copyFrom: 3 to: 6.

	"Convertir los valores a números"
	month := month asNumber .
	year := year asNumber .

	"Obtener el mes y año actual"
	currentYear := Date today yearNumber .
	currentMonth := Date today monthIndex .

	"Validar el formato y la validez de la fecha"
	^((month between: 1 and: 12)not)
	   or:[
	(year > currentYear or: (year = currentYear and: month > currentMonth))
	    ]! !

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/6/2024 00:38:45'!
ERROR!

!testRun: #CashierTest #test05CashierChecksIsValidCardAndChecksOutACartWithTwoBook stamp: 'I 6/6/2024 00:38:49'!
ERROR!

((month between: 1 and: 12)not)!

(year > currentYear or: (year = currentYear and: month > currentMonth))!
!CreditCard class methodsFor: 'instance creation' stamp: 'I 6/6/2024 00:40:23' prior: 50615204!
withNumber: aCardNumber withExpirationDate: expirationDate withOwner: cardOwner 
	^(self subclasses detect:[:subclass| subclass canHandleNumber: aCardNumber anExpirationDate: expirationDate]) withNumber: aCardNumber withExpirationDate: expirationDate withOwner: cardOwner .
"
	^self new initializeWithNumber: aCardNumber withExpirationDate: expirationDate withOwner: cardOwner "! !
!InvalidCreditCard class methodsFor: 'nil' stamp: 'I 6/6/2024 00:40:52' overrides: 50615856!
withNumber: aCardNumber withExpirationDate: expirationDate withOwner: cardOwner! !

----QUIT----(6 June 2024 00:42:05) CuisUniversity-6169.image priorSource: 9041485!